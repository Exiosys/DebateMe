'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezer = require('lezer');

// This file was generated by lezer-generator. You probably shouldn't edit it.
const 
  StartTag = 3,
  StartCloseTag = 4,
  MismatchedStartCloseTag = 5,
  missingCloseTag = 39,
  SelfCloserEndTag = 6,
  Element = 11,
  OpenTag = 12,
  SelfClosingTag = 22,
  RawText = 27;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33;

const tagStartExpr = /^<\s*([\.\-\:\w\xa1-\uffff]+)/;

const elementQuery = [Element];

const tagStart = new lezer.ExternalTokenizer((input, token, stack) => {
  let pos = token.start, first = input.get(pos);
  // End of file, just close anything
  if (first < 0) {
    let contextStart = stack.startOf(elementQuery);
    let match = contextStart < 0 ? null : tagStartExpr.exec(input.read(contextStart, contextStart + 30));
    if (match && implicitlyClosed[match[1].toLowerCase()]) token.accept(missingCloseTag, token.start);
  }
  if (first != lessThan) return
  pos++;
  let close = false, tokEnd = pos;
  for (let next; next = input.get(pos);) {
    if (next == slash && !close) { close = true; pos++; tokEnd = pos; }
    else if (next == question || next == bang) return
    else if (isSpace(next)) pos++;
    else break
  }
  let nameStart = pos;
  while (nameChar(input.get(pos))) pos++;
  if (pos > nameStart) {
    let name = input.read(nameStart, pos).toLowerCase();
    let contextStart = stack.startOf(elementQuery);
    let match = contextStart < 0 ? null : tagStartExpr.exec(input.read(contextStart, contextStart + name.length + 10));
    if (match) {
      let contextName = match[1].toLowerCase();
      if (close && name != contextName)
        return implicitlyClosed[contextName] ? token.accept(missingCloseTag, token.start)
          : token.accept(MismatchedStartCloseTag, tokEnd)
      if (!close && closeOnOpen[contextName] && closeOnOpen[contextName][name])
        return token.accept(missingCloseTag, token.start)
    }
  }
  token.accept(close ? StartCloseTag : StartTag, tokEnd);
}, {contextual: true});

const tagQuery = [OpenTag, SelfClosingTag];

const selfClosed = new lezer.ExternalTokenizer((input, token, stack) => {
  if (input.get(token.start) != greaterThan) return
  let from = stack.startOf(tagQuery);
  let match = from < 0 ? null : tagStartExpr.exec(input.read(from, token.start));
  if (match && selfClosers[match[1].toLowerCase()]) token.accept(SelfCloserEndTag, token.start + 1);
}, {contextual: true});

const openTag = /^<\/?\s*([\.\-\:\w\xa1-\uffff]+)/;

function tagName(tag) {
  let m = openTag.exec(tag);
  return m ? m[1].toLowerCase() : null
}

function attributes(tag) {
  let open = openTag.exec(tag), attrs = {};
  if (open) {
    let attr = /\s*([\.\-\:\w\xa1-\uffff]+)\s*(?:=("[^"]*"|'[^']*'|[^\s=<>"'/]+))?/g, m;
    attr.lastIndex = open.index + open[0].length;
    while (m = attr.exec(tag)) attrs[m[1]] = m[2] || m[1];
  }
  return attrs
}

const stay = {stay: true};

function skip(name) { return token => tagName(token) == name }

// tags: {
//   tag: string,
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser?: Parser,
//   parseNode?: (input: InputStream, start: number) => Tree
// }[]

function resolveContent(tags) {
  let tagMap = null;
  for (let tag of tags) {
    if (!tagMap) tagMap = Object.create(null)
    ;(tagMap[tag.tag] || (tagMap[tag.tag] = [])).push({
      attrs: tag.attrs,
      value: {
        filterEnd: skip(tag.tag),
        parser: tag.parser,
        parseNode: tag.parseNode
      }
    });
  }
  return function(input, stack) {
    let openTag = input.read(stack.ruleStart, stack.pos);
    let name = tagName(openTag), matches, attrs;
    if (!name) return stay
    if (tagMap && (matches = tagMap[name])) {
      for (let match of matches) {
        if (!match.attrs || match.attrs(attrs || (attrs = attributes(openTag)))) return match.value
      }
    }
    if (name == "script" || name == "textarea" || name == "style") return {
      filterEnd: skip(name),
      wrapType: RawText
    }
    return stay
  }
}

const elementContent = resolveContent([]);

function configureTags(parser, tags) {
  return parser.withNested({elementContent: resolveContent(tags)})
}

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = lezer.Parser.deserialize({
  states: "'bOPOTOOOgOTO'#C}O!QOWO'#ChS!XOTO'#CgOOOS'#Cg'#CgOOOS'#DU'#DUOOOS(3A[(3A[QOOOOOOOOS,59d,59dO!uOWO'#DOOOOW(3A](3A]O#POWO,59SO#TOTO'#DROOOS(3A`(3A`OOOO'#DY'#DYO#qOPO,59ROOOW,59e,59eO#{ObO1G.nOOOS,59h,59hO!QOWO'#CpO$]OpO'#CpOOOS1G.m1G.mO$dObO'#DOO$wObO7+$YO%UOWO,59[O%YOpO'#DOO%aOpO,59[O%eObO'#DPO%rObO'#CjOOO`(3A^(3A^O&VOYO<<GtO&aOWO1G.vOOO`,59f,59fO&hObO,59UOOOSAN=`AN=`OOOSAN=jAN=jO&xOWO7+$bO&|O!bO1G.pOOOS<<G|<<G|O'WO!bO'#DOO'bO!bO7+$[O'iO#tO'#CmO#{ObO<<GvO'vO#tO'#DQOOO#t(3A_(3A_O(TOWO,59XOOO`AN=bAN=bOOO#t,59g,59gOOO`1G.s1G.s",
  stateData: "(]~RQOWTOXTOYTOhTOiTOjUO~RQOWTOXTOYTOhTOiTOjUOvqX~yYO]rP~RQOWTOXTOYTOhTOiTOSuPTuPwuP~yYO]rXcrX~]aO~RQOWTOXTOYTOhTOiTOSuXTuXwuX~ScOTdOweO~yYOUrP_rPcrPgrP~yYOerP~yYOUrX_rXcrXgrX`rX~_lOUsPcsPgsP~]oO~yYOerX~eoO~_lOUsXcsXgsX~yYOUrP_rP`rPcrPgrP~UsOcrOgsO~yYOcrP~`uOU^a_^ac^ag^a~cvO~yYObrPzrP~yYObrXzrX~bzOzyO~X|OY|O{|OztP~X|OY|O{|OztX~z!QO~hij~",
  goto: "$m}PPPPPPPPPPP!O!UP![PP!`PP!cP!fPPPPP!l!r#Y#`#f#l#o$X$[$_PP$bPPP$jXTOPR[XROPR[TmgkRzxRe_XSOPR[QPORWPUXQcoW`XfiwUfalzQidRwuQkgRpkQ{yR!P{Q[RRb[RVOQZQQgaQhcQjdQqlQtoQxuR!OzRngR}yR^RSUOPT]R[R_R",
  nodeNames: "⚠ Document ⚠ StartTag StartCloseTag StartCloseTag SelfCloserEndTag Document Text EntityReference CharacterReference Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag CloseTag MismatchedTagName SelfClosingTag SelfCloseEndTag Comment ProcessingInst DoctypeDecl RawText",
  repeatNodeCount: 5,
  tokenData: "Gh!aR!UOX$eXY'rYZ'rZ]$e]^'r^p$epq'rqr$ers(tsv$evw)Uwx%yx!P$e!P!Q0i!Q![$e![!]1u!]!^$e!^!_7`!_!`Dt!`!aEa!a!c$e!c!}1u!}#R$e#R#S1u#S#T$e#T#o1u#o$f$e$f$g%y$g%W$e%W%o1u%o%p$e%p&a1u&a&b$e&b1p1u1p4U$e4U4d1u4d4e$e4e$IS1u$IS$I`$e$I`$Ib1u$Ib$Kh$e$Kh%#t1u%#t&/x$e&/x&Et1u&Et&FV$e&FV;'S1u;'S;:jE|;:j?&r$e?&r?Ah1u?Ah?BY$e?BY?Mn1u?Mn~$e!R$ncWPb`{pOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx!P$e!P!Q%y!Q!^$e!^!_&r!_!a%y!a$f$e$f$g%y$g~$eq&QUWP{pOr%yrs&dsv%yw!^%y!^!_&r!_~%yP&iRWPOv&dw!^&d!_~&dp&wR{pOr&rsv&rw~&r`'VXb`OX'QZ]'Q^p'Qqr'Qsw'Qx!P'Q!Q!^'Q!a$f'Q$g~'Q!a'{]WP{pynOX%yXY'rYZ'rZ]%y]^'r^p%ypq'rqr%yrs&dsv%yw!^%y!^!_&r!_~%y!T({Rz!SWPOv&dw!^&d!_~&d!R)Zbb`OX*cXZ+pZ]*c]^+p^p*cqr*crs+pst,{tw*cwx+px!P*c!P!Q+p!Q!]*c!]!^'Q!^!a+p!a$f*c$f$g+p$g~*c!R*hbb`OX*cXZ+pZ]*c]^+p^p*cqr*crs+pst'Qtw*cwx+px!P*c!P!Q+p!Q!]*c!]!^,X!^!a+p!a$f*c$f$g+p$g~*cq+sTOp+pqs+pt!]+p!]!^,S!^~+pq,XOXq!R,`XXqb`OX'QZ]'Q^p'Qqr'Qsw'Qx!P'Q!Q!^'Q!a$f'Q$g~'Q!R-Qab`OX.VXZ/aZ].V]^/a^p.Vqr.Vrs/asw.Vwx/ax!P.V!P!Q/a!Q!].V!]!^'Q!^!a/a!a$f.V$f$g/a$g~.V!R.[ab`OX.VXZ/aZ].V]^/a^p.Vqr.Vrs/asw.Vwx/ax!P.V!P!Q/a!Q!].V!]!^/u!^!a/a!a$f.V$f$g/a$g~.Vq/dSOp/aq!]/a!]!^/p!^~/aq/uOYq!R/|XYqb`OX'QZ]'Q^p'Qqr'Qsw'Qx!P'Q!Q!^'Q!a$f'Q$g~'Qw0pWWP{pOr%yrs&dsv%yw!^%y!^!_&r!_!`%y!`!a1Y!a~%yw1cUgUWP{pOr%yrs&dsv%yw!^%y!^!_&r!_~%y!a2U!Y_SeW]QWPb`{pOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx}$e}!O1u!O!P1u!P!Q%y!Q![1u![!]1u!]!^$e!^!_&r!_!a%y!a!c$e!c!}1u!}#R$e#R#S1u#S#T$e#T#o1u#o$f$e$f$g%y$g$}$e$}%O1u%O%W$e%W%o1u%o%p$e%p&a1u&a&b$e&b1p1u1p4U1u4U4d1u4d4e$e4e$IS1u$IS$I`$e$I`$Ib1u$Ib$Je$e$Je$Jg1u$Jg$Kh$e$Kh%#t1u%#t&/x$e&/x&Et1u&Et&FV$e&FV;'S1u;'S;:j5t;:j?&r$e?&r?Ah1u?Ah?BY$e?BY?Mn1u?Mn~$e!a5}eWPb`{pOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx!P$e!P!Q%y!Q!^$e!^!_&r!_!a%y!a$f$e$f$g%y$g;=`$e;=`<%l1u<%l~$eq7eU{pOq&rqr7wsv&rw!a&r!a!bBo!b~&rq7|X{pOr&rsv&rw}&r}!O8i!O!f&r!f!g<W!g#W&r#W#X@R#X~&rq8nT{pOr&rsv&rw}&r}!O8}!O~&rq9SV{pOr8}rs9isv8}vw9iw}8}}!O:j!O~8}P9lRO}9i}!O9u!O~9iP9xRO}9i}!O:R!O~9iP:UTO}9i}!O:R!O!`9i!`!a:e!a~9iP:jOhPq:oV{pOr8}rs9isv8}vw9iw}8}}!O;U!O~8}q;ZX{pOr8}rs9isv8}vw9iw}8}}!O;U!O!`8}!`!a;v!a~8}q;}R{phPOr&rsv&rw~&rq<]T{pOr&rsv&rw!q&r!q!r<l!r~&rq<qT{pOr&rsv&rw!e&r!e!f=Q!f~&rq=VT{pOr&rsv&rw!v&r!v!w=f!w~&rq=kT{pOr&rsv&rw!{&r!{!|=z!|~&rq>PT{pOr&rsv&rw!r&r!r!s>`!s~&rq>eT{pOr&rsv&rw!g&r!g!h>t!h~&rq>yV{pOr>trs?`sv>tvw?`w!`>t!`!a?q!a~>tP?cRO!`?`!`!a?l!a~?`P?qOjPq?xR{pjPOr&rsv&rw~&rq@WT{pOr&rsv&rw#c&r#c#d@g#d~&rq@lT{pOr&rsv&rw#V&r#V#W@{#W~&rqAQT{pOr&rsv&rw#h&r#h#iAa#i~&rqAfT{pOr&rsv&rw#m&r#m#nAu#n~&rqAzT{pOr&rsv&rw#d&r#d#eBZ#e~&rqB`T{pOr&rsv&rw#X&r#X#Y>t#Y~&rqBtV{pOrBorsCZsvBovwCZw!aBo!a!bCx!b~BoPC^RO!aCZ!a!bCg!b~CZPCjRO!`CZ!`!aCs!a~CZPCxOiPqC}V{pOrBorsCZsvBovwCZw!`Bo!`!aDd!a~BoqDkR{piPOr&rsv&rw~&ruD}U`SWP{pOr%yrs&dsv%yw!^%y!^!_&r!_~%ywEjUcUWP{pOr%yrs&dsv%yw!^%y!^!_&r!_~%y!aFVeWPb`{pOX$eXZ%yZ]$e]^%y^p$epq%yqr$ers&dsv$evw'Qwx%yx!P$e!P!Q%y!Q!^$e!^!_&r!_!a%y!a$f$e$f$g%y$g;=`$e;=`<%l1u<%l~$e",
  tokenizers: [tagStart, selfClosed, 0, 1, 2, 3, 4, 5],
  nested: [["elementContent", elementContent,"&k~RP!^!_U~XP!P!Q[~_dXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~!pdXY!mYZ!m]^!mpq!m![!]$O!c!}$O#R#S$O#T#o$O%W%o$O%p&a$O&b1p$O4U4d$O4e$IS$O$I`$Ib$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&e?&r?Ah$O?BY?Mn$O~$RkXY%vYZ%v]^%vpq%v}!O$O!O!P$O!Q![$O![!]$O!`!a&Y!c!}$O#R#S$O#T#o$O$}%O$O%W%o$O%p&a$O&b1p$O1p4U$O4U4d$O4e$IS$O$I`$Ib$O$Je$Jg$O$Kh%#t$O&/x&Et$O&FV;'S$O;'S;:j&_?&r?Ah$O?BY?Mn$O~%yTXY%vYZ%v]^%vpq%v!`!a&Y~&_Ov~~&bP;=`<%l$O~&hP;=`<%l$O", 44]],
  specializeTable: 0,
  tokenPrec: 331
});

function configureHTML(tags) { return configureTags(parser, tags) }

exports.configureHTML = configureHTML;
exports.parser = parser;

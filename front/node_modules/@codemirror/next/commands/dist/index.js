'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('../../state');

function moveSelection(view, dir, granularity) {
    let transaction = view.state.t().forEachRange(range => {
        if (!range.empty && granularity != "lineboundary")
            return new state.SelectionRange(dir == "left" || dir == "backward" ? range.from : range.to);
        return new state.SelectionRange(view.movePos(range.head, dir, granularity, "move"));
    });
    if (transaction.selection.eq(view.state.selection))
        return false;
    if (granularity == "line")
        transaction.annotate(state.Transaction.preserveGoalColumn, true);
    view.dispatch(transaction.scrollIntoView());
    return true;
}
/// Move the selection one character to the left (which is backward in
/// left-to-right text, forward in right-to-left text).
const moveCharLeft = view => moveSelection(view, "left", "character");
/// Move the selection one character to the right.
const moveCharRight = view => moveSelection(view, "right", "character");
/// Move the selection one word to the left.
const moveWordLeft = view => moveSelection(view, "left", "word");
/// Move the selection one word to the right.
const moveWordRight = view => moveSelection(view, "right", "word");
/// Move the selection one line up.
const moveLineUp = view => moveSelection(view, "backward", "line");
/// Move the selection one line down.
const moveLineDown = view => moveSelection(view, "forward", "line");
/// Move the selection to the start of the line.
const moveLineStart = view => moveSelection(view, "backward", "lineboundary");
/// Move the selection to the end of the line.
const moveLineEnd = view => moveSelection(view, "forward", "lineboundary");
function extendSelection(view, dir, granularity) {
    let transaction = view.state.t().forEachRange(range => {
        return new state.SelectionRange(range.anchor, view.movePos(range.head, dir, granularity, "extend"));
    });
    if (transaction.selection.eq(view.state.selection))
        return false;
    if (granularity == "line")
        transaction.annotate(state.Transaction.preserveGoalColumn, true);
    view.dispatch(transaction.scrollIntoView());
    return true;
}
/// Move the selection head one character to the left, while leaving
/// the anchor in place.
const extendCharLeft = view => extendSelection(view, "left", "character");
/// Move the selection head one character to the right.
const extendCharRight = view => extendSelection(view, "right", "character");
/// Move the selection head one word to the left.
const extendWordLeft = view => extendSelection(view, "left", "word");
/// Move the selection head one word to the right.
const extendWordRight = view => extendSelection(view, "right", "word");
/// Move the selection head one line up.
const extendLineUp = view => extendSelection(view, "backward", "line");
/// Move the selection head one line down.
const extendLineDown = view => extendSelection(view, "forward", "line");
/// Move the selection head to the start of the line.
const extendLineStart = view => extendSelection(view, "backward", "lineboundary");
/// Move the selection head to the end of the line.
const extendLineEnd = view => extendSelection(view, "forward", "lineboundary");
/// Move the selection to the start of the document.
const selectDocStart = ({ state: state$1, dispatch }) => {
    dispatch(state$1.t().setSelection(state.EditorSelection.single(0)).scrollIntoView());
    return true;
};
/// Move the selection to the end of the document.
const selectDocEnd = ({ state: state$1, dispatch }) => {
    dispatch(state$1.t().setSelection(state.EditorSelection.single(state$1.doc.length)).scrollIntoView());
    return true;
};
/// Select the entire document.
const selectAll = ({ state: state$1, dispatch }) => {
    dispatch(state$1.t().setSelection(state.EditorSelection.single(0, state$1.doc.length)));
    return true;
};
function deleteText(view, dir) {
    let transaction = view.state.t().forEachRange((range, transaction) => {
        let { from, to } = range;
        if (from == to) {
            let target = view.movePos(range.head, dir, "character", "move");
            from = Math.min(from, target);
            to = Math.max(to, target);
        }
        if (from == to)
            return range;
        transaction.replace(from, to, "");
        return new state.SelectionRange(from);
    });
    if (!transaction.docChanged)
        return false;
    view.dispatch(transaction.scrollIntoView());
    return true;
}
/// Delete the character before the cursor (which is the one to left
/// in left-to-right text, but the one to the right in right-to-left
/// text).
const deleteCharBackward = view => deleteText(view, "backward");
/// Delete the character after the cursor.
const deleteCharForward = view => deleteText(view, "forward");
// FIXME support indenting by tab, configurable indent units
function space(n) {
    let result = "";
    for (let i = 0; i < n; i++)
        result += " ";
    return result;
}
function getIndentation(state$1, pos) {
    for (let f of state$1.facet(state.EditorState.indentation)) {
        let result = f(state$1, pos);
        if (result > -1)
            return result;
    }
    return -1;
}
/// Replace the selection with a newline and indent the newly created
/// line(s).
const insertNewlineAndIndent = ({ state: state$1, dispatch }) => {
    let i = 0, indentation = state$1.selection.ranges.map(r => {
        let indent = getIndentation(state$1, r.from);
        return indent > -1 ? indent : /^\s*/.exec(state$1.doc.lineAt(r.from).slice(0, 50))[0].length;
    });
    dispatch(state$1.t().forEachRange(({ from, to }, tr) => {
        let indent = indentation[i++], line = tr.doc.lineAt(to);
        while (to < line.end && /s/.test(line.slice(to - line.start, to + 1 - line.start)))
            to++;
        tr.replace(from, to, ["", space(indent)]);
        return new state.SelectionRange(from + indent + 1);
    }).scrollIntoView());
    return true;
};
/// Auto-indent the selected lines. This uses the [indentation
/// behavor](#state.EditorState^indentation) as source.
const indentSelection = ({ state, dispatch }) => {
    // FIXME this will base all indentation on the same state, which is
    // wrong (indentation looks at the indent of previous lines, which may
    // be changed).
    let lastLine = -1, positions = [];
    for (let range of state.selection.ranges) {
        for (let { start, end } = state.doc.lineAt(range.from);;) {
            if (start != lastLine) {
                lastLine = start;
                let indent = getIndentation(state, start), current;
                if (indent > -1 &&
                    indent != (current = /^\s*/.exec(state.doc.slice(start, Math.min(end, start + 100)))[0].length))
                    positions.push({ pos: start, current, indent });
            }
            if (end + 1 > range.to)
                break;
            ({ start, end } = state.doc.lineAt(end + 1));
        }
    }
    if (positions.length > 0) {
        let tr = state.t();
        for (let { pos, current, indent } of positions) {
            let start = tr.changes.mapPos(pos);
            tr.replace(start, start + current, space(indent));
        }
        dispatch(tr);
    }
    return true;
};
/// The default keymap for Linux/Windows/non-Mac platforms. Binds the
/// arrows for cursor motion, shift-arrow for selection extension,
/// ctrl-arrows for by-word motion, home/end for line start/end,
/// ctrl-home/end for document start/end, ctrl-a to select all,
/// backspace/delete for deletion, and enter for newline-and-indent.
const pcBaseKeymap = {
    "ArrowLeft": moveCharLeft,
    "ArrowRight": moveCharRight,
    "Shift-ArrowLeft": extendCharLeft,
    "Shift-ArrowRight": extendCharRight,
    "Mod-ArrowLeft": moveWordLeft,
    "Mod-ArrowRight": moveWordRight,
    "Shift-Mod-ArrowLeft": extendWordLeft,
    "Shift-Mod-ArrowRight": extendWordRight,
    "ArrowUp": moveLineUp,
    "ArrowDown": moveLineDown,
    "Shift-ArrowUp": extendLineUp,
    "Shift-ArrowDown": extendLineDown,
    "Home": moveLineStart,
    "End": moveLineEnd,
    "Shift-Home": extendLineStart,
    "Shift-End": extendLineEnd,
    "Mod-Home": selectDocStart,
    "Mod-End": selectDocEnd,
    "Mod-a": selectAll,
    "Backspace": deleteCharBackward,
    "Delete": deleteCharForward,
    "Enter": insertNewlineAndIndent
};
/// The default keymap for Mac platforms. Includes the bindings from
/// the [PC keymap](#commands.pcBaseKeymap) (using Cmd instead of
/// Ctrl), and adds Mac-specific default bindings.
const macBaseKeymap = {
    "Control-b": moveCharLeft,
    "Control-f": moveCharRight,
    "Shift-Control-b": extendCharLeft,
    "Shift-Control-f": extendCharRight,
    "Control-p": moveLineUp,
    "Control-n": moveLineDown,
    "Shift-Control-p": extendLineUp,
    "Shift-Control-n": extendLineDown,
    "Control-a": moveLineStart,
    "Control-e": moveLineEnd,
    "Shift-Control-a": extendLineStart,
    "Shift-Control-e": extendLineEnd,
    "Cmd-ArrowUp": selectDocStart,
    "Cmd-ArrowDown": selectDocEnd,
    "Control-d": deleteCharForward,
    "Control-h": deleteCharBackward
};
for (let key in pcBaseKeymap)
    macBaseKeymap[key] = pcBaseKeymap[key];
const mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform)
    : typeof os != "undefined" ? os.platform() == "darwin" : false;
/// The default keymap for the current platform.
const baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;

exports.baseKeymap = baseKeymap;
exports.deleteCharBackward = deleteCharBackward;
exports.deleteCharForward = deleteCharForward;
exports.extendCharLeft = extendCharLeft;
exports.extendCharRight = extendCharRight;
exports.extendLineDown = extendLineDown;
exports.extendLineEnd = extendLineEnd;
exports.extendLineStart = extendLineStart;
exports.extendLineUp = extendLineUp;
exports.extendWordLeft = extendWordLeft;
exports.extendWordRight = extendWordRight;
exports.indentSelection = indentSelection;
exports.insertNewlineAndIndent = insertNewlineAndIndent;
exports.macBaseKeymap = macBaseKeymap;
exports.moveCharLeft = moveCharLeft;
exports.moveCharRight = moveCharRight;
exports.moveLineDown = moveLineDown;
exports.moveLineEnd = moveLineEnd;
exports.moveLineStart = moveLineStart;
exports.moveLineUp = moveLineUp;
exports.moveWordLeft = moveWordLeft;
exports.moveWordRight = moveWordRight;
exports.pcBaseKeymap = pcBaseKeymap;
exports.selectAll = selectAll;
exports.selectDocEnd = selectDocEnd;
exports.selectDocStart = selectDocStart;

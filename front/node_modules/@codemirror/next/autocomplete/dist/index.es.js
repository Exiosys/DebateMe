import { ViewPlugin, EditorView } from '../../view';
import { EditorState, Facet, combineConfig, Precedence, EditorSelection, Annotation, StateField, Transaction } from '../../state';
import { keymap } from '../../keymap';
import { tooltips, showTooltip } from '../../tooltip';

function completeFromSyntax(state, pos) {
    let syntax = state.facet(EditorState.syntax);
    if (syntax.length == 0)
        return { items: [] };
    let { completeAt } = syntax[0].languageDataAt(state, pos);
    return completeAt ? completeAt(state, pos) : { items: [] };
}
function sortAndFilterCompletion(substr, items) {
    const startMatch = [], inMatch = [];
    for (const item of items) {
        if (item.label == substr)
            continue;
        // FIXME: separate key
        else if (item.label.startsWith(substr))
            startMatch.push(item);
        else if (item.label.includes(substr))
            inMatch.push(item);
    }
    return startMatch.concat(inMatch);
}
const autocompleteConfig = Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            completeAt(state, pos) {
                return completeFromSyntax(state, pos) || { start: pos, items: [] };
            }
        });
    }
});
function autocomplete(config = {}) {
    return [
        activeCompletion,
        autocompleteConfig.of(config),
        autocompletePlugin,
        Precedence.Fallback.set(style),
        tooltips(),
        Precedence.Override.set(keymap({
            ArrowDown: moveCompletion("down"),
            ArrowUp: moveCompletion("up"),
            Enter: acceptCompletion,
            Escape: closeCompletion
        }))
    ];
}
function moveCompletion(dir) {
    return (view) => {
        let active = view.state.field(activeCompletion);
        if (!(active instanceof ActiveCompletion))
            return false;
        let selected = (active.selected + (dir == "up" ? active.options.length - 1 : 1)) % active.options.length;
        view.dispatch(view.state.t().annotate(setActiveCompletion, new ActiveCompletion(active.options, selected, active.tooltip)));
        return true;
    };
}
function acceptCompletion(view) {
    let active = view.state.field(activeCompletion);
    if (!(active instanceof ActiveCompletion))
        return false;
    applyCompletion(view, active.options[active.selected]);
    return true;
}
function startCompletion(view) {
    let active = view.state.field(activeCompletion);
    if (active != null)
        return false;
    view.dispatch(view.state.t().annotate(setActiveCompletion, "pending"));
    return true;
}
function applyCompletion(view, option) {
    let apply = option.apply || option.label;
    // FIXME make sure option.start/end still point at the current
    // doc, or keep a mapping in an active completion
    if (typeof apply == "string") {
        view.dispatch(view.state.t().replace(option.start, option.end, apply)
            .setSelection(EditorSelection.single(option.start + apply.length)));
    }
    else {
        apply(view);
    }
}
function closeCompletion(view) {
    let active = view.state.field(activeCompletion);
    if (active == null)
        return false;
    view.dispatch(view.state.t().annotate(setActiveCompletion, null));
    return true;
}
const setActiveCompletion = Annotation.define();
const activeCompletion = StateField.define({
    create() { return null; },
    update(prev, tr) {
        let set = tr.annotation(setActiveCompletion);
        if (set !== undefined)
            return set;
        return tr.annotation(Transaction.userEvent) == "input" ? "pending"
            : tr.docChanged || tr.selectionSet ? null
                : prev;
    }
}).provideN(showTooltip, active => active instanceof ActiveCompletion ? [active.tooltip] : []);
class ActiveCompletion {
    constructor(options, selected, tooltip) {
        this.options = options;
        this.selected = selected;
        this.tooltip = tooltip;
    }
}
function createListBox(options) {
    const ul = document.createElement("ul");
    ul.setAttribute("role", "listbox"); // FIXME this won't be focused, so the aria attributes aren't really useful
    for (let option of options) {
        const li = ul.appendChild(document.createElement("li"));
        li.innerText = option.label;
        li.setAttribute("role", "option");
    }
    return ul;
}
function buildTooltip(options) {
    return (view) => {
        let list = createListBox(options);
        list.addEventListener("click", (e) => {
            let index = 0, dom = e.target;
            for (;;) {
                dom = dom.previousSibling;
                if (!dom)
                    break;
                index++;
            }
            let active = view.state.field(activeCompletion);
            if (active instanceof ActiveCompletion && index < active.options.length)
                applyCompletion(view, active.options[index]);
        });
        function updateSel(view) {
            let cur = view.state.field(activeCompletion);
            if (cur instanceof ActiveCompletion)
                updateSelectedOption(list, cur.selected);
        }
        return {
            dom: list,
            mount: updateSel,
            update(update) {
                if (update.state.field(activeCompletion) != update.prevState.field(activeCompletion))
                    updateSel(update.view);
            },
            pos: options.reduce((m, o) => Math.min(m, o.start), 1e9),
            style: "autocomplete"
        };
    };
}
function updateSelectedOption(list, selected) {
    let set = null;
    for (let opt = list.firstChild, i = 0; opt; opt = opt.nextSibling, i++) {
        if (i == selected) {
            if (!opt.hasAttribute("aria-selected")) {
                opt.setAttribute("aria-selected", "true");
                set = opt;
            }
        }
        else {
            if (opt.hasAttribute("aria-selected"))
                opt.removeAttribute("aria-selected");
        }
    }
    if (set)
        scrollIntoView(list, set);
}
function scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    if (self.top < parent.top)
        container.scrollTop -= parent.top - self.top;
    else if (self.bottom > parent.bottom)
        container.scrollTop += self.bottom - parent.bottom;
}
const DebounceTime = 100;
const autocompletePlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.stateVersion = 0;
        this.debounce = -1;
    }
    update(update) {
        if (!(update.docChanged || update.selectionSet ||
            update.transactions.some(t => t.annotation(setActiveCompletion) !== undefined)))
            return;
        this.stateVersion++;
        if (this.debounce > -1)
            clearTimeout(this.debounce);
        let active = update.state.field(activeCompletion);
        this.debounce = active == "pending" ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
    }
    startUpdate() {
        this.debounce = -1;
        let version = this.stateVersion, state = this.view.state;
        let config = state.facet(autocompleteConfig);
        Promise.resolve(config.completeAt(state, state.selection.primary.head)).then(result => {
            if (this.stateVersion != version || result.items.length == 0)
                return;
            let tooltip = buildTooltip(result.items);
            this.view.dispatch(this.view.state.t().annotate(setActiveCompletion, new ActiveCompletion(result.items, 0, tooltip)));
        });
    }
});
const style = EditorView.theme({
    "tooltip.autocomplete": {
        fontFamily: "monospace",
        overflowY: "auto",
        maxHeight: "10em",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
            cursor: "pointer",
            padding: "1px 1em 1px 3px"
        },
        "& > li[aria-selected]": {
            background_fallback: "#bdf",
            background: "Highlight",
            color_fallback: "white",
            color: "HighlightText"
        }
    }
});

export { autocomplete, completeFromSyntax, sortAndFilterCompletion, startCompletion };

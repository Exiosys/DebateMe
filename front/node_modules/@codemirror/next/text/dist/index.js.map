{"version":3,"file":"index.js","sources":["../src/char.ts","../src/column.ts","../src/text.ts"],"sourcesContent":["let extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u180b-\\u180d\\u18a9\\u200c\\u200d]/\ntry { extendingChars = new RegExp(\"\\\\p{Grapheme_Extend}\", \"u\") } catch (_) {}\n\n/// Test whether a given code unit (as in, the thing that `charCodeAt`\n/// returns) extends the character before it.\nexport function isExtendingChar(code: number): boolean {\n  return code >= 768 && (code >= 0xdc00 && code < 0xe000 || extendingChars.test(String.fromCharCode(code)))\n}\n\nconst nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/\n\nlet wordChar: RegExp | null\ntry { wordChar = new RegExp(\"[\\\\p{Alphabetic}_]\", \"u\") } catch (_) {}\n\n// FIXME this doesn't work for astral chars yet (need different calling convention)\n\nfunction isWordCharBasic(ch: string): boolean {\n  if (wordChar) return wordChar.test(ch)\n  return /\\w/.test(ch) || ch > \"\\x80\" &&\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n}\n\n/// Test whether the given character is a word character.\nexport function isWordChar(ch: string, wordChars?: RegExp): boolean {\n  if (!wordChars) return isWordCharBasic(ch)\n  if (wordChars.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true\n  return wordChars.test(ch)\n}\n\n/// This is used to group characters into three categoriesâ€”word\n/// characters, whitespace, and anything else. It is used, by default,\n/// to do things like selecting by word.\nexport enum CharType { Word, Space, Other }\n\n/// Determine the character type for a given character.\nexport function charType(ch: string, wordChars?: RegExp): CharType {\n  // FIXME make this configurable in a better way\n  return /\\s/.test(ch) ? CharType.Space : isWordChar(ch, wordChars) ? CharType.Word : CharType.Other\n}\n\n/// Find the code point at the given position in a string (as in the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nexport function codePointAt(str: string, pos: number) {\n  let code0 = str.charCodeAt(pos)\n  if (code0 < 0xd800 || code0 > 0xdbff || pos + 1 == str.length) return code0\n  let code1 = str.charCodeAt(pos + 1)\n  if (code1 < 0xdc00 || code1 > 0xdfff) return code0\n  return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000\n}\n\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (as in\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint).\nexport function fromCodePoint(code: number) {\n  if (code <= 0xffff) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00)\n}\n\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nexport const minPairCodePoint = 0x10000\n","import {isExtendingChar} from \"./char\"\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nexport function countColumn(string: string, n: number, tabSize: number): number {\n  for (let i = 0; i < string.length; i++) {\n    let code = string.charCodeAt(i)\n    if (code == 9) n += tabSize - (n % tabSize)\n    else if (code < 768 || !isExtendingChar(code)) n++\n  }\n  return n\n}\n\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nexport function findColumn(string: string, n: number, col: number, tabSize: number): {offset: number, leftOver: number} {\n  for (let i = 0; i < string.length; i++) {\n    let code = string.charCodeAt(i)\n    if (isExtendingChar(code)) continue\n    if (n >= col) return {offset: i, leftOver: 0}\n    n += code == 9 ? tabSize - (n % tabSize) : 1\n  }\n  return {offset: string.length, leftOver: col - n}\n}\n","const enum Tree {\n  // The base size of a leaf node\n  BaseLeaf = 512,\n  // The max size of a leaf node\n  MaxLeaf = Tree.BaseLeaf * 2,\n  // The desired amount of branches per node, as an exponent of 2 (so 3\n  // means 8 branches)\n  BranchShift = 3\n}\n\n/// A text iterator iterates over a sequence of strings.\nexport interface TextIterator extends Iterator<string> {\n  /// Retrieve the next string. Optionally skip a given number of\n  /// positions after the current position. Always returns the object\n  /// itself.\n  next(skip?: number): this\n  /// The current string. Will be `\"\"` when the cursor is at its end\n  /// or `next` hasn't been called on it yet.\n  value: string\n  /// Whether the end of the iteration has been reached. You should\n  /// probably check this right after calling `next`.\n  done: boolean\n  /// Whether the current string represents a line break.\n  lineBreak: boolean\n}\n\n/// The document tree type.\nexport abstract class Text {\n  /// The length of the string.\n  abstract readonly length: number\n  /// The number of lines in the string (always >= 1).\n  abstract readonly lines: number\n  /// @internal\n  abstract readonly children: readonly Text[] | null\n\n  /// Get the line description around the given position.\n  lineAt(pos: number): Line {\n    if (pos < 0 || pos > this.length)\n      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`)\n    for (let i = 0; i < lineCache.length; i += 2) {\n      if (lineCache[i] != this) continue\n      let line = lineCache[i + 1]\n      if (line.start <= pos && line.end >= pos) return line\n    }\n    return cacheLine(this, this.lineInner(pos, false, 1, 0).finish(this))\n  }\n\n  /// Get the description for the given (1-based) line number.\n  line(n: number): Line {\n    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`)\n    for (let i = 0; i < lineCache.length; i += 2) {\n      if (lineCache[i] != this) continue\n      let line = lineCache[i + 1]\n      if (line.number == n) return line\n    }\n    return cacheLine(this, this.lineInner(n, true, 1, 0).finish(this))\n  }\n\n  /// @internal\n  abstract lineInner(target: number, isLine: boolean, line: number, offset: number): Line\n\n  /// Replace a range of the text with the given lines. `text` should\n  /// have a length of at least one.\n  replace(from: number, to: number, text: readonly string[]): Text {\n    if (text.length == 0) throw new RangeError(\"An inserted range must have at least one line\")\n    return this.replaceInner(from, to, text, textLength(text))\n  }\n\n  /// @internal\n  abstract replaceInner(from: number, to: number, text: readonly string[], length: number): Text\n\n  /// Retrieve the lines between the given points.\n  sliceLines(from: number, to: number = this.length): readonly string[] {\n    return this.sliceTo(from, to, [\"\"])\n  }\n\n  /// @internal\n  abstract sliceTo(from: number, to: number, target: string[]): string[]\n\n  /// Retrieve the text between the given points.\n  slice(from: number, to?: number, lineSeparator: string = \"\\n\"): string {\n    return this.sliceLines(from, to).join(lineSeparator)\n  }\n\n  /// Test whether this text is equal to another instance.\n  eq(other: Text): boolean { return this == other || eqContent(this, other) }\n\n  /// Iterate over the text. When `dir` is `-1`, iteration happens\n  /// from end to start. This will return lines and the breaks between\n  /// them as separate strings, and for long lines, might split lines\n  /// themselves into multiple chunks as well.\n  iter(dir: 1 | -1 = 1): TextIterator { return new RawTextCursor(this, dir) }\n\n  /// Iterate over a range of the text. When `from` > `to`, the\n  /// iterator will run in reverse.\n  iterRange(from: number, to: number = this.length): TextIterator { return new PartialTextCursor(this, from, to) }\n\n  /// Iterate over lines in the text, starting at position (_not_ line\n  /// number) `from`. An iterator returned by this combines all text\n  /// on a line into a single string (which may be expensive for very\n  /// long lines), and skips line breaks (its\n  /// [`lineBreak`](#text.TextIterator.lineBreak) property is always\n  /// false).\n  iterLines(from: number = 0): TextIterator { return new LineCursor(this, from) }\n\n  /// @internal\n  abstract decomposeStart(to: number, target: Text[]): void\n  /// @internal\n  abstract decomposeEnd(from: number, target: Text[]): void\n  /// @internal\n  abstract lastLineLength(): number\n  /// @internal\n  abstract firstLineLength(): number\n\n  /// Flattens the document into a single string, using `\"\\n\"` as line\n  /// separator.\n  toString() { return this.slice(0, this.length) }\n\n  /// @internal\n  protected constructor() {}\n\n  /// Create a `Text` instance for the given array of lines.\n  static of(text: readonly string[]): Text {\n    if (text.length == 0) throw new RangeError(\"A document must have at least one line\")\n    let length = textLength(text)\n    return length < Tree.MaxLeaf ? new TextLeaf(text, length) : TextNode.from(TextLeaf.split(text, []), length)\n  }\n\n  /// The empty text.\n  static empty: Text\n}\n\nlet lineCache: any[] = [], lineCachePos = -2, lineCacheSize = 12\n\nfunction cacheLine(text: Text, line: Line): Line {\n  lineCachePos = (lineCachePos + 2) % lineCacheSize\n  lineCache[lineCachePos] = text\n  lineCache[lineCachePos + 1] = line\n  return line\n}\n\n// Leaves store an array of strings. There are always line breaks\n// between these strings (though not between adjacent leaves). These\n// are limited in length, so that bigger documents are constructed as\n// a tree structure. Long lines will be broken into a number of\n// single-line leaves.\nclass TextLeaf extends Text {\n  constructor(readonly text: readonly string[], readonly length: number = textLength(text)) {\n    super()\n  }\n\n  get lines(): number { return this.text.length }\n\n  get children() { return null }\n\n  replaceInner(from: number, to: number, text: readonly string[], length: number): Text {\n    return Text.of(appendText(this.text, appendText(text, sliceText(this.text, 0, from)), to))\n  }\n\n  sliceTo(from: number, to: number = this.length, target: string[]): string[] {\n    return appendText(this.text, target, from, to)\n  }\n\n  lineInner(target: number, isLine: boolean, line: number, offset: number): Line {\n    for (let i = 0;; i++) {\n      let string = this.text[i], end = offset + string.length\n      if ((isLine ? line : end) >= target)\n        return new Line(offset, end, line, string)\n      offset = end + 1\n      line++\n    }\n  }\n\n  decomposeStart(to: number, target: Text[]) {\n    target.push(new TextLeaf(sliceText(this.text, 0, to), to))\n  }\n\n  decomposeEnd(from: number, target: Text[]) {\n    target.push(new TextLeaf(sliceText(this.text, from), this.length - from))\n  }\n\n  lastLineLength(): number { return this.text[this.text.length - 1].length }\n\n  firstLineLength(): number { return this.text[0].length }\n\n  static split(text: readonly string[], target: Text[]): Text[] {\n    let part = [], length = -1\n    for (let line of text) {\n      for (;;) {\n        let newLength = length + line.length + 1\n        if (newLength < Tree.BaseLeaf) {\n          length = newLength\n          part.push(line)\n          break\n        }\n        let cut = Tree.BaseLeaf - length - 1, after = line.charCodeAt(cut)\n        if (after >= 0xdc00 && after < 0xe000) cut++\n        part.push(line.slice(0, cut))\n        target.push(new TextLeaf(part, Tree.BaseLeaf))\n        line = line.slice(cut)\n        length = -1\n        part = []\n      }\n    }\n    if (length != -1) target.push(new TextLeaf(part, length))\n    return target\n  }\n}\n\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance itself on\n// changes.\nclass TextNode extends Text {\n  readonly lines: number;\n\n  constructor(readonly children: readonly Text[], readonly length: number) {\n    super()\n    this.lines = 1\n    for (let child of children) this.lines += child.lines - 1\n  }\n\n  replaceInner(from: number, to: number, text: readonly string[], length: number): Text {\n    let lengthDiff = length - (to - from), newLength = this.length + lengthDiff\n    if (newLength <= Tree.BaseLeaf)\n      return new TextLeaf(appendText(this.sliceLines(to), appendText(text, this.sliceTo(0, from, [\"\"]))), newLength)\n\n    let children\n    for (let i = 0, pos = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = pos + child.length\n      if (from >= pos && to <= end &&\n          (lengthDiff > 0\n           ? child.length + lengthDiff < Math.max(newLength >> (Tree.BranchShift - 1), Tree.MaxLeaf)\n           : child.length + lengthDiff > newLength >> (Tree.BranchShift + 1))) {\n        // Fast path: if the change only affects one child and the\n        // child's size remains in the acceptable range, only update\n        // that child\n        children = this.children.slice()\n        children[i] = child.replace(from - pos, to - pos, text)\n        return new TextNode(children, newLength)\n      } else if (end >= from) {\n        // Otherwise, we must build up a new array of children\n        if (children == null) children = this.children.slice(0, i)\n        if (pos < from) {\n          if (end == from) children.push(child)\n          else child.decomposeStart(from - pos, children)\n        }\n        if (pos <= from && end >= from) TextLeaf.split(text, children)\n        if (pos >= to) children.push(child)\n        else if (end > to) child.decomposeEnd(to - pos, children)\n      }\n      pos = end\n    }\n    return children ? TextNode.from(children, newLength) : this\n  }\n\n  sliceTo(from: number, to: number, target: string[]): string[] {\n    let pos = 0\n    for (let child of this.children) {\n      let end = pos + child.length\n      if (to > pos && from < end)\n        child.sliceTo(Math.max(0, from - pos), Math.min(child.length, to - pos), target)\n      pos = end\n    }\n    return target\n  }\n\n  lineInner(target: number, isLine: boolean, line: number, offset: number): Line {\n    for (let i = 0;; i++) {\n      let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1\n      if ((isLine ? endLine : end) >= target) {\n        let inner = child.lineInner(target, isLine, line, offset), add\n        if (inner.start == offset && (add = this.lineLengthTo(i))) {\n          ;(inner as any).start -= add\n          ;(inner as any).content = null\n        }\n        if (inner.end == end && (add = this.lineLengthFrom(i + 1))) {\n          ;(inner as any).end += add\n          ;(inner as any).content = null\n        }\n        return inner\n      }\n      offset = end\n      line = endLine\n    }\n  }\n\n  decomposeStart(to: number, target: Text[]) {\n    for (let i = 0, pos = 0;; i++) {\n      let child = this.children[i], end = pos + child.length\n      if (end <= to) {\n        target.push(child)\n      } else {\n        if (pos < to) child.decomposeStart(to - pos, target)\n        break\n      }\n      pos = end\n    }\n  }\n\n  decomposeEnd(from: number, target: Text[]) {\n    let pos = 0\n    for (let child of this.children) {\n      let end = pos + child.length\n      if (pos >= from) target.push(child)\n      else if (end > from && pos < from) child.decomposeEnd(from - pos, target)\n      pos = end\n    }\n  }\n\n  private lineLengthTo(to: number): number {\n    let length = 0\n    for (let i = to - 1; i >= 0; i--) {\n      let child = this.children[i]\n      if (child.lines > 1) return length + child.lastLineLength()\n      length += child.length\n    }\n    return length\n  }\n\n  lastLineLength(): number { return this.lineLengthTo(this.children.length) }\n\n  private lineLengthFrom(from: number): number {\n    let length = 0\n    for (let i = from; i < this.children.length; i++) {\n      let child = this.children[i]\n      if (child.lines > 1) return length + child.firstLineLength()\n      length += child.length\n    }\n    return length\n  }\n\n  firstLineLength(): number { return this.lineLengthFrom(0) }\n\n  static from(children: Text[], length: number): Text {\n    if (length < Tree.MaxLeaf) {\n      let text = [\"\"]\n      for (let child of children) child.sliceTo(0, child.length, text)\n      return new TextLeaf(text, length)\n    }\n\n    let chunkLength = Math.max(Tree.BaseLeaf, length >> Tree.BranchShift), maxLength = chunkLength << 1, minLength = chunkLength >> 1\n    let chunked: Text[] = [], currentLength = 0, currentChunk: Text[] = []\n    function add(child: Text) {\n      let childLength = child.length, last\n      if (childLength > maxLength && child instanceof TextNode) {\n        for (let node of child.children) add(node)\n      } else if (childLength > minLength && (currentLength > minLength || currentLength == 0)) {\n        flush()\n        chunked.push(child)\n      } else if (child instanceof TextLeaf && currentLength > 0 &&\n                 (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                 child.length + last.length <= Tree.BaseLeaf) {\n        currentLength += childLength\n        currentChunk[currentChunk.length - 1] = new TextLeaf(appendText(child.text, last.text.slice()), child.length + last.length)\n      } else {\n        if (currentLength + childLength > chunkLength) flush()\n        currentLength += childLength\n        currentChunk.push(child)\n      }\n    }\n    function flush() {\n      if (currentLength == 0) return\n      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLength))\n      currentLength = 0\n      currentChunk.length = 0\n    }\n\n    for (let child of children) add(child)\n    flush()\n    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length)\n  }\n}\n\nText.empty = Text.of([\"\"])\n\nfunction textLength(text: readonly string[]) {\n  let length = -1\n  for (let line of text) length += line.length + 1\n  return length\n}\n\nfunction appendText(text: readonly string[], target: string[], from = 0, to = 1e9): string[] {\n  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n    let line = text[i], end = pos + line.length\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos)\n      if (pos < from) line = line.slice(from - pos)\n      if (first) { target[target.length - 1] += line; first = false }\n      else target.push(line)\n    }\n    pos = end + 1\n  }\n  return target\n}\n\nfunction sliceText(text: readonly string[], from?: number, to?: number): string[] {\n  return appendText(text, [\"\"], from, to)\n}\n\nfunction eqContent(a: Text, b: Text): boolean {\n  if (a.length != b.length || a.lines != b.lines) return false\n  let iterA = new RawTextCursor(a), iterB = new RawTextCursor(b)\n  for (let offA = 0, offB = 0;;) {\n    if (iterA.lineBreak != iterB.lineBreak || iterA.done != iterB.done) {\n      return false\n    } else if (iterA.done) {\n      return true\n    } else if (iterA.lineBreak) {\n      iterA.next(); iterB.next()\n      offA = offB = 0\n    } else {\n      let strA = iterA.value.slice(offA), strB = iterB.value.slice(offB)\n      if (strA.length == strB.length) {\n        if (strA != strB) return false\n        iterA.next(); iterB.next()\n        offA = offB = 0\n      } else if (strA.length > strB.length) {\n        if (strA.slice(0, strB.length) != strB) return false\n        offA += strB.length\n        iterB.next(); offB = 0\n      } else {\n        if (strB.slice(0, strA.length) != strA) return false\n        offB += strA.length\n        iterA.next(); offA = 0\n      }\n    }\n  }\n}\n\nclass RawTextCursor implements TextIterator {\n  public done: boolean = false\n  public lineBreak: boolean = false\n  public value: string = \"\"\n  private nodes: Text[]\n  private offsets: number[]\n\n  constructor(text: Text, readonly dir: 1 | -1 = 1) {\n    this.nodes = [text]\n    this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children!.length]\n  }\n\n  next(skip: number = 0): this {\n    for (;;) {\n      let last = this.nodes.length - 1\n      if (last < 0) {\n        this.done = true\n        this.value = \"\"\n        this.lineBreak = false\n        return this\n      }\n      let top = this.nodes[last]\n      let offset = this.offsets[last]\n      if (top instanceof TextLeaf) {\n        // Internal offset with lineBreak == false means we have to\n        // count the line break at this position\n        if (offset != (this.dir > 0 ? 0 : top.text.length) && !this.lineBreak) {\n          this.lineBreak = true\n          if (skip == 0) {\n            this.value = \"\\n\"\n            return this\n          }\n          skip--\n          continue\n        }\n        // Otherwise, move to the next string\n        let next = top.text[offset - (this.dir < 0 ? 1 : 0)]\n        this.offsets[last] = (offset += this.dir)\n        if (offset == (this.dir > 0 ? top.text.length : 0)) {\n          this.nodes.pop()\n          this.offsets.pop()\n        }\n        this.lineBreak = false\n        if (next.length > skip) {\n          this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip)\n          return this\n        }\n        skip -= next.length\n      } else if (offset == (this.dir > 0 ? top.children!.length : 0)) {\n        this.nodes.pop()\n        this.offsets.pop()\n      } else {\n        let next = top.children![this.dir > 0 ? offset : offset - 1], len = next.length\n        this.offsets[last] = offset + this.dir\n        if (skip > len) {\n          skip -= len\n        } else {\n          this.nodes.push(next)\n          this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children!.length)\n        }\n      }\n    }\n  }\n}\n\nclass PartialTextCursor implements TextIterator {\n  cursor: RawTextCursor\n  limit: number\n  skip: number\n  value: string = \"\"\n\n  constructor(text: Text, start: number, end: number) {\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1)\n    if (start > end) {\n      this.skip = text.length - start\n      this.limit = start - end\n    } else {\n      this.skip = start\n      this.limit = end - start\n    }\n  }\n\n  next(): this {\n    if (this.limit <= 0) {\n      this.limit = -1\n    } else {\n      let {value, lineBreak} = this.cursor.next(this.skip)\n      this.skip = 0\n      this.value = value\n      let len = lineBreak ? 1 : value.length\n      if (len > this.limit)\n        this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit)\n      this.limit -= this.value.length\n    }\n    return this\n  }\n\n  get lineBreak() { return this.cursor.lineBreak }\n\n  get done() { return this.limit < 0 }\n}\n\nclass LineCursor implements TextIterator {\n  cursor: TextIterator\n  skip: number\n  value = \"\"\n  done = false\n\n  constructor(text: Text, from = 0) {\n    this.cursor = text.iter()\n    this.skip = from\n  }\n\n  next(): this {\n    if (this.cursor.done) {\n      this.done = true\n      this.value = \"\"\n      return this\n    }\n    for (this.value = \"\";;) {\n      let {value, lineBreak, done} = this.cursor.next(this.skip)\n      this.skip = 0\n      if (done || lineBreak) return this\n      this.value += value\n    }\n  }\n\n  get lineBreak() { return false }\n}\n\n// FIXME rename start/end to from/to for consistency with other types?\n\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nexport class Line {\n  /// @internal\n  constructor(\n    /// The position of the start of the line.\n    readonly start: number,\n    /// The position at the end of the line (_before_ the line break,\n    /// if this isn't the last line).\n    readonly end: number,\n    /// This line's line number (1-based).\n    readonly number: number,\n    /// @internal\n    public content: string | null | LineContent\n  ) {}\n\n  /// The length of the line (not including any line break after it).\n  get length() { return this.end - this.start }\n\n  /// Retrieve a part of the content of this line. This is a method,\n  /// rather than, say, a string property, to avoid concatenating long\n  /// lines whenever they are accessed. Try to write your code, if it\n  /// is going to be doing a lot of line-reading, to read only the\n  /// parts it needs.\n  slice(from: number = 0, to: number = this.length) {\n    if (typeof this.content == \"string\")\n      return to == from + 1 ? this.content.charAt(from) : this.content.slice(from, to)\n    if (from == to) return \"\"\n    let result = this.content!.slice(from, to)\n    if (from == 0 && to == this.length) this.content = result\n    return result\n  }\n\n  /// @internal\n  finish(text: Text): this {\n    if (this.content == null) this.content = new LineContent(text, this.start)\n    return this\n  }\n}\n\nclass LineContent {\n  cursor: null | TextIterator = null\n  strings: string[] | null = null\n\n  constructor(private doc: Text, private start: number) {}\n\n  // FIXME quadratic complexity (somewhat) when iterating long lines in small pieces\n  slice(from: number, to: number) {\n    if (!this.cursor) {\n      this.cursor = this.doc.iter()\n      this.strings = [this.cursor.next(this.start).value]\n    }\n    for (let result = \"\", pos = 0, i = 0;; i++) {\n      if (i == this.strings!.length) this.strings!.push(this.cursor!.next().value)\n      let string = this.strings![i], end = pos + string.length\n      if (end <= from) continue\n      result += string.slice(Math.max(0, from - pos), Math.min(string.length, to - pos))\n      if (end >= to) return result\n      pos += string.length\n    }\n  }\n}\n"],"names":["CharType"],"mappings":"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"}
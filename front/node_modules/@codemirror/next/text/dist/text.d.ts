export interface TextIterator extends Iterator<string> {
    next(skip?: number): this;
    value: string;
    done: boolean;
    lineBreak: boolean;
}
export declare abstract class Text {
    abstract readonly length: number;
    abstract readonly lines: number;
    abstract readonly children: readonly Text[] | null;
    lineAt(pos: number): Line;
    line(n: number): Line;
    abstract lineInner(target: number, isLine: boolean, line: number, offset: number): Line;
    replace(from: number, to: number, text: readonly string[]): Text;
    abstract replaceInner(from: number, to: number, text: readonly string[], length: number): Text;
    sliceLines(from: number, to?: number): readonly string[];
    abstract sliceTo(from: number, to: number, target: string[]): string[];
    slice(from: number, to?: number, lineSeparator?: string): string;
    eq(other: Text): boolean;
    iter(dir?: 1 | -1): TextIterator;
    iterRange(from: number, to?: number): TextIterator;
    iterLines(from?: number): TextIterator;
    abstract decomposeStart(to: number, target: Text[]): void;
    abstract decomposeEnd(from: number, target: Text[]): void;
    abstract lastLineLength(): number;
    abstract firstLineLength(): number;
    toString(): string;
    protected constructor();
    static of(text: readonly string[]): Text;
    static empty: Text;
}
export declare class Line {
    readonly start: number;
    readonly end: number;
    readonly number: number;
    content: string | null | LineContent;
    constructor(start: number, end: number, number: number, content: string | null | LineContent);
    get length(): number;
    slice(from?: number, to?: number): string;
    finish(text: Text): this;
}
declare class LineContent {
    private doc;
    private start;
    cursor: null | TextIterator;
    strings: string[] | null;
    constructor(doc: Text, start: number);
    slice(from: number, to: number): string;
}
export {};
//# sourceMappingURL=text.d.ts.map
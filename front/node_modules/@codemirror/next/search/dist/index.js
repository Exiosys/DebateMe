'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('../../view');
var state = require('../../state');
var panel = require('../../panel');
var keymap = require('../../keymap');
var text = require('../../text');
var rangeset = require('../../rangeset');

const basicNormalize = String.prototype.normalize ? x => x.normalize("NFKD") : x => x;
/// A search cursor provides an iterator over text matches in a
/// document.
class SearchCursor {
    /// Create a text cursor. The query is the search string, `from` to
    /// `to` provides the region to search.
    ///
    /// When `normalize` is given, it will be called, on both the query
    /// string and the content it is matched against, before comparing.
    /// You can, for example, create a case-insensitive search by
    /// passing `s => s.toLowerCase()`.
    ///
    /// Text is always normalized with
    /// [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    /// (when supported).
    constructor(text, query, from = 0, to = text.length, normalize) {
        this.text = text;
        /// The current match (only holds a meaningful value after
        /// [`next`](#search.SearchCursor.next) has been called and when
        /// `done` is true).
        this.value = { from: 0, to: 0 };
        /// Whether the end of the iterated region has been reached.
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
                return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return this.buffer.charCodeAt(this.bufferPos);
    }
    /// Look for the next match. Updates the iterator's
    /// [`value`](#search.SearchCursor.value) and
    /// [`done`](#search.SearchCursor.done) properties. Should be called
    /// at least once before using the cursor.
    next() {
        for (;;) {
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = String.fromCharCode(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos++;
            for (;;) {
                let peek = this.peek();
                if (peek < 0 || !text.isExtendingChar(peek))
                    break;
                this.bufferPos++;
                str += String.fromCharCode(peek);
            }
            let norm = this.normalize(str);
            for (let i = 0, pos = start;; i++) {
                let code = norm.charCodeAt(i);
                let match = this.match(code, pos);
                if (match) {
                    this.value = match;
                    return this;
                }
                if (i == norm.length - 1)
                    break;
                if (pos == start && i < str.length && str.charCodeAt(i) == code)
                    pos++;
            }
        }
    }
    match(code, pos) {
        let match = null;
        for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
                if (index == this.query.length - 1) {
                    match = { from: this.matches[i + 1], to: pos + 1 };
                }
                else {
                    this.matches[i]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i, 2);
                i -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
                match = { from: pos, to: pos + 1 };
            else
                this.matches.push(1, pos);
        }
        return match;
    }
}

class Query {
    constructor(search, replace, caseInsensitive) {
        this.search = search;
        this.replace = replace;
        this.caseInsensitive = caseInsensitive;
    }
    eq(other) {
        return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive;
    }
    cursor(doc, from = 0, to = doc.length) {
        return new SearchCursor(doc, this.search, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);
    }
    get valid() { return !!this.search; }
}
const searchAnnotation = state.Annotation.define();
const searchState = state.StateField.define({
    create() {
        return new SearchState(new Query("", "", false), []);
    },
    update(search, tr) {
        let ann = tr.annotation(searchAnnotation);
        return ann ? new SearchState(ann.query || search.query, ann.panel == null ? search.panel :
            ann.panel ? [createSearchPanel] : []) : search;
    }
}).provideN(panel.showPanel, s => s.panel);
class SearchState {
    constructor(query, panel) {
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = view.Decoration.mark({ class: view.themeClass("searchmatch") }), selectedMatchMark = view.Decoration.mark({ class: view.themeClass("searchmatch.selected") });
const searchHighlighter = view.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState).query);
    }
    update(update) {
        let state = update.state.field(searchState);
        if (state != update.prevState.field(searchState) || update.docChanged || update.selectionSet)
            this.decorations = this.highlight(state.query);
    }
    highlight(query) {
        let state = this.view.state, viewport = this.view.viewport;
        let cursor = query.cursor(state.doc, Math.max(0, viewport.from - query.search.length), Math.min(viewport.to + query.search.length, state.doc.length));
        let builder = new rangeset.RangeSetBuilder();
        while (!cursor.next().done) {
            let { from, to } = cursor.value;
            let selected = state.selection.ranges.some(r => r.from == from && r.to == to);
            builder.add(from, to, selected ? selectedMatchMark : matchMark);
        }
        return builder.finish();
    }
}).decorations();
const panelKeymap = state.Facet.define({
    combine(keymaps) {
        let result = Object.create(null);
        for (let map of keymaps)
            for (let prop of Object.keys(map))
                result[prop] = map[prop];
        return new keymap.NormalizedKeymap(result);
    }
});
/// Create an extension that enables search/replace functionality.
/// This needs to be enabled for any of the search-related commands to
/// work.
const search = function (config) {
    // FIXME make multiple instances of this combine, somehow
    let keys = Object.create(null), panelKeys = Object.create(null);
    if (config.keymap)
        for (let key of Object.keys(config.keymap)) {
            panelKeys[key] = keys[key] = config.keymap[key];
        }
    if (config.panelKeymap)
        for (let key of Object.keys(config.panelKeymap)) {
            panelKeys[key] = config.panelKeymap[key];
        }
    return [
        searchState,
        keymap.keymap(keys),
        panelKeymap.of(panelKeys),
        searchHighlighter,
        panel.panels(),
        baseTheme
    ];
};
function beforeCommand(view) {
    let state = view.state.field(searchState);
    if (!state)
        return false;
    if (!state.query.valid) {
        openSearchPanel(view);
        return true;
    }
    return state;
}
function findNextMatch(doc, from, query) {
    let cursor = query.cursor(doc, from).next();
    if (cursor.done) {
        cursor = query.cursor(doc, 0, from + query.search.length - 1).next();
        if (cursor.done)
            return null;
    }
    return cursor.value;
}
/// Open the search panel if it isn't already open, and move the
/// selection to the first match after the current primary selection.
/// Will wrap around to the start of the document when it reaches the
/// end.
const findNext = view => {
    let state$1 = beforeCommand(view);
    if (typeof state$1 == "boolean")
        return state$1;
    let { from, to } = view.state.selection.primary;
    let next = findNextMatch(view.state.doc, view.state.selection.primary.from + 1, state$1.query);
    if (!next || next.from == from && next.to == to)
        return false;
    view.dispatch(view.state.t().setSelection(state.EditorSelection.single(next.from, next.to)).scrollIntoView());
    maybeAnnounceMatch(view);
    return true;
};
const FindPrevChunkSize = 10000;
// Searching in reverse is, rather than implementing inverted search
// cursor, done by scanning chunk after chunk forward.
function findPrevInRange(query, doc, from, to) {
    for (let pos = to;;) {
        let start = Math.max(from, pos - FindPrevChunkSize - query.search.length);
        let cursor = query.cursor(doc, start, pos), range = null;
        while (!cursor.next().done)
            range = cursor.value;
        if (range)
            return range;
        if (start == from)
            return null;
        pos -= FindPrevChunkSize;
    }
}
/// Move the selection to the previous instance of the search query,
/// before the current primary selection. Will wrap past the start
/// of the document to start searching at the end again.
const findPrevious = view => {
    let plugin = beforeCommand(view);
    if (typeof plugin == "boolean")
        return plugin;
    let { state: state$1 } = view, { query } = plugin;
    let range = findPrevInRange(query, state$1.doc, 0, state$1.selection.primary.to - 1) ||
        findPrevInRange(query, state$1.doc, state$1.selection.primary.from + 1, state$1.doc.length);
    if (!range)
        return false;
    view.dispatch(state$1.t().setSelection(state.EditorSelection.single(range.from, range.to)).scrollIntoView());
    maybeAnnounceMatch(view);
    return true;
};
/// Select all instances of the search query.
const selectMatches = view => {
    let plugin = beforeCommand(view);
    if (typeof plugin == "boolean")
        return plugin;
    let cursor = plugin.query.cursor(view.state.doc), ranges = [];
    while (!cursor.next().done)
        ranges.push(new state.SelectionRange(cursor.value.from, cursor.value.to));
    if (!ranges.length)
        return false;
    view.dispatch(view.state.t().setSelection(state.EditorSelection.create(ranges)));
    return true;
};
/// Replace the current match of the search query.
const replaceNext = view => {
    let plugin = beforeCommand(view);
    if (typeof plugin == "boolean")
        return plugin;
    let next = findNextMatch(view.state.doc, view.state.selection.primary.from, plugin.query);
    if (!next)
        return false;
    let { from, to } = view.state.selection.primary, tr = view.state.t();
    if (next.from == from && next.to == to) {
        tr.replace(next.from, next.to, plugin.query.replace);
        next = findNextMatch(tr.doc, tr.changes.mapPos(next.to), plugin.query);
    }
    if (next)
        tr.setSelection(state.EditorSelection.single(next.from, next.to)).scrollIntoView();
    view.dispatch(tr);
    if (next)
        maybeAnnounceMatch(view);
    return true;
};
/// Replace all instances of the search query with the given
/// replacement.
const replaceAll = view => {
    let plugin = beforeCommand(view);
    if (typeof plugin == "boolean")
        return plugin;
    let cursor = plugin.query.cursor(view.state.doc), tr = view.state.t();
    while (!cursor.next().done) {
        let { from, to } = cursor.value;
        tr.replace(tr.changes.mapPos(from, 1), tr.changes.mapPos(to, -1), plugin.query.replace);
    }
    if (!tr.docChanged)
        return false;
    view.dispatch(tr);
    return true;
};
function createSearchPanel(view) {
    let { query } = view.state.field(searchState);
    return {
        dom: buildPanel({
            view,
            keymap: view.state.facet(panelKeymap),
            query,
            updateQuery(q) {
                if (!query.eq(q)) {
                    query = q;
                    view.dispatch(view.state.t().annotate(searchAnnotation, { query }));
                }
            }
        }),
        mount() {
            this.dom.querySelector("[name=search]").select();
        },
        pos: 80,
        style: "search"
    };
}
/// Make sure the search panel is open and focused.
const openSearchPanel = view => {
    let state = view.state.field(searchState);
    if (!state)
        return false;
    if (!state.panel.length)
        view.dispatch(view.state.t().annotate(searchAnnotation, { panel: true }));
    return true;
};
/// Default search-related bindings.
///
///  * Mod-f: [`openSearchPanel`](#search.openSearchPanel)
///  * F3: [`findNext`](#search.findNext)
///  * Shift-F3: [`findPrevious`](#search.findPrevious)
const defaultSearchKeymap = {
    "Mod-f": openSearchPanel,
    "F3": findNext,
    "Shift-F3": findPrevious
};
/// Close the search panel.
const closeSearchPanel = view => {
    let state = view.state.field(searchState);
    if (!state || !state.panel.length)
        return false;
    let panel = view.dom.querySelector(".cm-panel-search");
    if (panel && panel.contains(view.root.activeElement))
        view.focus();
    view.dispatch(view.state.t().annotate(searchAnnotation, { panel: false }));
    return true;
};
function elt(name, props = null, children = []) {
    let e = document.createElement(name);
    if (props)
        for (let prop in props) {
            let value = props[prop];
            if (typeof value == "string")
                e.setAttribute(prop, value);
            else
                e[prop] = value;
        }
    for (let child of children)
        e.appendChild(typeof child == "string" ? document.createTextNode(child) : child);
    return e;
}
// FIXME sync when search state changes independently
function buildPanel(conf) {
    function p(phrase) { return conf.view.phrase(phrase); }
    let searchField = elt("input", {
        value: conf.query.search,
        placeholder: p("Find"),
        "aria-label": p("Find"),
        name: "search",
        onchange: update,
        onkeyup: update
    });
    let replaceField = elt("input", {
        value: conf.query.replace,
        placeholder: p("Replace"),
        "aria-label": p("Replace"),
        name: "replace",
        onchange: update,
        onkeyup: update
    });
    let caseField = elt("input", {
        type: "checkbox",
        name: "case",
        checked: !conf.query.caseInsensitive,
        onchange: update
    });
    function update() {
        conf.updateQuery(new Query(searchField.value, replaceField.value, !caseField.checked));
    }
    function keydown(e) {
        let mapped = conf.keymap.get(e);
        if (mapped && mapped(conf.view)) {
            e.preventDefault();
        }
        else if (e.keyCode == 27) {
            e.preventDefault();
            closeSearchPanel(conf.view);
        }
        else if (e.keyCode == 13 && e.target == searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(conf.view);
        }
        else if (e.keyCode == 13 && e.target == replaceField) {
            e.preventDefault();
            replaceNext(conf.view);
        }
    }
    let panel = elt("div", { onkeydown: keydown }, [
        searchField,
        elt("button", { name: "next", onclick: () => findNext(conf.view) }, [p("next")]),
        elt("button", { name: "prev", onclick: () => findPrevious(conf.view) }, [p("previous")]),
        elt("button", { name: "select", onclick: () => selectMatches(conf.view) }, [p("all")]),
        elt("label", null, [caseField, "match case"]),
        elt("br"),
        replaceField,
        elt("button", { name: "replace", onclick: () => replaceNext(conf.view) }, [p("replace")]),
        elt("button", { name: "replaceAll", onclick: () => replaceAll(conf.view) }, [p("replace all")]),
        elt("button", { name: "close", onclick: () => closeSearchPanel(conf.view), "aria-label": p("close") }, ["×"]),
        elt("div", { style: "position: absolute; top: -10000px", "aria-live": "polite" })
    ]);
    return panel;
}
const AnnounceMargin = 30;
// FIXME this is a kludge
function maybeAnnounceMatch(view) {
    let { doc } = view.state, { from, to } = view.state.selection.primary;
    let lineStart = doc.lineAt(from).start, lineEnd = doc.lineAt(to).end;
    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text$1 = doc.slice(start, end);
    if (start != lineStart) {
        for (let i = 0; i < AnnounceMargin; i++)
            if (text.isWordChar(text$1[i + 1]) && !text.isWordChar(text$1[i])) {
                text$1 = text$1.slice(i);
                break;
            }
    }
    if (end != lineEnd) {
        for (let i = text$1.length - 1; i > text$1.length - AnnounceMargin; i--)
            if (text.isWordChar(text$1[i - 1]) && !text.isWordChar(text$1[i])) {
                text$1 = text$1.slice(0, i);
                break;
            }
    }
    let state = view.state.field(searchState);
    let panel = state.panel.length && view.dom.querySelector(".cm-panel-search");
    if (!panel || !panel.contains(view.root.activeElement))
        return;
    let live = panel.querySelector("div[aria-live]");
    live.textContent = view.phrase("current match") + ". " + text$1;
}
const baseTheme = view.EditorView.baseTheme({
    "panel.search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button": {
            verticalAlign: "middle",
            marginRight: ".5em"
        },
        "& label": {
            fontSize: "80%"
        }
    },
    searchMatch: {
        background: "#ffa"
    },
    "searchMatch.selected": {
        background: "#fca"
    }
});

exports.SearchCursor = SearchCursor;
exports.closeSearchPanel = closeSearchPanel;
exports.defaultSearchKeymap = defaultSearchKeymap;
exports.findNext = findNext;
exports.findPrevious = findPrevious;
exports.openSearchPanel = openSearchPanel;
exports.replaceAll = replaceAll;
exports.replaceNext = replaceNext;
exports.search = search;
exports.selectMatches = selectMatches;

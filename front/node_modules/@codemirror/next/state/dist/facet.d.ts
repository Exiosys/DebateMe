import { Transaction } from "./transaction";
import { EditorState } from "./state";
export declare type FacetConfig<Input, Output> = {
    combine?: (value: readonly Input[]) => Output;
    compare?: (a: Output, b: Output) => boolean;
    compareInput?: (a: Input, b: Input) => boolean;
    static?: boolean;
};
export declare class Facet<Input, Output> {
    readonly combine: (values: readonly Input[]) => Output;
    readonly compareInput: (a: Input, b: Input) => boolean;
    readonly compare: (a: Output, b: Output) => boolean;
    private isStatic;
    readonly id: number;
    readonly default: Output;
    private constructor();
    static define<Input, Output = readonly Input[]>(config?: FacetConfig<Input, Output>): Facet<Input, Output>;
    of(value: Input): Extension;
    compute(deps: readonly Slot<any>[], get: (state: EditorState) => Input): Extension;
    computeN(deps: readonly Slot<any>[], get: (state: EditorState) => readonly Input[]): Extension;
}
declare type Slot<T> = Facet<any, T> | StateField<T> | "doc" | "selection";
declare const isExtension: unique symbol;
export declare type StateFieldSpec<Value> = {
    create: (state: EditorState) => Value;
    update: (value: Value, transaction: Transaction, newState: EditorState) => Value;
    compare?: (a: Value, b: Value) => boolean;
};
export declare class StateField<Value> {
    readonly id: number;
    private createF;
    private updateF;
    private compareF;
    readonly facets: readonly Extension[];
    private constructor();
    static define<Value>(config: StateFieldSpec<Value>): StateField<Value>;
    provide(facet: Facet<Value, any>): StateField<Value>;
    provide<T>(facet: Facet<T, any>, get: (value: Value) => T, prec?: Precedence): StateField<Value>;
    provideN<T>(facet: Facet<T, any>, get: (value: Value) => readonly T[], prec?: Precedence): StateField<Value>;
    slot(addresses: {
        [id: number]: number;
    }): (state: EditorState, tr: Transaction | null) => 0 | SlotStatus.Changed;
    [isExtension]: true;
}
export declare type Extension = {
    [isExtension]: true;
} | {
    extension: Extension;
} | readonly Extension[];
export declare class Precedence {
    readonly val: number;
    private constructor();
    static Fallback: Precedence;
    static Default: Precedence;
    static Extend: Precedence;
    static Override: Precedence;
    set(extension: Extension): Extension;
}
export declare class ExtensionGroup {
    readonly name: string;
    constructor(name: string);
    of(extension: Extension): Extension;
}
declare type DynamicSlot = (state: EditorState, tr: Transaction | null) => number;
export declare class Configuration {
    readonly source: Extension;
    readonly replacements: Map<ExtensionGroup, Extension>;
    readonly dynamicSlots: DynamicSlot[];
    readonly address: {
        [id: number]: number;
    };
    readonly staticValues: readonly any[];
    readonly statusTemplate: SlotStatus[];
    constructor(source: Extension, replacements: Map<ExtensionGroup, Extension>, dynamicSlots: DynamicSlot[], address: {
        [id: number]: number;
    }, staticValues: readonly any[]);
    staticFacet<Output>(facet: Facet<any, Output>): any;
    static resolve(extension: Extension, replacements?: Map<ExtensionGroup, Extension>, oldState?: EditorState): Configuration;
}
export declare const enum SlotStatus {
    Uninitialized = 0,
    Changed = 1,
    Computed = 2,
    Computing = 4
}
export declare function ensureAddr(state: EditorState, addr: number): number;
export declare function getAddr(state: EditorState, addr: number): any;
export {};
//# sourceMappingURL=facet.d.ts.map
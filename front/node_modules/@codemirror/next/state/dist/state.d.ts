import { Text } from "../../text";
import { Tree } from "lezer-tree";
import { EditorSelection } from "./selection";
import { Transaction } from "./transaction";
import { Syntax } from "./extension";
import { Configuration, Facet, Extension, StateField, SlotStatus } from "./facet";
export interface EditorStateConfig {
    doc?: string | Text;
    selection?: EditorSelection;
    extensions?: Extension;
}
export declare class EditorState {
    readonly config: Configuration;
    readonly doc: Text;
    readonly selection: EditorSelection;
    readonly values: any[];
    readonly status: SlotStatus[];
    applying: null | Transaction;
    constructor(config: Configuration, doc: Text, selection: EditorSelection, tr?: Transaction | null);
    field<T>(field: StateField<T>): T;
    field<T>(field: StateField<T>, require: false): T | undefined;
    t(timestamp?: number): Transaction;
    joinLines(text: readonly string[]): string;
    splitLines(text: string): string[];
    facet<Output>(facet: Facet<any, Output>): Output;
    toJSON(): any;
    static fromJSON(json: any, config?: EditorStateConfig): EditorState;
    applyTransaction(tr: Transaction): EditorState;
    static create(config?: EditorStateConfig): EditorState;
    static allowMultipleSelections: Facet<boolean, boolean>;
    static indentation: Facet<(state: EditorState, pos: number) => number, readonly ((state: EditorState, pos: number) => number)[]>;
    static tabSize: Facet<number, number>;
    get tabSize(): number;
    static lineSeparator: Facet<string, string | undefined>;
    static indentUnit: Facet<number, number>;
    get indentUnit(): number;
    static syntax: Facet<Syntax, readonly Syntax[]>;
    get tree(): Tree;
    static foldable: Facet<(state: EditorState, lineStart: number, lineEnd: number) => {
        from: number;
        to: number;
    } | null, readonly ((state: EditorState, lineStart: number, lineEnd: number) => {
        from: number;
        to: number;
    } | null)[]>;
}
//# sourceMappingURL=state.d.ts.map
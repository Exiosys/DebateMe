import { Text } from "../../text";
export declare enum MapMode {
    Simple = 0,
    TrackDel = 1,
    TrackBefore = 2,
    TrackAfter = 3
}
export interface Mapping {
    mapPos(pos: number, bias?: number, mode?: MapMode): number;
}
export declare class ChangeDesc implements Mapping {
    readonly from: number;
    readonly to: number;
    readonly length: number;
    constructor(from: number, to: number, length: number);
    get invertedDesc(): ChangeDesc;
    mapPos(pos: number, bias?: number, mode?: MapMode): number;
    toJSON(): any;
    static fromJSON(json: any): ChangeDesc;
}
export declare class Change extends ChangeDesc {
    readonly from: number;
    readonly to: number;
    readonly text: readonly string[];
    constructor(from: number, to: number, text: readonly string[]);
    invert(doc: Text): Change;
    apply(doc: Text): Text;
    map(mapping: Mapping): Change | null;
    get desc(): ChangeDesc;
    toJSON(): any;
    static fromJSON(json: any): Change;
}
export declare class ChangeSet<C extends ChangeDesc = Change> implements Mapping {
    readonly changes: readonly C[];
    readonly mirror: readonly number[];
    private _changedRanges;
    constructor(changes: readonly C[], mirror?: readonly number[]);
    get length(): number;
    getMirror(n: number): number | null;
    append(change: C, mirror?: number): ChangeSet<C>;
    appendSet(changes: ChangeSet<C>): ChangeSet<C>;
    static empty: ChangeSet<any>;
    mapPos(pos: number, bias?: number, mode?: MapMode): number;
    mapInner(pos: number, bias: number, mode: MapMode, fromI: number, toI: number): number;
    touchesRange(from: number, to: number): boolean | "cover";
    partialMapping(from: number, to?: number): Mapping;
    changedRanges(): readonly ChangedRange[];
    get desc(): ChangeSet<ChangeDesc>;
    toJSON(): any;
    static fromJSON<C extends ChangeDesc>(ChangeType: {
        fromJSON: (json: any) => C;
    }, json: any): ChangeSet<C>;
}
export declare class ChangedRange {
    readonly fromA: number;
    readonly toA: number;
    readonly fromB: number;
    readonly toB: number;
    constructor(fromA: number, toA: number, fromB: number, toB: number);
    join(other: ChangedRange): ChangedRange;
    addToSet(set: ChangedRange[]): ChangedRange[];
    get lenDiff(): number;
    static mapPos(pos: number, bias: number, changes: readonly ChangedRange[]): number;
}
//# sourceMappingURL=change.d.ts.map
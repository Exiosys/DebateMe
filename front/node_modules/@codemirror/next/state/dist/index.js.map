{"version":3,"file":"index.js","sources":["../src/selection.ts","../src/facet.ts","../src/extension.ts","../src/change.ts","../src/transaction.ts","../src/state.ts","../src/config.ts"],"sourcesContent":["import {Mapping} from \"./change\"\nimport {EditorState} from \"./state\"\nimport {Text, charType} from \"../../text\"\n\n/// A single selection range. When\n/// [`allowMultipleSelections`](#state.EditorState^allowMultipleSelections)\n/// is enabled, a [selection](#state.EditorSelection) may hold\n/// multiple ranges. By default, selections hold exactly one range.\nexport class SelectionRange {\n  /// Create a range. `head` defaults to `anchor` when not given.\n  constructor(\n    /// The anchor of the rangeâ€”the side that doesn't move when you\n    /// extend it.\n    readonly anchor: number,\n    /// The head of the range, which is moved when the range is\n    /// [extended](#state.SelectionRange.extend).\n    public readonly head: number = anchor) {}\n\n  /// The lower side of the range.\n  get from(): number { return Math.min(this.anchor, this.head) }\n  /// The upper side of the range.\n  get to(): number { return Math.max(this.anchor, this.head) }\n  /// True when `anchor` and `head` are at the same position.\n  get empty(): boolean { return this.anchor == this.head }\n\n  /// Map this range through a mapping.\n  map(mapping: Mapping): SelectionRange {\n    let anchor = mapping.mapPos(this.anchor), head = mapping.mapPos(this.head)\n    if (anchor == this.anchor && head == this.head) return this\n    else return new SelectionRange(anchor, head)\n  }\n\n  /// Extend this range to cover at least `from` to `to`.\n  extend(from: number, to: number = from) {\n    if (from <= this.anchor && to >= this.anchor) return new SelectionRange(from, to)\n    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to\n    return new SelectionRange(this.anchor, head)\n  }\n\n  /// Compare this range to another range.\n  eq(other: SelectionRange): boolean {\n    return this.anchor == other.anchor && this.head == other.head\n  }\n\n  /// Return a JSON-serializable object representing the range.\n  toJSON(): any { return this }\n\n  /// Convert a JSON representation of a range to a `SelectionRange`\n  /// instance.\n  static fromJSON(json: any): SelectionRange {\n    if (!json || typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid JSON representation for SelectionRange\")\n    return new SelectionRange(json.anchor, json.head)\n  }\n\n  /// @internal FIXME export?\n  static groupAt(state: EditorState, pos: number, bias: 1 | -1 = 1) {\n    // FIXME at some point, take language-specific identifier characters into account\n    let line = state.doc.lineAt(pos), linePos = pos - line.start\n    if (line.length == 0) return new SelectionRange(pos)\n    if (linePos == 0) bias = 1\n    else if (linePos == line.length) bias = -1\n    let read = linePos + (bias < 0 ? -1 : 0), type = charType(line.slice(read, read + 1))\n    let from = pos, to = pos\n    for (let lineFrom = linePos; lineFrom > 0 && charType(line.slice(lineFrom - 1, lineFrom)) == type; lineFrom--) from--\n    for (let lineTo = linePos; lineTo < line.length && charType(line.slice(lineTo, lineTo + 1)) == type; lineTo++) to++\n    return new SelectionRange(to, from)\n  }\n}\n\n/// An editor selection holds one or more selection ranges.\nexport class EditorSelection {\n  /// @internal\n  constructor(\n    /// The ranges in the selection, sorted by position. Ranges cannot\n    /// overlap (but they may touch, if they aren't empty).\n    readonly ranges: readonly SelectionRange[],\n    /// The index of the _primary_ range in the selection (which is\n    /// usually the range that was added last).\n    readonly primaryIndex: number = 0\n  ) {}\n\n  /// Map a selection through a mapping. Mostly used to adjust the\n  /// selection position for changes.\n  map(mapping: Mapping): EditorSelection {\n    return EditorSelection.create(this.ranges.map(r => r.map(mapping)), this.primaryIndex)\n  }\n\n  /// Compare this selection to another selection.\n  eq(other: EditorSelection): boolean {\n    if (this.ranges.length != other.ranges.length ||\n        this.primaryIndex != other.primaryIndex) return false\n    for (let i = 0; i < this.ranges.length; i++)\n      if (!this.ranges[i].eq(other.ranges[i])) return false\n    return true\n  }\n\n  /// Get the primary selection range. Usually, you should make sure\n  /// your code applies to _all_ ranges, by using transaction methods\n  /// like [`forEachRange`](#state.transaction.forEachRange).\n  get primary(): SelectionRange { return this.ranges[this.primaryIndex] }\n\n  /// Make sure the selection only has one range. Returns a selection\n  /// holding only the primary range from this selection.\n  asSingle() {\n    return this.ranges.length == 1 ? this : new EditorSelection([this.primary])\n  }\n\n  /// Extend this selection with an extra range.\n  addRange(range: SelectionRange, primary: boolean = true) {\n    return EditorSelection.create([range].concat(this.ranges), primary ? 0 : this.primaryIndex + 1)\n  }\n\n  /// Replace a given range with another range, and then normalize the\n  /// selection to merge and sort ranges if necessary.\n  replaceRange(range: SelectionRange, which: number = this.primaryIndex) {\n    let ranges = this.ranges.slice()\n    ranges[which] = range\n    return EditorSelection.create(ranges, this.primaryIndex)\n  }\n\n  /// Convert this selection to an object that can be serialized to\n  /// JSON.\n  toJSON(): any {\n    return this.ranges.length == 1 ? this.ranges[0].toJSON() :\n      {ranges: this.ranges.map(r => r.toJSON()), primaryIndex: this.primaryIndex}\n  }\n\n  /// Create a selection from a JSON representation.\n  static fromJSON(json: any): EditorSelection {\n    if (json && Array.isArray(json.ranges)) {\n      if (typeof json.primaryIndex != \"number\" || json.primaryIndex >= json.ranges.length)\n        throw new RangeError(\"Invalid JSON representation for EditorSelection\")\n      return new EditorSelection(json.ranges.map((r: any) => SelectionRange.fromJSON(r)), json.primaryIndex)\n    }\n    return new EditorSelection([SelectionRange.fromJSON(json)])\n  }\n\n  /// Create a selection holding a single range.\n  static single(anchor: number, head: number = anchor) {\n    return new EditorSelection([new SelectionRange(anchor, head)], 0)\n  }\n\n  /// Sort and merge the given set of ranges, creating a valid\n  /// selection.\n  static create(ranges: readonly SelectionRange[], primaryIndex: number = 0) {\n    for (let pos = 0, i = 0; i < ranges.length; i++) {\n      let range = ranges[i]\n      if (range.empty ? range.from <= pos : range.from < pos) return normalized(ranges.slice(), primaryIndex)\n      pos = range.to\n    }\n    return new EditorSelection(ranges, primaryIndex)\n  }\n}\n\nfunction normalized(ranges: SelectionRange[], primaryIndex: number = 0): EditorSelection {\n  let primary = ranges[primaryIndex]\n  ranges.sort((a, b) => a.from - b.from)\n  primaryIndex = ranges.indexOf(primary)\n  for (let i = 1; i < ranges.length; i++) {\n    let range = ranges[i], prev = ranges[i - 1]\n    if (range.empty ? range.from <= prev.to : range.from < prev.to) {\n      let from = prev.from, to = Math.max(range.to, prev.to)\n      if (i <= primaryIndex) primaryIndex--\n      ranges.splice(--i, 2, range.anchor > range.head ? new SelectionRange(to, from) : new SelectionRange(from, to))\n    }\n  }\n  return new EditorSelection(ranges, primaryIndex)\n}\n\nexport function checkSelection(selection: EditorSelection, doc: Text) {\n  for (let range of selection.ranges)\n    if (range.to > doc.length) throw new RangeError(\"Selection points outside of document\")\n}\n","import {Transaction} from \"./transaction\"\nimport {EditorState} from \"./state\"\n\nlet nextID = 0\n\n/// Config object passed to [`defineFacet`](#state.defineFacet).\nexport type FacetConfig<Input, Output> = {\n  /// How to combine the input values into a single output value. When\n  /// not given, the array of input values becomes the output. This\n  /// will immediately be called on creating the facet, with an empty\n  /// array, to compute the facet's default value when no inputs are\n  /// present.\n  combine?: (value: readonly Input[]) => Output,\n  /// How to compare output values to determine whether the value of\n  /// the facet changed. Defaults to comparing by `===` or, if no\n  /// `combine` function was given, comparing each element of the\n  /// array with `===`.\n  compare?: (a: Output, b: Output) => boolean,\n  /// How to compare input values to avoid recomputing the output\n  /// value when no inputs changed. Defaults to comparing with `===`.\n  compareInput?: (a: Input, b: Input) => boolean,\n  /// Static facets can not contain dynamic inputs.\n  static?: boolean\n}\n\n/// A facet is a value that is assicated with a state and can be\n/// influenced by any number of extensions. Extensions can provide\n/// input values for the facet, and the facet combines those into an\n/// output value.\n///\n/// Examples of facets are the theme styles associated with an editor\n/// (which are all stored) or the tab size (which is reduced to a\n/// single value, using the input with the hightest precedence).\nexport class Facet<Input, Output> {\n  /// @internal\n  readonly id = nextID++\n  /// @internal\n  readonly default: Output\n\n  private constructor(\n    /// @internal\n    readonly combine: (values: readonly Input[]) => Output,\n    /// @internal\n    readonly compareInput: (a: Input, b: Input) => boolean,\n    /// @internal\n    readonly compare: (a: Output, b: Output) => boolean,\n    private isStatic: boolean\n  ) {\n    this.default = combine([])\n  }\n\n  /// Define a new facet.\n  static define<Input, Output = readonly Input[]>(config: FacetConfig<Input, Output> = {}) {\n    return new Facet<Input, Output>(config.combine || ((a: any) => a) as any,\n                                    config.compareInput || ((a, b) => a === b),\n                                    config.compare || (!config.combine ? sameArray as any : (a, b) => a === b),\n                                    !!config.static)\n  }\n\n  /// Returns an extension that adds the given value for this facet.\n  of(value: Input): Extension {\n    return new FacetProvider<Input>([], this, Provider.Static, value)\n  }\n\n  /// Create an extension that computes a value for the facet from a\n  /// state. You must take care to declare the parts of the state that\n  /// this value depends on, since your function is only called again\n  /// for a new state when one of those parts changed.\n  ///\n  /// In most cases, you'll want to use\n  /// [`StateField.provide`](#state.StateField^provide) instead.\n  compute(deps: readonly Slot<any>[], get: (state: EditorState) => Input): Extension {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\")\n    return new FacetProvider<Input>(deps, this, Provider.Single, get)\n  }\n\n  /// Create an extension that computes zero or more values for this\n  /// facet from a state.\n  computeN(deps: readonly Slot<any>[], get: (state: EditorState) => readonly Input[]): Extension {\n    if (this.isStatic) throw new Error(\"Can't compute a static facet\")\n    return new FacetProvider<Input>(deps, this, Provider.Multi, get)\n  }\n}\n\nfunction sameArray<T>(a: readonly T[], b: readonly T[]) {\n  return a == b || a.length == b.length && a.every((e, i) => e === b[i])\n}\n\ntype Slot<T> = Facet<any, T> | StateField<T> | \"doc\" | \"selection\"\n\n// Marks a value as an [`Extension`](#state.Extension).\ndeclare const isExtension: unique symbol\n\nconst enum Provider { Static, Single, Multi }\n\nclass FacetProvider<Input> {\n  readonly id = nextID++\n\n  constructor(readonly dependencies: readonly Slot<any>[],\n              readonly facet: Facet<Input, any>,\n              readonly type: Provider,\n              readonly value: ((state: EditorState) => Input) | ((state: EditorState) => readonly Input[]) | Input) {}\n\n  dynamicSlot(addresses: {[id: number]: number}) {\n    let getter: (state: EditorState) => any = this.value as any\n    let compare = this.facet.compareInput\n    let idx = addresses[this.id] >> 1, multi = this.type == Provider.Multi\n    let depDoc = false, depSel = false, depAddrs: number[] = []\n    for (let dep of this.dependencies) {\n      if (dep == \"doc\") depDoc = true\n      else if (dep == \"selection\") depSel = true\n      else if ((addresses[dep.id] & 1) == 0) depAddrs.push(addresses[dep.id])\n    }\n\n    return (state: EditorState, tr: Transaction | null) => {\n      if (!tr || tr.reconfigured) {\n        state.values[idx] = getter(state)\n        return SlotStatus.Changed\n      } else {\n        let depChanged = (depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selectionSet)) || \n          depAddrs.some(addr => (ensureAddr(state, addr) & SlotStatus.Changed) > 0)\n        if (!depChanged) return 0\n        let newVal = getter(state), oldVal = tr.startState.values[idx]\n        if (multi ? compareArray(newVal, oldVal, compare) : compare(newVal, oldVal)) return 0\n        state.values[idx] = newVal\n        return SlotStatus.Changed\n      }\n    }\n  }\n\n  [isExtension]!: true\n}\n\nfunction compareArray<T>(a: readonly T[], b: readonly T[], compare: (a: T, b: T) => boolean) {\n  if (a.length != b.length) return false\n  for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false\n  return true\n}\n\nfunction dynamicFacetSlot<Input, Output>(\n  addresses: {[id: number]: number},\n  facet: Facet<Input, Output>,\n  providers: readonly FacetProvider<Input>[]\n) {\n  let providerAddrs = providers.map(p => addresses[p.id])\n  let providerTypes = providers.map(p => p.type)\n  let dynamic = providerAddrs.filter(p => !(p & 1))\n  let idx = addresses[facet.id] >> 1\n\n  return (state: EditorState, tr: Transaction | null) => {\n    let oldAddr = !tr ? null : tr.reconfigured ? tr.startState.config.address[facet.id] : idx << 1\n    let changed = oldAddr == null\n    for (let dynAddr of dynamic) {\n      if (ensureAddr(state, dynAddr) & SlotStatus.Changed) changed = true\n    }\n    if (!changed) return 0\n    let values: Input[] = []\n    for (let i = 0; i < providerAddrs.length; i++) {\n      let value = getAddr(state, providerAddrs[i])\n      if (providerTypes[i] == Provider.Multi) for (let val of value) values.push(val)\n      else values.push(value)\n    }\n    let newVal = facet.combine(values)\n    if (oldAddr != null && facet.compare(newVal, getAddr(tr!.startState, oldAddr))) return 0\n    state.values[idx] = newVal\n    return SlotStatus.Changed\n  }\n}\n\n/// Parameters passed when creating a\n/// [`StateField`](#state.StateField^define). The `Value` type\n/// parameter refers to the content of the field. Since it will be\n/// stored in (immutable) state objects, it should be an immutable\n/// value itself.\nexport type StateFieldSpec<Value> = {\n  /// Creates the initial value for the field when a state is created.\n  create: (state: EditorState) => Value,\n\n  /// Compute a new value from the field's previous value and a\n  /// [transaction](#state.Transaction).\n  update: (value: Value, transaction: Transaction, newState: EditorState) => Value,\n\n  /// Compare two values of the field, returning `true` when they are\n  /// the same. This is used to avoid recomputing facets that depend\n  /// on the field when its value did not change. Defaults to using\n  /// `==`.\n  compare?: (a: Value, b: Value) => boolean,\n}\n\n/// Fields can store additional information in an editor state, and\n/// keep it in sync with the rest of the state.\nexport class StateField<Value> {\n  private constructor(\n    /// @internal\n    readonly id: number,\n    private createF: (state: EditorState) => Value,\n    private updateF: (value: Value, tr: Transaction, state: EditorState) => Value,\n    private compareF: (a: Value, b: Value) => boolean,\n    /// @internal\n    readonly facets: readonly Extension[]\n  ) {}\n\n  /// Define a state field.\n  static define<Value>(config: StateFieldSpec<Value>): StateField<Value> {\n    return new StateField<Value>(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), [])\n  }\n\n  /// Extends the field to also provide a facet value. Returns a new\n  /// `StateField` instance that, when used to extend a state,\n  /// provides an input to the given facet that's derived from the\n  /// field. When no `get` value is given, the entire value of the\n  /// field is used as facet input.\n  provide(facet: Facet<Value, any>): StateField<Value>\n  provide<T>(facet: Facet<T, any>, get: (value: Value) => T, prec?: Precedence): StateField<Value>\n  provide<T>(facet: Facet<T, any>, get?: (value: Value) => T, prec?: Precedence) {\n    let provider = facet.compute([this], get ? state => get(state.field(this)) : state => state.field(this) as any)\n    return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)))\n  }\n\n  /// Extends the field to provide zero or more input values for the\n  /// given facet.\n  provideN<T>(facet: Facet<T, any>, get: (value: Value) => readonly T[], prec?: Precedence): StateField<Value> {\n    let provider = facet.computeN([this], state => get(state.field(this)))\n    return new StateField(this.id, this.createF, this.updateF, this.compareF, this.facets.concat(maybePrec(prec, provider)))\n  }\n\n  /// @internal\n  slot(addresses: {[id: number]: number}) {\n    let idx = addresses[this.id] >> 1\n    return (state: EditorState, tr: Transaction | null) => {\n      let oldIdx = !tr ? null : tr.reconfigured ? tr.startState.config.address[this.id] >> 1 : idx\n      if (oldIdx == null) {\n        state.values[idx] = this.createF(state)\n        return SlotStatus.Changed\n      } else {\n        let oldVal = tr!.startState.values[oldIdx], value = this.updateF(oldVal, tr!, state)\n        if (this.compareF(oldVal, value)) return 0\n        state.values[idx] = value\n        return SlotStatus.Changed\n      }\n    }\n  }\n\n  /// State field instances can be used as\n  /// [`Extension`](#state.Extension) values to enable the field in a\n  /// given state. (This symbol is a TypeScript-related trick to mark\n  /// it as an extension value.)\n  [isExtension]!: true\n}\n\n/// Extension values can be\n/// [provided](#state.EditorStateConfig.extensions) when creating a\n/// state to attach various kinds of configuration and behavior\n/// information. It may an extension object, such as a [state\n/// field](#state.StateField) or facet provider, any object with an\n/// extension in its `extension` property, or an array of extension\n/// values.\nexport type Extension = {[isExtension]: true} | {extension: Extension} | readonly Extension[]\n\n/// By default extensions are registered in the order they are\n/// provided in a flattening of the nested arrays that were provided.\n/// Individual extension values can be assigned a precedence to\n/// override this. Extensions that do not have a precedence set get\n/// the precedence of the nearest parent with a precedence, or\n/// [`Default`](#state.Precedence.Default) if there is no such parent.\n/// The final ordering of extensions is determined by first sorting by\n/// precedence and then by order within each precedence.\nexport class Precedence {\n  private constructor(\n    /// @internal\n    readonly val: number\n  ) {}\n\n  /// A precedence below the default precedence, which will cause\n  /// default-precedence extensions to override it even if they are\n  /// specified later in the extension ordering.\n  static Fallback = new Precedence(3)\n  /// The regular default precedence.\n  static Default = new Precedence(2)\n  /// A higher-than-default precedence.\n  static Extend = new Precedence(1)\n  /// Precedence above the `Default` and `Extend` precedences.\n  static Override = new Precedence(0)\n\n  /// Tag an extension with this precedence.\n  set(extension: Extension): Extension {\n    return new PrecExtension(extension, this.val)\n  }\n}\n\nfunction maybePrec(prec: Precedence | undefined, ext: Extension) {\n  return prec == null ? ext : prec.set(ext)\n}\n\nclass PrecExtension {\n  constructor(readonly e: Extension, readonly prec: number) {}\n  [isExtension]!: true\n}\n\nclass GroupExtension {\n  constructor(readonly extension: Extension, readonly group: ExtensionGroup) {}\n  [isExtension]!: true\n}\n\n/// Extension groups can be used to make a configuration dynamic.\n/// [Wrapping](#state.ExtensionGroup.of) an extension in a group\n/// allows you to later replace it with\n/// [`Transaction.replaceExtension`](#state.Transaction.replaceExtension).\n/// A given group may only occur once within a given configuration.\nexport class ExtensionGroup {\n  /// Define a new group. The name is used only for debugging\n  /// purposes.\n  constructor(readonly name: string) {}\n\n  /// Tag the given extension with this group.\n  of(extension: Extension): Extension { return new GroupExtension(extension, this) }\n}\n\ntype DynamicSlot = (state: EditorState, tr: Transaction | null) => number\n\nexport class Configuration {\n  readonly statusTemplate: SlotStatus[] = []\n\n  constructor(readonly source: Extension,\n              readonly replacements: Map<ExtensionGroup, Extension>,\n              readonly dynamicSlots: DynamicSlot[],\n              readonly address: {[id: number]: number},\n              readonly staticValues: readonly any[]) {\n    while (this.statusTemplate.length < staticValues.length)\n      this.statusTemplate.push(SlotStatus.Uninitialized)\n  }\n\n  staticFacet<Output>(facet: Facet<any, Output>) {\n    let addr = this.address[facet.id]\n    return addr == null ? facet.default : this.staticValues[addr >> 1]\n  }\n\n  static resolve(extension: Extension, replacements: Map<ExtensionGroup, Extension> = new Map, oldState?: EditorState) {\n    let fields: StateField<any>[] = []\n    let facets: {[id: number]: FacetProvider<any>[]} = Object.create(null)\n    for (let ext of flatten(extension, replacements)) {\n      if (ext instanceof StateField) fields.push(ext)\n      else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext)\n    }\n\n    let address: {[id: number]: number} = Object.create(null)\n    let staticValues: any[] = []\n    let dynamicSlots: ((address: {[id: number]: number}) => DynamicSlot)[] = []\n    for (let field of fields) {\n      address[field.id] = dynamicSlots.length << 1\n      dynamicSlots.push(a => field.slot(a))\n    }\n    for (let id in facets) {\n      let providers = facets[id], facet = providers[0].facet\n      if (providers.every(p => p.type == Provider.Static)) {\n        address[facet.id] = (staticValues.length << 1) | 1\n        let value = facet.combine(providers.map(p => p.value))\n        let oldAddr = oldState ? oldState.config.address[facet.id] : null\n        if (oldAddr != null) {\n          let oldVal = getAddr(oldState!, oldAddr)\n          if (facet.compare(value, oldVal)) value = oldVal\n        }\n        staticValues.push(value)\n      } else {\n        for (let p of providers) {\n          if (p.type == Provider.Static) {\n            address[p.id] = (staticValues.length << 1) | 1\n            staticValues.push(p.value)\n          } else {\n            address[p.id] = dynamicSlots.length << 1\n            dynamicSlots.push(a => p.dynamicSlot(a))\n          }\n        }\n        address[facet.id] = dynamicSlots.length << 1\n        dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers))\n      }\n    }\n\n    return new Configuration(extension, replacements, dynamicSlots.map(f => f(address)), address, staticValues)\n  }\n}\n\nfunction flatten(extension: Extension, replacements: Map<ExtensionGroup, Extension>) {\n  let result: (FacetProvider<any> | StateField<any>)[][] = [[], [], [], []]\n  let seen = new Set<Extension>()\n  let groupsSeen = new Set<ExtensionGroup>()\n  ;(function inner(ext, prec: number) {\n    if (seen.has(ext)) return\n    seen.add(ext)\n    if (Array.isArray(ext)) {\n      for (let e of ext) inner(e, prec)\n    } else if (ext instanceof GroupExtension) {\n      if (groupsSeen.has(ext.group))\n        throw new RangeError(`Duplicate use of group '${ext.group.name}' in extensions`)\n      groupsSeen.add(ext.group)\n      inner(replacements.get(ext.group) || ext.extension, prec)\n    } else if ((ext as any).extension) {\n      inner((ext as any).extension, prec)\n    } else if (ext instanceof PrecExtension) {\n      inner(ext.e, ext.prec)\n    } else {\n      result[prec].push(ext as any)\n      if (ext instanceof StateField) inner(ext.facets, prec)\n    }\n  })(extension, Precedence.Default.val)\n  return result.reduce((a, b) => a.concat(b))\n}\n\nexport const enum SlotStatus {\n  Uninitialized = 0,\n  Changed = 1,\n  Computed = 2,\n  Computing = 4\n}\n\nexport function ensureAddr(state: EditorState, addr: number) {\n  if (addr & 1) return SlotStatus.Computed\n  let idx = addr >> 1\n  let status = state.status[idx]\n  if (status == SlotStatus.Computing) throw new Error(\"Cyclic dependency between fields and/or facets\")\n  if (status & SlotStatus.Computed) return status\n  state.status[idx] = SlotStatus.Computing\n  let changed = state.config.dynamicSlots[idx](state, state.applying)\n  return state.status[idx] = SlotStatus.Computed | changed\n}\n\nexport function getAddr(state: EditorState, addr: number) {\n  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1]\n}\n","import {EditorState} from \"./state\"\nimport {Transaction} from \"./transaction\"\nimport {Facet} from \"./facet\"\nimport {Tree, NodeType, NodeProp} from \"lezer-tree\"\n\n/// Subtype of [`Command`](#view.Command) that doesn't require access\n/// to the actual editor view. Mostly useful to define commands that\n/// can be run and tested outside of a browser environment.\nexport type StateCommand = (target: {state: EditorState, dispatch: (transaction: Transaction) => void}) => boolean\n\nexport const allowMultipleSelections = Facet.define<boolean, boolean>({\n  combine: values => values.some(v => v),\n  static: true\n})\n\nlet annotationID = 0\n\n/// Annotations are tagged values that are used to add metadata to\n/// transactions in an extensible way.\nexport class Annotation<T> {\n  /// @internal\n  id = annotationID++\n\n  private constructor() {}\n\n  /// Define a new type of annotation.\n  static define<T>() { return new Annotation<T>() }\n}\n\n/// A node prop that can be stored on a grammar's top node to\n/// associate information with the language. Different extension might\n/// use different properties from this object (which they typically\n/// export as an interface).\nexport const languageData = new NodeProp<{}>()\n\n/// Syntax [parsing services](#state.EditorState^syntax) must provide\n/// this interface.\nexport interface Syntax {\n  /// Read the current syntax tree from a state. This may return an\n  /// incomplete tree.\n  getTree(state: EditorState): Tree\n\n  /// Get the position up to which the current document has been\n  /// parsed.\n  parsePos(state: EditorState): number\n\n  /// Get a tree that covers the document at least up to `upto`. If\n  /// that involves more than `timeout` milliseconds of work, return\n  /// null instead. Don't call this as a matter of course in, for\n  /// example, state updates or decorating functions, since it'll make\n  /// the editor unresponsive. Calling it in response to a specific\n  /// user command can be appropriate.\n  ensureTree(state: EditorState, upto: number, timeout?: number): Tree | null\n\n  /// The node type at the root of trees produced by this syntax.\n  docNodeType: NodeType\n\n  /// Return the language data object for the given position. This'll\n  /// usually be the be the data for the grammar's top node, but with\n  /// nested grammars it may be the data of some nested grammar.\n  languageDataAt<Interface = any>(state: EditorState, pos: number): Interface\n}\n\n// FIXME add a view plugin that schedules background parsing\n\n// FIXME add a way to be notified when the document is fully parsed\n","import {Text} from \"../../text\"\n\nconst empty: readonly any[] = []\n\n/// Distinguishes different ways in which positions can be mapped.\nexport enum MapMode {\n  /// Map a position to a valid new position, even when its context\n  /// was deleted.\n  Simple,\n  /// Return a negative number if a deletion happens across the\n  /// position. This number will be `-(newPos + 1)`, where `newPos` is\n  /// the result you'd get with `MapMode.Simple`.\n  TrackDel,\n  /// Return a negative number if the character _before_ the position\n  /// is deleted. The result is encoded the same way as with\n  /// `MapMode.TrackDel`.\n  TrackBefore,\n  /// Return a negative number if the character _after_ the position is\n  /// deleted.\n  TrackAfter\n}\n\n/// Interface for things that support position mapping.\nexport interface Mapping {\n  /// Map a given position through a set of changes.\n  ///\n  /// `bias` indicates whether, when content is inserted at the\n  /// position or the content around the position is replaced, the\n  /// position at the end (positive) or start (negative or zero) of\n  /// that change should be used. It defaults to `-1`.\n  ///\n  /// `mode` determines whether deletions should be\n  /// [reported](#state.MapMode). It defaults to `MapMode.Simple`\n  /// (don't report deletions).\n  mapPos(pos: number, bias?: number, mode?: MapMode): number\n}\n\n/// A change description describes a document change. This is usually\n/// used as a superclass of [`Change`](#state.Change), but can be used\n/// to store change data without storing the replacement string\n/// content.\nexport class ChangeDesc implements Mapping {\n  /// Create a description that replaces the text between positions\n  /// `from` and `to` with a new string of length `length`.\n  constructor(\n    /// The start position of the change.\n    public readonly from: number,\n    /// The end of the change (as a pre-change document position).\n    public readonly to: number,\n    /// The length of the replacing content.\n    public readonly length: number\n  ) {}\n\n  /// Get the change description of the inverse of this change.\n  get invertedDesc() { return new ChangeDesc(this.from, this.from + this.length, this.to - this.from) }\n\n  /// @internal\n  mapPos(pos: number, bias: number = -1, mode: MapMode = MapMode.Simple): number {\n    let {from, to, length} = this\n    if (pos < from) return pos\n    if (pos > to) return pos + (length - (to - from))\n    if (pos == to || pos == from) {\n      if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter) return -pos - 1\n      return (from == to ? bias <= 0 : pos == from) ? from : from + length\n    }\n    pos = from + (bias <= 0 ? 0 : length)\n    return mode != MapMode.Simple ? -pos - 1 : pos\n  }\n\n  /// Return a JSON-serializeable object representing this value.\n  toJSON(): any { return this }\n\n  /// Create a change description from its JSON representation.\n  static fromJSON(json: any) {\n    if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.length != \"number\")\n      throw new RangeError(\"Invalid JSON representation for ChangeDesc\")\n    return new ChangeDesc(json.from, json.to, json.length)\n  }\n}\n\n/// Change objects describe changes to the document.\nexport class Change extends ChangeDesc {\n  /// Create a change that replaces `from` to `to` with `text`. The\n  /// text is given as an array of lines. When it doesn't span lines,\n  /// the array has a single element. When it does, a new element is\n  /// added for every line. It should never have zero elements.\n  constructor(\n    public readonly from: number,\n    public readonly to: number,\n    /// The replacement content.\n    public readonly text: readonly string[]\n  ) {\n    super(from, to, textLength(text))\n  }\n\n  /// Create the inverse of this change when applied to the given\n  /// document. `change.invert(doc).apply(change.apply(doc))` gets you\n  /// the same document as the original `doc`.\n  invert(doc: Text): Change {\n    return new Change(this.from, this.from + this.length, doc.sliceLines(this.from, this.to))\n  }\n\n  /// Apply this change to the given content, returning an updated\n  /// version of the document.\n  apply(doc: Text): Text {\n    return doc.replace(this.from, this.to, this.text)\n  }\n\n  /// Map this change through a mapping, producing a new change that\n  /// can be applied to a post-mapping document. May return null if\n  /// the mapping completely replaces the region this change would\n  /// apply to.\n  map(mapping: Mapping): Change | null {\n    let from = mapping.mapPos(this.from, 1), to = mapping.mapPos(this.to, -1)\n    return from > to ? null : new Change(from, to, this.text)\n  }\n\n  /// A change description for this change.\n  get desc() { return new ChangeDesc(this.from, this.to, this.length) }\n\n  /// Produce a JSON-serializable object representing this change.\n  toJSON(): any {\n    return {from: this.from, to: this.to, text: this.text}\n  }\n\n  /// Read a change instance from its JSON representation.\n  static fromJSON(json: any) {\n    if (!json || typeof json.from != \"number\" || typeof json.to != \"number\" ||\n        !Array.isArray(json.text) || json.text.length == 0 || json.text.some((val: any) => typeof val != \"string\"))\n      throw new RangeError(\"Invalid JSON representation for Change\")\n    return new Change(json.from, json.to, json.text)\n  }\n}\n\nfunction textLength(text: readonly string[]) {\n  let length = -1\n  for (let line of text) length += line.length + 1\n  return length\n}\n\n/// A change set holds a sequence of changes or change descriptions.\nexport class ChangeSet<C extends ChangeDesc = Change> implements Mapping {\n  private _changedRanges: null | readonly ChangedRange[] = null\n\n  /// @internal\n  constructor(\n    /// The changes in this set.\n    readonly changes: readonly C[],\n    /// @internal\n    readonly mirror: readonly number[] = empty) {}\n\n  /// The number of changes in the set.\n  get length(): number {\n    return this.changes.length\n  }\n\n  /// Change sets can track which changes are inverses of each other,\n  /// to allow robust position mapping in situations where changes are\n  /// undone and then redone again. This queries which change is the\n  /// mirror image of a given change (by index).\n  getMirror(n: number): number | null {\n    for (let i = 0; i < this.mirror.length; i++)\n      if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)]\n    return null\n  }\n\n  /// Append a change to this set, returning an extended set. `mirror`\n  /// may be the index of a change already in the set, which\n  /// [mirrors](#state.ChangeSet.getMirror) the new change.\n  append(change: C, mirror?: number): ChangeSet<C> {\n    return new ChangeSet(this.changes.concat(change),\n                         mirror != null ? this.mirror.concat(this.length, mirror) : this.mirror)\n  }\n\n  /// Append another change set to this one.\n  appendSet(changes: ChangeSet<C>): ChangeSet<C> {\n    return changes.length == 0 ? this :\n      this.length == 0 ? changes :\n      new ChangeSet(this.changes.concat(changes.changes),\n                    this.mirror.concat(changes.mirror.map(i => i + this.length)))\n  }\n\n  /// The empty change set.\n  static empty: ChangeSet<any> = new ChangeSet(empty)\n\n  /// @internal\n  mapPos(pos: number, bias: number = -1, mode: MapMode = MapMode.Simple): number {\n    return this.mapInner(pos, bias, mode, 0, this.length)\n  }\n\n  /// @internal\n  mapInner(pos: number, bias: number, mode: MapMode, fromI: number, toI: number): number {\n    let dir = toI < fromI ? -1 : 1\n    let recoverables: {[key: number]: number} | null = null\n    let hasMirrors = this.mirror.length > 0, rec, mirror, deleted = false\n    for (let i = fromI - (dir < 0 ? 1 : 0), endI = toI - (dir < 0 ? 1 : 0); i != endI; i += dir) {\n      let {from, to, length} = this.changes[i]\n      if (dir < 0) {\n        let len = to - from\n        to = from + length\n        length = len\n      }\n\n      if (pos < from) continue\n      if (pos > to) {\n        pos += length - (to - from)\n        continue\n      }\n      // Change touches this position\n      if (recoverables && (rec = recoverables[i]) != null) { // There's a recovery for this change, and it applies\n        pos = from + rec\n        continue\n      }\n      if (hasMirrors && (mirror = this.getMirror(i)) != null &&\n          (dir > 0 ? mirror > i && mirror < toI : mirror < i && mirror >= toI)) { // A mirror exists\n        if (pos > from && pos < to) { // If this change deletes the position, skip forward to the mirror\n          i = mirror\n          pos = this.changes[i].from + (pos - from)\n          continue\n        }\n        // Else store a recoverable\n        ;(recoverables || (recoverables = {}))[mirror] = pos - from\n      }\n      if (pos > from && pos < to) {\n        if (mode != MapMode.Simple) deleted = true\n        pos = bias <= 0 ? from : from + length\n      } else {\n        if (from < pos && mode == MapMode.TrackBefore || to > pos && mode == MapMode.TrackAfter) deleted = true\n        pos = (from == to ? bias <= 0 : pos == from) ? from : from + length\n      }\n    }\n    return deleted ? -pos - 1 : pos\n  }\n\n  /// Check whether these changes touch a given range. When one of the\n  /// changes entirely covers the range, the string `\"cover\"` is\n  /// returned.\n  touchesRange(from: number, to: number): boolean | \"cover\" {\n    let result = false\n    for (let change of this.changes) {\n      if (change.to >= from && change.from <= to) {\n        if (change.from < from && change.to > to) return \"cover\"\n        result = true\n      }\n      let diff = change.length - (change.to - change.from)\n      if (from > change.from) from += diff\n      if (to > change.to) to += diff\n    }\n    return result\n  }\n\n  /// Get a partial [mapping](#state.Mapping) covering part of this\n  /// change set.\n  partialMapping(from: number, to: number = this.length): Mapping {\n    if (from == 0 && to == this.length) return this\n    return new PartialMapping(this, from, to)\n  }\n\n  /// Summarize this set of changes as a minimal sequence of changed\n  /// ranges, sored by position. For example, if you have changes\n  /// deleting between 1 and 4 and inserting a character at 1, the\n  /// result would be a single range saying 1 to 4 in the old doc was\n  /// replaced with range 1 to 2 in the new doc.\n  changedRanges(): readonly ChangedRange[] {\n    if (this._changedRanges) return this._changedRanges\n    let set: ChangedRange[] = []\n    for (let i = 0; i < this.length; i++) {\n      let change = this.changes[i]\n      let fromA = change.from, toA = change.to, fromB = change.from, toB = change.from + change.length\n      if (i < this.length - 1) {\n        let mapping = this.partialMapping(i + 1)\n        fromB = mapping.mapPos(fromB, 1); toB = mapping.mapPos(toB, -1)\n      }\n      if (i > 0) {\n        let mapping = this.partialMapping(i, 0)\n        fromA = mapping.mapPos(fromA, 1); toA = mapping.mapPos(toA, -1)\n      }\n      new ChangedRange(fromA, toA, fromB, toB).addToSet(set)\n    }\n    return this._changedRanges = set\n  }\n\n  /// Convert a set of changes to a set of change descriptions.\n  get desc(): ChangeSet<ChangeDesc> {\n    if (this.changes.length == 0 || this.changes[0] instanceof ChangeDesc) return this\n    return new ChangeSet(this.changes.map(ch => (ch as any).desc), this.mirror)\n  }\n\n  /// Create a JSON-serializable representation of this change set.\n  toJSON(): any {\n    let changes = this.changes.map(change => change.toJSON())\n    return this.mirror.length == 0 ? changes : {mirror: this.mirror, changes}\n  }\n\n  /// Read a change set from its JSON representation.\n  static fromJSON<C extends ChangeDesc>(ChangeType: {fromJSON: (json: any) => C}, json: any): ChangeSet<C> {\n    let mirror, changes\n    if (Array.isArray(json)) {\n      mirror = empty\n      changes = json\n    } else if (!json || !Array.isArray(json.mirror) || !Array.isArray(json.changes)) {\n      throw new RangeError(\"Invalid JSON representation for ChangeSet\")\n    } else {\n      ;({mirror, changes} = json)\n    }\n    return new ChangeSet(changes.map((ch: any) => ChangeType.fromJSON(ch)), mirror)\n  }\n}\n\nclass PartialMapping implements Mapping {\n  constructor(readonly changes: ChangeSet<any>, readonly from: number, readonly to: number) {}\n  mapPos(pos: number, bias: number = -1, mode: MapMode = MapMode.Simple): number {\n    return this.changes.mapInner(pos, bias, mode, this.from, this.to)\n  }\n}\n\n/// A changed range represents a replacement as two absolute ranges,\n/// one pointing into the old document (the replaced content) and one\n/// pointing into the new document (the content that replaces it).\nexport class ChangedRange {\n  // FIXME store unchanged ranges instead?\n  constructor(\n    /// The start of the replaced range in the old document.\n    readonly fromA: number,\n    /// The end of the replaced range in the old document.\n    readonly toA: number,\n    /// The start of the replacing range in the new document.\n    readonly fromB: number,\n    /// The end of the replacing range in the new document.\n    readonly toB: number) {}\n\n  /// @internal\n  join(other: ChangedRange): ChangedRange {\n    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA),\n                            Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB))\n  }\n\n  /// @internal\n  // FIXME used by view. Document?\n  addToSet(set: ChangedRange[]): ChangedRange[] {\n    let i = set.length, me: ChangedRange = this\n    for (; i > 0; i--) {\n      let range = set[i - 1]\n      if (range.fromA > me.toA) continue\n      if (range.toA < me.fromA) break\n      me = me.join(range)\n      set.splice(i - 1, 1)\n    }\n    set.splice(i, 0, me)\n    return set\n  }\n\n  /// The difference in document length created by this change\n  /// (positive when the document grew).\n  get lenDiff() { return (this.toB - this.fromB) - (this.toA - this.fromA) }\n\n  /// @internal\n  static mapPos(pos: number, bias: number, changes: readonly ChangedRange[]): number {\n    let off = 0\n    for (let range of changes) {\n      if (pos < range.fromA) break\n      if (pos <= range.toA) {\n        let side = range.toA == range.fromA ? bias : pos == range.fromA ? -1 : pos == range.toA ? 1 : bias\n        return side < 0 ? range.fromB : range.toB\n      }\n      off = range.toB - range.toA\n    }\n    return pos + off\n  }\n}\n","import {Text} from \"../../text\"\nimport {Annotation, allowMultipleSelections} from \"./extension\"\nimport {EditorState} from \"./state\"\nimport {EditorSelection, SelectionRange, checkSelection} from \"./selection\"\nimport {Change, ChangeSet} from \"./change\"\nimport {Extension, ExtensionGroup} from \"./facet\"\n\nconst enum Flag { SelectionSet = 1, ScrollIntoView = 2 }\n\n/// Changes to the editor state are grouped into transactions.\n/// Usually, a user action creates a single transaction, which may\n/// contain zero or more document changes. Create a transaction by\n/// calling [`EditorState.t`](#state.EditorState.t).\n///\n/// Transactions are mutable, and usually built up piece by piece with\n/// updating methods and method chaining (most methods return the\n/// transaction itself). Once they are\n/// [applied](#state.Transaction.apply), they can't be updated\n/// anymore.\nexport class Transaction {\n  /// The document changes made by this transaction.\n  changes: ChangeSet = ChangeSet.empty\n  /// The document versions after each of the changes.\n  docs: Text[] = []\n  /// The selection at the end of the transaction.\n  selection: EditorSelection\n  private _annotations: {[id: number]: any} = Object.create(null)\n  private flags: number = 0\n  /// @internal\n  reconfigureData: {base: Extension, replaced: Map<ExtensionGroup, Extension>} | null = null\n  private state: EditorState | null = null\n\n  /// @internal\n  constructor(\n    /// The state from which the transaction starts.\n    readonly startState: EditorState,\n    time: number = Date.now()\n  ) {\n    this.selection = startState.selection\n    this._annotations[Transaction.time.id] = time\n  }\n\n  /// The document at the end of the transaction.\n  get doc(): Text {\n    let last = this.docs.length - 1\n    return last < 0 ? this.startState.doc : this.docs[last]\n  }\n\n  /// Add annotations to this transaction. Annotations can provide\n  /// additional information about the transaction.\n  annotate<T>(annotation: Annotation<T>, value: T): Transaction {\n    this.ensureOpen()\n    this._annotations[annotation.id] = value\n    return this\n  }\n\n  /// Get the value of the given annotation type, if any.\n  annotation<T>(annotation: Annotation<T>): T | undefined {\n    return this._annotations[annotation.id]\n  }\n\n  /// Add a change to this transaction. If `mirror` is given, it\n  /// should be the index (in `this.changes.changes`) at which the\n  /// mirror image of this change sits.\n  change(change: Change, mirror?: number): Transaction {\n    this.ensureOpen()\n    if (change.from == change.to && change.length == 0) return this\n    if (change.from < 0 || change.to < change.from || change.to > this.doc.length)\n      throw new RangeError(`Invalid change ${change.from} to ${change.to}`)\n    this.changes = this.changes.append(change, mirror)\n    this.docs.push(change.apply(this.doc))\n    this.selection = this.selection.map(change)\n    return this\n  }\n\n  /// Indicates whether the transaction changed the document.\n  get docChanged(): boolean {\n    return this.changes.length > 0\n  }\n\n  /// Add a change replacing the given document range with the given\n  /// content.\n  replace(from: number, to: number, text: string | readonly string[]): Transaction {\n    return this.change(new Change(from, to, typeof text == \"string\" ? this.startState.splitLines(text) : text))\n  }\n\n  /// Replace all selection ranges with the given content.\n  replaceSelection(text: string | readonly string[]): Transaction {\n    let content = typeof text == \"string\" ? this.startState.splitLines(text) : text\n    return this.forEachRange(range => {\n      let change = new Change(range.from, range.to, content)\n      this.change(change)\n      return new SelectionRange(range.from + change.length)\n    })\n  }\n\n  /// Run the given function for each selection range. The method will\n  /// map the ranges to reflect deletions/insertions that happen\n  /// before them. At the end, set the new selection to the ranges\n  /// returned by the function (again, automatically mapped to for\n  /// changes that happened after them).\n  forEachRange(f: (range: SelectionRange, tr: Transaction) => SelectionRange): Transaction {\n    let sel = this.selection, start = this.changes.length, newRanges: SelectionRange[] = []\n    for (let range of sel.ranges) {\n      let before = this.changes.length\n      let result = f(range.map(this.changes.partialMapping(start)), this)\n      if (this.changes.length > before) {\n        let mapping = this.changes.partialMapping(before)\n        for (let i = 0; i < newRanges.length; i++) newRanges[i] = newRanges[i].map(mapping)\n      }\n      newRanges.push(result)\n    }\n    return this.setSelection(EditorSelection.create(newRanges, sel.primaryIndex))\n  }\n\n  /// Update the selection.\n  setSelection(selection: EditorSelection): Transaction {\n    this.ensureOpen()\n    if (!this.startState.facet(allowMultipleSelections)) selection = selection.asSingle()\n    checkSelection(selection, this.doc)\n    this.selection = selection\n    this.flags |= Flag.SelectionSet\n    return this\n  }\n\n  /// Tells you whether this transaction explicitly sets a new\n  /// selection (as opposed to just mapping the selection through\n  /// changes).\n  get selectionSet(): boolean {\n    return (this.flags & Flag.SelectionSet) > 0\n  }\n\n  /// Set a flag on this transaction that indicates that the editor\n  /// should scroll the selection into view after applying it.\n  scrollIntoView(): Transaction {\n    this.ensureOpen()\n    this.flags |= Flag.ScrollIntoView\n    return this\n  }\n\n  /// Query whether the selection should be scrolled into view after\n  /// applying this transaction.\n  get scrolledIntoView(): boolean {\n    return (this.flags & Flag.ScrollIntoView) > 0\n  }\n\n  /// Provice new content for a given [extension\n  /// group](#state.ExtensionGroup) in the current configuration. (If\n  /// the group isn't present in the configuration, this will not have\n  /// any effect.)\n  replaceExtension(group: ExtensionGroup, content: Extension) {\n    this.ensureOpen()\n    if (!this.reconfigureData) {\n      let replaced = new Map<ExtensionGroup, Extension>()\n      this.startState.config.replacements.forEach((ext, group) => replaced.set(group, ext))\n      this.reconfigureData = {base: this.startState.config.source, replaced}\n    }\n    this.reconfigureData.replaced.set(group, content)\n    return this\n  }\n\n  /// Move to an entirely new state configuration.\n  reconfigure(extension: Extension) {\n    this.ensureOpen()\n    this.reconfigureData = {base: extension, replaced: new Map}\n    return this\n  }\n\n  /// Indicates whether the transaction reconfigures the state.\n  get reconfigured(): boolean {\n    return this.reconfigureData != null\n  }\n\n  private ensureOpen() {\n    if (this.state) throw new Error(\"Transactions may not be modified after being applied\")\n  }\n\n  /// Apply this transaction, computing a new editor state. May be\n  /// called multiple times (the result is cached). The transaction\n  /// cannot be further modified after this has been called.\n  apply(): EditorState {\n    return this.state || (this.state = this.startState.applyTransaction(this))\n  }\n\n  /// Create a set of changes that undo the changes made by this\n  /// transaction.\n  invertedChanges(): ChangeSet<Change> {\n    if (!this.changes.length) return ChangeSet.empty\n    let changes: Change[] = [], set = this.changes\n    for (let i = set.length - 1; i >= 0; i--)\n      changes.push(set.changes[i].invert(i == 0 ? this.startState.doc : this.docs[i - 1]))\n    return new ChangeSet(changes, set.mirror.length ? set.mirror.map(i => set.length - i - 1) : set.mirror)\n  }\n\n  /// Annotation used to store transaction timestamps.\n  static time = Annotation.define<number>()\n\n  /// Annotation used to indicate that this transaction shouldn't\n  /// clear the goal column, which is used during vertical cursor\n  /// motion (so that moving over short lines doesn't reset the\n  /// horizontal position to the end of the shortest line). Should\n  /// generally only be set by commands that perform vertical motion.\n  static preserveGoalColumn = Annotation.define<boolean>()\n\n  /// Annotation used to associate a transaction with a user interface\n  /// event. The view will set this to...\n  ///\n  ///  - `\"paste\"` when pasting content\n  ///  - `\"cut\"` when cutting\n  ///  - `\"drop\"` when content is inserted via drag-and-drop\n  ///  - `\"keyboard\"` when moving the selection via the keyboard\n  ///  - `\"pointer\"` when moving the selection through the pointing device\n  static userEvent = Annotation.define<string>()\n\n  /// Annotation indicating whether a transaction should be added to\n  /// the undo history or not.\n  static addToHistory = Annotation.define<boolean>()\n}\n","import {Text} from \"../../text\"\nimport {Tree} from \"lezer-tree\"\nimport {EditorSelection, checkSelection} from \"./selection\"\nimport {Transaction} from \"./transaction\"\nimport {Syntax, allowMultipleSelections} from \"./extension\"\nimport {Configuration, Facet, Extension, StateField, SlotStatus, ensureAddr, getAddr} from \"./facet\"\n\n/// Options passed when [creating](#state.EditorState^create) an\n/// editor state.\nexport interface EditorStateConfig {\n  /// The initial document. Defaults to an empty document. Can be\n  /// provided either as a plain string (which will be split into\n  /// lines according to the value of the [`lineSeparator`\n  /// behavior](#state.EditorState^lineSeparator)), or an instance of\n  /// the [`Text`](#text.Text) class (which is what the state will use\n  /// to represent the document).\n  doc?: string | Text\n  /// The starting selection. Defaults to a cursor at the very start\n  /// of the document.\n  selection?: EditorSelection\n  /// [State](#state.EditorState^extend) or\n  /// [view](#view.EditorView^extend) extensions to associate with\n  /// this state. View extensions provided here only take effect when\n  /// the state is put into an editor view.\n  extensions?: Extension\n}\n\nconst DefaultIndentUnit = 2, DefaultTabsize = 4, DefaultSplit = /\\r\\n?|\\n/\n\n/// The editor state class is a persistent (immutable) data structure.\n/// To update a state, you [create](#state.EditorState.t) and\n/// [apply](#state.Transaction.apply) a\n/// [transaction](#state.Transaction), which produces a _new_ state\n/// instance, without modifying the original object.\n///\n/// As such, _never_ mutate properties of a state directly. That'll\n/// just break things.\nexport class EditorState {\n  /// @internal\n  readonly values: any[]\n  /// @internal\n  readonly status: SlotStatus[]\n  /// @internal\n  applying: null | Transaction = null\n\n  /// @internal\n  constructor(\n    /// @internal\n    readonly config: Configuration,\n    /// The current document.\n    readonly doc: Text,\n    /// The current selection.\n    readonly selection: EditorSelection,\n    tr: Transaction | null = null\n  ) {\n    this.status = config.statusTemplate.slice()\n    if (tr && !tr.reconfigured) {\n      this.values = tr.startState.values.slice()\n    } else {\n      this.values = config.dynamicSlots.map(_ => null)\n      // Copy over old values for shared facets/fields if this is a reconfigure\n      if (tr) for (let id in config.address) {\n        let cur = config.address[id], prev = tr.startState.config.address[id]\n        if (prev != null && (cur & 1) == 0) this.values[cur >> 1] = getAddr(tr.startState, prev)\n      }\n    }\n\n    this.applying = tr\n    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1)\n    this.applying = null\n  }\n\n  /// Retrieve the value of a [state field](#state.StateField). Throws\n  /// an error when the state doesn't have that field, unless you pass\n  /// `false` as second parameter.\n  field<T>(field: StateField<T>): T\n  field<T>(field: StateField<T>, require: false): T | undefined\n  field<T>(field: StateField<T>, require: boolean = true): T | undefined {\n    let addr = this.config.address[field.id]\n    if (addr == null) {\n      if (require) throw new RangeError(\"Field is not present in this state\")\n      return undefined\n    }\n    ensureAddr(this, addr)\n    return getAddr(this, addr)\n  }\n\n  /// Start a new transaction from this state. When not given, the\n  /// timestamp defaults to\n  /// [`Date.now()`](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now).\n  t(timestamp?: number): Transaction {\n    return new Transaction(this, timestamp)\n  }\n\n  /// Join an array of lines using the state's [line\n  /// separator](#state.EditorState^lineSeparator).\n  joinLines(text: readonly string[]): string { return text.join(this.facet(EditorState.lineSeparator) || \"\\n\") }\n\n  /// Split a string into lines using the state's [line\n  /// separator](#state.EditorState^lineSeparator).\n  splitLines(text: string): string[] { return text.split(this.facet(EditorState.lineSeparator) || DefaultSplit) }\n\n  /// Get the value of a state [behavior](#extension.Behavior).\n  facet<Output>(facet: Facet<any, Output>): Output {\n    let addr = this.config.address[facet.id]\n    if (addr == null) return facet.default\n    ensureAddr(this, addr)\n    return getAddr(this, addr)\n  }\n\n  /// Convert this state to a JSON-serializable object.\n  toJSON(): any {\n    // FIXME plugin state serialization\n    return {\n      doc: this.joinLines(this.doc.sliceLines(0, this.doc.length)),\n      selection: this.selection.toJSON()\n    }\n  }\n\n  /// Deserialize a state from its JSON representation.\n  static fromJSON(json: any, config: EditorStateConfig = {}): EditorState {\n    if (!json || typeof json.doc != \"string\")\n      throw new RangeError(\"Invalid JSON representation for EditorState\")\n    return EditorState.create({\n      doc: json.doc,\n      selection: EditorSelection.fromJSON(json.selection),\n      extensions: config.extensions\n    })\n  }\n\n  /// @internal\n  applyTransaction(tr: Transaction): EditorState {\n    let reconf = tr.reconfigureData, config = reconf ? Configuration.resolve(reconf.base, reconf.replaced, this): this.config\n    return new EditorState(config, tr.doc, tr.selection, tr)\n  }\n\n  /// Create a new state. You'll usually only need this when\n  /// initializing an editorâ€”updated states are created by applying\n  /// transactions.\n  static create(config: EditorStateConfig = {}): EditorState {\n    let configuration = Configuration.resolve(config.extensions || [])\n    let doc = config.doc instanceof Text ? config.doc\n      : Text.of((config.doc || \"\").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit))\n    let selection = config.selection || EditorSelection.single(0)\n    checkSelection(selection, doc)\n    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle()\n    return new EditorState(configuration, doc, selection)\n  }\n\n  /// A facet that, when enabled, causes the editor to allow multiple\n  /// ranges to be selected. You should probably not use this\n  /// directly, but let a plugin like\n  /// [multiple-selections](#multiple-selections) handle it (which\n  /// also makes sure the selections are visible in the view).\n  static allowMultipleSelections = allowMultipleSelections\n\n  /// Facet that defines a way to query for automatic indentation\n  /// depth at the start of a given line.\n  static indentation = Facet.define<(state: EditorState, pos: number) => number>()\n\n  /// Configures the tab size to use in this state. The first\n  /// (highest-precedence) value of the behavior is used.\n  static tabSize = Facet.define<number, number>({\n    combine: values => values.length ? values[0] : DefaultTabsize\n  })\n\n  /// The size (in columns) of a tab in the document, determined by\n  /// the [`tabSize`](#state.EditorState^tabSize) behavior.\n  get tabSize() { return this.facet(EditorState.tabSize) }\n\n  /// The line separator to use. By default, any of `\"\\n\"`, `\"\\r\\n\"`\n  /// and `\"\\r\"` is treated as a separator when splitting lines, and\n  /// lines are joined with `\"\\n\"`.\n  ///\n  /// When you configure a value here, only that precise separator\n  /// will be used, allowing you to round-trip documents through the\n  /// editor without normalizing line separators.\n  static lineSeparator = Facet.define<string, string | undefined>({\n    combine: values => values.length ? values[0] : undefined,\n    static: true\n  })\n\n  /// Facet for overriding the unit (in columns) by which\n  /// indentation happens. When not set, this defaults to 2.\n  static indentUnit = Facet.define<number, number>({\n    combine: values => values.length ? values[0] : DefaultIndentUnit\n  })\n\n  /// The size of an indent unit in the document. Determined by the\n  /// [`indentUnit`](#state.EditorState^indentUnit) facet.\n  get indentUnit() { return this.facet(EditorState.indentUnit) }\n\n  /// Facet that registers a parsing service for the state.\n  static syntax = Facet.define<Syntax>()\n\n  /// Get the syntax tree for this state, which is the current\n  /// (possibly incomplete) parse tree of the [syntax](#state.Syntax)\n  /// with the highest precedence, or the empty tree if there is no\n  /// syntax available.\n  get tree() {\n    let syntax = this.facet(EditorState.syntax)\n    return syntax.length ? syntax[0].getTree(this) : Tree.empty\n  }\n\n  /// A facet that registers a code folding service. When called\n  /// with the extent of a line, it'll return a range object when a\n  /// foldable that starts on that line (but continues beyond it) can\n  /// be found.\n  static foldable = Facet.define<(state: EditorState, lineStart: number, lineEnd: number) => ({from: number, to: number} | null)>()\n}\n","/// Utility function for combining behaviors to fill in a config\n/// object from an array of provided configs. Will, by default, error\n/// when a field gets two values that aren't ===-equal, but you can\n/// provide combine functions per field to do something else.\nexport function combineConfig<Config>(\n  configs: readonly Partial<Config>[],\n  defaults: Partial<Config>, // Should hold only the optional properties of Config, but I haven't managed to express that\n  combine: {[P in keyof Config]?: (first: Config[P], second: Config[P]) => Config[P]} = {}\n): Config {\n  let result: any = {}\n  for (let config of configs) for (let key of Object.keys(config) as (keyof Config)[]) {\n    let value = config[key], current = result[key]\n    if (current === undefined) result[key] = value\n    else if (current === value || value === undefined) {} // No conflict\n    else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key]!(current as any, value as any)\n    else throw new Error(\"Config merge conflict for field \" + key)\n  }\n  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key]\n  return result\n}\n\n/// Defaults the fields in a configuration object to values given in\n/// `defaults` if they are not already present.\nexport function fillConfig<Config>(config: Config, defaults: Partial<Config>): Required<Config> {\n  let result: any = {}\n  for (let key in config) result[key] = config[key]\n  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key]\n  return result\n}\n"],"names":["charType","NodeProp","MapMode","Text","Tree"],"mappings":"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"}
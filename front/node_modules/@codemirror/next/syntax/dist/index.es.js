import { NodeProp, Tree } from 'lezer-tree';
import { EditorState, Annotation, StateField, languageData } from '../../state';
import { ViewPlugin } from '../../view';

/// A syntax tree node prop used to associate indentation strategies
/// with node types. Such a strategy is a function from an indentation
/// context to a number. That number may be -1, to indicate that no
/// definitive indentation can be determined, or a column number to
/// which the given line should be indented.
const indentNodeProp = new NodeProp();
function syntaxIndentation(syntax) {
    return EditorState.indentation.of((state, pos) => {
        return computeIndentation(state, syntax.getTree(state), pos);
    });
}
// Compute the indentation for a given position from the syntax tree.
function computeIndentation(state, ast, pos) {
    let tree = ast.resolve(pos);
    // Enter previous nodes that end in empty error terms, which means
    // they were broken off by error recovery, so that indentation
    // works even if the constructs haven't been finished.
    for (let scan = tree, scanPos = pos;;) {
        let last = scan.childBefore(scanPos);
        if (!last)
            break;
        if (last.type.prop(NodeProp.error) && last.start == last.end) {
            tree = scan;
            scanPos = last.start;
        }
        else {
            scan = last;
            scanPos = scan.end + 1;
        }
    }
    for (; tree; tree = tree.parent) {
        let strategy = indentStrategy(tree.type) || (tree.parent == null ? topIndent : null);
        if (strategy)
            return strategy(new IndentContext(state, pos, tree));
    }
    return -1;
}
function indentStrategy(type) {
    let strategy = type.prop(indentNodeProp);
    if (!strategy) {
        let delim = type.prop(NodeProp.delim);
        if (delim)
            return delimitedIndent({ closing: delim.split(" ")[1] });
    }
    return strategy;
}
function topIndent() { return 0; }
/// Objects of this type provide context information and helper
/// methods to indentation functions.
class IndentContext {
    /// @internal
    constructor(
    /// The editor state.
    state, 
    /// The position at which indentation is being computed.
    pos, 
    /// The syntax tree node for which the indentation strategy is
    /// registered.
    node) {
        this.state = state;
        this.pos = pos;
        this.node = node;
    }
    /// The indent unit (number of spaces per indentation level).
    get unit() { return this.state.indentUnit; }
    /// Get the text directly after `this.pos`, either the entire line
    /// or the next 50 characters, whichever is shorter.
    get textAfter() {
        return this.state.doc.slice(this.pos, Math.min(this.pos + 50, this.state.doc.lineAt(this.pos).end)).match(/^\s*(.*)/)[1];
    }
    /// find the column position (taking tabs into account) of the given
    /// position in the given string.
    countColumn(line, pos) {
        // FIXME use extending character information
        if (pos < 0)
            pos = line.length;
        let tab = this.state.tabSize;
        for (var i = 0, n = 0;;) {
            let nextTab = line.indexOf("\t", i);
            if (nextTab < 0 || nextTab >= pos)
                return n + (pos - i);
            n += nextTab - i;
            n += tab - (n % tab);
            i = nextTab + 1;
        }
    }
    /// Find the indentation column of the given document line.
    lineIndent(line) {
        let text = line.slice(0, Math.min(50, line.length, this.node.start > line.start ? this.node.start - line.start : 1e8));
        return this.countColumn(text, text.search(/\S/));
    }
    /// Get the indentation at the reference line for `this.tree`, which
    /// is the line on which it starts, unless there is a node that is
    /// _not_ a parent of this node covering the start of that line. If
    /// so, the line at the start of that node is tried, again skipping
    /// on if it is covered by another such node.
    get baseIndent() {
        let line = this.state.doc.lineAt(this.node.start);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = this.node.resolve(line.start);
            while (atBreak.parent && atBreak.parent.start == atBreak.start)
                atBreak = atBreak.parent;
            if (isParent(atBreak, this.node))
                break;
            line = this.state.doc.lineAt(atBreak.start);
        }
        return this.lineIndent(line);
    }
    /// Find the column for the given position.
    column(pos) {
        let line = this.state.doc.lineAt(pos);
        return this.countColumn(line.slice(0, pos - line.start), pos - line.start);
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.start);
    if (!openToken)
        return null;
    let openLine = context.state.doc.lineAt(openToken.start);
    for (let pos = openToken.end;;) {
        let next = tree.childAfter(pos);
        if (!next)
            return null;
        if (!next.type.prop(NodeProp.skipped))
            return next.start < openLine.end ? openToken : null;
        pos = next.end;
    }
}
/// An indentation strategy for delimited (usually bracketed) nodes.
/// Will, by default, indent one unit more than the parent's base
/// indent unless the line starts with a closing token. When `align`
/// is true and there are non-skipped nodes on the node's opening
/// line, the content of the node will be aligned with the end of the
/// opening node, like this:
///
///     foo(bar,
///         baz)
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => {
        let closed = context.textAfter.slice(0, closing.length) == closing;
        let aligned = align ? bracketedAligned(context) : null;
        if (aligned)
            return closed ? context.column(aligned.start) : context.column(aligned.end);
        return context.baseIndent + (closed ? 0 : context.unit * units);
    };
}
/// An indentation strategy that aligns a node content to its base
/// indentation.
const flatIndent = (context) => context.baseIndent;
/// Creates an indentation strategy that, by default, indents
/// continued lines one unit more than the node's base indentation.
/// You can provide `except` to prevent indentation of lines that
/// match a pattern (for example `/^else\b/` in `if`/`else`
/// constructs), and you can change the amount of units used with the
/// `units` option.
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}

/// This node prop is used to associate folding information with node
/// types. Given a subtree, it should check whether that tree is
/// foldable and return the range that can be collapsed when it is.
const foldNodeProp = new NodeProp();
function syntaxFolding(syntax) {
    return EditorState.foldable.of((state, start, end) => {
        let inner = syntax.getTree(state).resolve(end);
        let found = null;
        for (let cur = inner; cur; cur = cur.parent) {
            if (cur.end <= end || cur.start > end)
                continue;
            if (found && cur.start < start)
                break;
            let prop = cur.type.prop(foldNodeProp);
            if (prop) {
                let value = prop(cur, state);
                if (value && value.from <= end && value.from >= start && value.to > end)
                    found = value;
            }
        }
        return found;
    });
}

/// A [syntax provider](#state.Syntax) based on a
/// [Lezer](https://lezer.codemirror.net) parser.
class LezerSyntax {
    /// Create a syntax instance for the given parser. You'll usually
    /// want to use the
    /// [`withProps`](https://lezer.codemirror.net/docs/ref/#lezer.Parser.withProps)
    /// method to register CodeMirror-specific syntax node props in the
    /// parser, before passing it to this constructor.
    constructor(parser) {
        this.parser = parser;
        let setSyntax = Annotation.define();
        this.field = StateField.define({
            create(state) { return SyntaxState.advance(Tree.empty, parser, state.doc); },
            update(value, tr) { return value.apply(tr, parser, setSyntax); }
        });
        this.extension = [
            EditorState.syntax.of(this),
            this.field,
            ViewPlugin.define(view => new HighlightWorker(view, this, setSyntax)),
            syntaxIndentation(this),
            syntaxFolding(this)
        ];
    }
    getTree(state) {
        return state.field(this.field).tree;
    }
    parsePos(state) {
        return state.field(this.field).upto;
    }
    ensureTree(state, upto, timeout = 100) {
        let field = state.field(this.field);
        if (field.upto >= upto)
            return field.updatedTree;
        if (!field.parse)
            field.startParse(this.parser, state.doc);
        if (field.parse.pos < upto) {
            let done = work(field.parse, timeout, upto);
            if (done)
                return field.stopParse(done, state.doc.length);
        }
        return field.parse.pos < upto ? null : field.stopParse();
    }
    get docNodeType() { return this.parser.group.types[1]; }
    languageDataAt(state, pos) {
        let type = this.parser.group.types[1];
        if (this.parser.hasNested) {
            let tree = this.getTree(state);
            let target = tree.resolve(pos);
            while (target) {
                if (target.type.prop(NodeProp.top)) {
                    type = target.type;
                    break;
                }
                target = target.parent;
            }
        }
        return (type.prop(languageData) || nothing);
    }
}
const nothing = {};
class DocStream {
    constructor(doc, length = doc.length) {
        this.doc = doc;
        this.length = length;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    get(pos) {
        if (pos >= this.length)
            return -1;
        let stringStart = this.cursorPos - this.string.length;
        if (pos < stringStart || pos >= this.cursorPos) {
            if (pos < this.cursorPos) { // Reset the cursor if we have to go back
                this.cursor = this.doc.iter();
                this.cursorPos = 0;
            }
            this.string = this.cursor.next(pos - this.cursorPos).value;
            this.cursorPos = pos + this.string.length;
            stringStart = this.cursorPos - this.string.length;
        }
        return this.string.charCodeAt(pos - stringStart);
    }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.slice(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
    clip(at) {
        return new DocStream(this.doc, at);
    }
}
function work(parse, time, upto = 5000000 /* MaxPos */) {
    let endTime = Date.now() + time;
    for (;;) {
        let done = parse.advance();
        if (done)
            return done;
        if (parse.pos > upto || Date.now() > endTime)
            return null;
    }
}
function takeTree(parse, base) {
    let parsed = parse.forceFinish();
    let after = base.applyChanges([{ fromA: 0, toA: parse.pos, fromB: 0, toB: parse.pos }]);
    return parsed.append(after);
}
class SyntaxState {
    constructor(tree, upto) {
        this.tree = tree;
        this.upto = upto;
        this.parse = null;
        this.updatedTree = tree;
    }
    static advance(tree, parser, doc) {
        let parse = parser.startParse(new DocStream(doc), { cache: tree });
        let done = work(parse, 25 /* Apply */);
        return done ? new SyntaxState(done, doc.length) : new SyntaxState(takeTree(parse, tree), parse.pos);
    }
    apply(tr, parser, annotation) {
        let given = tr.annotation(annotation);
        return given || (!tr.docChanged && this) || SyntaxState.advance((this.parse ? takeTree(this.parse, this.updatedTree) : this.updatedTree).applyChanges(tr.changes.changedRanges()), parser, tr.doc);
    }
    startParse(parser, doc) {
        this.parse = parser.startParse(new DocStream(doc), { cache: this.updatedTree });
    }
    stopParse(tree, upto) {
        if (!tree)
            tree = takeTree(this.parse, this.updatedTree);
        this.updatedTree = tree;
        this.upto = (upto !== null && upto !== void 0 ? upto : this.parse.pos);
        this.parse = null;
        return tree;
    }
}
let requestIdle = typeof window != "undefined" && window.requestIdleCallback ||
    ((callback, { timeout }) => setTimeout(callback, timeout));
let cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
// FIXME figure out some way to back off from full re-parses when the
// document is large—you could waste a lot of battery re-parsing a
// multi-megabyte document every time you insert a backtick, even if
// it happens in the background.
class HighlightWorker {
    constructor(view, syntax, setSyntax) {
        this.view = view;
        this.syntax = syntax;
        this.setSyntax = setSyntax;
        this.working = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        if (update.docChanged)
            this.scheduleWork();
    }
    scheduleWork() {
        if (this.working > -1)
            return;
        let { state } = this.view, field = state.field(this.syntax.field);
        if (field.upto >= state.doc.length)
            return;
        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });
    }
    work(deadline) {
        this.working = -1;
        let { state } = this.view, field = state.field(this.syntax.field);
        if (field.upto >= state.doc.length)
            return;
        if (!field.parse)
            field.startParse(this.syntax.parser, state.doc);
        let done = work(field.parse, deadline ? Math.max(25 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */);
        if (done || field.parse.badness > .8)
            this.view.dispatch(state.t().annotate(this.setSyntax, new SyntaxState(field.stopParse(done, state.doc.length), state.doc.length)));
        else
            this.scheduleWork();
    }
    destroy() {
        if (this.working >= 0)
            cancelIdle(this.working);
    }
}

function mkMatchProp() { return new NodeProp({ deserialize(str) { return str.split(" "); } }); }
/// A node prop that encodes information about which other nodes match
/// this node as delimiters. Should hold a space-separated list of
/// node names of the closing nodes that match this node.
const openNodeProp = mkMatchProp();
/// Like `openNodeProp`, but for closing nodes. Should hold a
/// space-separated list of opening node names that match this closing
/// delimiter.
const closeNodeProp = mkMatchProp();

export { IndentContext, LezerSyntax, closeNodeProp, continuedIndent, delimitedIndent, flatIndent, foldNodeProp, indentNodeProp, openNodeProp };

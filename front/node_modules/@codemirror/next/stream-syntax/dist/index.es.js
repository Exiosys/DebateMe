import { Annotation, StateField, EditorState, languageData } from '../../state';
import { ViewPlugin } from '../../view';
import { Tree, NodeType, NodeGroup } from 'lezer-tree';
import { defaultTags } from '../../highlight';

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
// FIXME more or less duplicated in indent/src/indent.ts
function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
            end = string.length;
    }
    for (let i = startIndex || 0, n = startValue || 0;;) {
        let nextTab = string.indexOf("\t", i);
        if (nextTab < 0 || nextTab >= end)
            return n + (end - i);
        n += nextTab - i;
        n += tabSize - (n % tabSize);
        i = nextTab + 1;
    }
}
// STRING STREAM
/// Encapsulates a single line of input. Given to stream syntax code,
/// which uses it to tokenize the content.
class StringStream {
    /// @internal
    constructor(
    /// The line.
    string, 
    /// Current tab size.
    tabSize) {
        this.string = string;
        this.tabSize = tabSize;
        /// The current position on the line.
        this.pos = 0;
        /// The start position of the current token.
        this.start = 0;
        this.lineStart = 0;
        this.lastColumnPos = 0;
        this.lastColumnValue = 0;
    }
    /// True if we are at the end of the line.
    eol() { return this.pos >= this.string.length; }
    /// True if we are at the start of the line.
    sol() { return this.pos == this.lineStart; }
    /// Get the next code unit after the current position, or undefined
    /// if we're at the end of the line.
    peek() { return this.string.charAt(this.pos) || undefined; }
    /// Read the next code unit and advance `this.pos`.
    next() {
        if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
    }
    /// Match the next character against the given string, regular
    /// expression, or predicate. Consume and return it if it matches.
    eat(match) {
        let ch = this.string.charAt(this.pos);
        let ok;
        if (typeof match == "string")
            ok = ch == match;
        else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    }
    /// Continue matching characters that match the given string,
    /// regular expression, or predicate function. Return true if any
    /// characters were consumed.
    eatWhile(match) {
        let start = this.pos;
        while (this.eat(match)) { }
        return this.pos > start;
    }
    /// Consume whitespace ahead of `this.pos`. Return true if any was
    /// found.
    eatSpace() {
        let start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos > start;
    }
    /// Move to the end of the line.
    skipToEnd() { this.pos = this.string.length; }
    /// Move to directly before the given character, if found on the
    /// current line.
    skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    }
    /// Move back `n` characters.
    backUp(n) { this.pos -= n; }
    /// Get the column position at `this.pos`.
    column() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    }
    /// Get the indentation column of the current line.
    indentation() {
        return countColumn(this.string, null, this.tabSize) -
            (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    }
    /// Match the input against the given string or regular expression
    /// (which should start with a `^`). Return true or the regexp match
    /// if it matches.
    ///
    /// Unless `consume` is set to `false`, this will move `this.pos`
    /// past the matched text.
    ///
    /// When matching a string `caseInsensitive` can be set to true to
    /// make the match case-insensitive.
    match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
            else
                return null;
        }
        else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
                return null;
            if (match && consume !== false)
                this.pos += match[0].length;
            return match;
        }
    }
    /// Get the current token.
    current() { return this.string.slice(this.start, this.pos); }
    /// Hide the first `n` characters of the stream while running
    /// `inner`. This can be useful for nesting modes.
    hideFirstChars(n, inner) {
        this.lineStart += n;
        try {
            return inner();
        }
        finally {
            this.lineStart -= n;
        }
    }
}
class StringStreamCursor {
    constructor(text, offset, tabSize = 4) {
        this.offset = offset;
        this.tabSize = tabSize;
        this.iter = text.iterLines(offset);
        this.curLineEnd = this.offset - 1;
    }
    next() {
        let { value, done } = this.iter.next();
        if (done)
            throw new RangeError("Reached end of document");
        const res = new StringStream(value, this.tabSize);
        this.offset = this.curLineEnd + 1;
        this.curLineEnd += value.length + 1;
        return res;
    }
}

class StreamParserInstance {
    constructor(spec) {
        this.token = spec.token;
        this.blankLine = spec.blankLine || (() => { });
        this.startState = spec.startState || (() => true);
        this.copyState = spec.copyState || defaultCopyState;
        this.indent = spec.indent || (() => -1);
        this.docType = docID(spec.docProps || []);
    }
    readToken(state, stream, editorState) {
        stream.start = stream.pos;
        for (let i = 0; i < 10; i++) {
            let result = this.token(stream, state, editorState);
            if (stream.pos > stream.start)
                return result;
        }
        throw new Error("Stream parser failed to advance stream.");
    }
}
function defaultCopyState(state) {
    if (typeof state != "object")
        return state;
    let newState = {};
    for (let prop in state) {
        let val = state[prop];
        newState[prop] = (val instanceof Array ? val.slice() : val);
    }
    return newState;
}
/// A syntax provider that uses a stream parser.
class StreamSyntax {
    /// Create a stream syntax.
    constructor(parser) {
        let parserInst = this.parser = new StreamParserInstance(parser);
        let setSyntax = Annotation.define();
        this.field = StateField.define({
            create(state) {
                let start = new SyntaxState(Tree.empty, [parserInst.startState(state)], 1, 0, null);
                start.advanceFrontier(parserInst, state, 25 /* Apply */);
                start.tree = start.updatedTree;
                return start;
            },
            update(value, tr, state) {
                let set = tr.annotation(setSyntax);
                if (set)
                    return set;
                if (!tr.docChanged)
                    return value;
                let { start, number } = tr.doc.lineAt(tr.changes.changedRanges()[0].fromA);
                let newValue = number >= value.frontierLine ? value.copy() : value.cut(number, start);
                newValue.advanceFrontier(parserInst, state, 25 /* Apply */);
                newValue.tree = newValue.updatedTree;
                return newValue;
            }
        });
        this.extension = [
            EditorState.syntax.of(this),
            ViewPlugin.define(view => new HighlightWorker(view, this.parser, this.field, setSyntax)),
            this.field,
            EditorState.indentation.of((state, pos) => {
                return state.field(this.field).getIndent(this.parser, state, pos);
            })
        ];
    }
    getTree(state) {
        return state.field(this.field).tree;
    }
    parsePos(state) {
        return state.field(this.field).frontierPos;
    }
    ensureTree(state, upto, timeout = 100) {
        let field = state.field(this.field);
        if (field.frontierPos < upto)
            field.advanceFrontier(this.parser, state, timeout, upto);
        return field.frontierPos < upto ? null : field.updatedTree;
    }
    get docNodeType() { return typeArray[this.parser.docType]; }
    languageDataAt() {
        return (typeArray[this.parser.docType].prop(languageData) || {});
    }
}
const CacheStepShift = 6, CacheStep = 1 << CacheStepShift;
const MaxRecomputeDistance = 20e3;
class SyntaxState {
    constructor(tree, 
    // Slot 0 stores the start state (line 1), slot 1 the
    // state at the start of line 65, etc, so lineNo ==
    // (index * CACHE_STEP) + 1
    cache, frontierLine, frontierPos, frontierState) {
        this.tree = tree;
        this.cache = cache;
        this.frontierLine = frontierLine;
        this.frontierPos = frontierPos;
        this.frontierState = frontierState;
        this.working = -1;
        this.updatedTree = tree;
    }
    copy() {
        return new SyntaxState(this.updatedTree, this.cache.slice(), this.frontierLine, this.frontierPos, this.frontierState);
    }
    cut(line, pos) {
        return new SyntaxState(this.updatedTree.cut(pos), this.cache.slice(0, (line >> CacheStepShift) + 1), line, pos, null);
    }
    maybeStoreState(parser, lineBefore, state) {
        if (lineBefore % CacheStep == 0)
            this.cache[(lineBefore - 1) >> CacheStepShift] = parser.copyState(state);
    }
    findState(parser, editorState, line) {
        let cacheIndex = Math.min(this.cache.length - 1, (line - 1) >> CacheStepShift);
        let cachedLine = (cacheIndex << CacheStepShift) + 1;
        let startPos = editorState.doc.line(cachedLine).start;
        if (line - cachedLine > CacheStep && editorState.doc.line(line).start - startPos > MaxRecomputeDistance)
            return null;
        let state = parser.copyState(this.cache[cacheIndex]);
        let cursor = new StringStreamCursor(editorState.doc, startPos, editorState.tabSize);
        for (let l = cachedLine; l < line; l++) {
            let stream = cursor.next();
            if (stream.eol()) {
                parser.blankLine(state, editorState);
            }
            else {
                while (!stream.eol())
                    parser.readToken(state, stream, editorState);
            }
            this.maybeStoreState(parser, l, state);
        }
        return state;
    }
    advanceFrontier(parser, editorState, timeout, upto = editorState.doc.length) {
        if (this.frontierPos >= editorState.doc.length)
            return;
        let sliceEnd = Date.now() + timeout;
        let state = this.frontierState || this.findState(parser, editorState, this.frontierLine);
        let cursor = new StringStreamCursor(editorState.doc, this.frontierPos, editorState.tabSize);
        let buffer = [];
        let line = this.frontierLine, pos = this.frontierPos;
        while (pos < upto) {
            let stream = cursor.next(), offset = cursor.offset;
            if (stream.eol()) {
                parser.blankLine(state, editorState);
            }
            else {
                while (!stream.eol()) {
                    let type = parser.readToken(state, stream, editorState);
                    if (type)
                        buffer.push(tokenID(type), offset + stream.start, offset + stream.pos, 4);
                }
            }
            this.maybeStoreState(parser, line, state);
            line++;
            pos += stream.string.length + 1;
            if (Date.now() > sliceEnd)
                break;
        }
        let tree = Tree.build({ buffer,
            group: nodeGroup,
            topID: parser.docType }).balance();
        this.updatedTree = this.updatedTree.append(tree).balance();
        this.frontierLine = line;
        this.frontierPos = pos;
        this.frontierState = state;
    }
    getIndent(parser, state, pos) {
        let line = state.doc.lineAt(pos);
        let parseState = this.findState(parser, state, line.number);
        if (parseState == null)
            return -1;
        let text = line.slice(pos - line.start, Math.min(line.end, pos + 100) - line.start);
        return parser.indent(parseState, /^\s*(.*)/.exec(text)[1], state);
    }
}
let requestIdle = typeof window != "undefined" && window.requestIdleCallback ||
    ((callback, { timeout }) => setTimeout(callback, timeout));
let cancelIdle = typeof window != "undefined" && window.cancelIdleCallback || clearTimeout;
class HighlightWorker {
    constructor(view, parser, field, setSyntax) {
        this.view = view;
        this.parser = parser;
        this.field = field;
        this.setSyntax = setSyntax;
        this.working = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        if (update.docChanged)
            this.scheduleWork();
    }
    scheduleWork() {
        if (this.working > -1)
            return;
        let { state } = this.view, field = state.field(this.field);
        if (field.frontierPos >= state.doc.length)
            return;
        this.working = requestIdle(this.work, { timeout: 200 /* Pause */ });
    }
    work(deadline) {
        this.working = -1;
        let { state } = this.view, field = state.field(this.field);
        if (field.frontierPos >= state.doc.length)
            return;
        // Advance to the end of the viewport, and no further, by default
        let end = this.view.viewport.to;
        field.advanceFrontier(this.parser, state, deadline ? Math.max(50 /* MinSlice */, deadline.timeRemaining()) : 100 /* Slice */, end);
        if (field.frontierPos < end)
            this.scheduleWork();
        else
            this.view.dispatch(state.t().annotate(this.setSyntax, field.copy()));
    }
    destroy() {
        if (this.working >= 0)
            cancelIdle(this.working);
    }
}
const tokenTable = Object.create(null);
const typeArray = [NodeType.none];
const nodeGroup = new NodeGroup(typeArray);
const warned = [];
function tokenID(tag) {
    let id = tokenTable[tag];
    if (id == null) {
        let tagID = 0;
        try {
            tagID = defaultTags.get(tag);
        }
        catch (e) {
            if (!(e instanceof RangeError))
                throw e;
            if (warned.indexOf(tag) < 0) {
                warned.push(tag);
                console.warn(`'${tag}' is not a valid style tag`);
            }
            return tokenID("");
        }
        id = tokenTable[tag] = typeArray.length;
        typeArray.push(new NodeType(tag ? tag.replace(/ /g, "_") : "_", defaultTags.prop.set({}, tagID), id));
    }
    return id;
}
function docID(props) {
    if (props.length == 0)
        return tokenID("");
    let obj = Object.create(null);
    for (let [prop, value] of props)
        prop.set(obj, value);
    let id = typeArray.length;
    typeArray.push(new NodeType("document", obj, id));
    return id;
}

export { StreamSyntax, StringStream };

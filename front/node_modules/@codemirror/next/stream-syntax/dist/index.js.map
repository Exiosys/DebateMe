{"version":3,"file":"index.js","sources":["../src/stringstream.ts","../src/stream-syntax.ts"],"sourcesContent":["import {Text, TextIterator} from \"../../text\"\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\n// FIXME more or less duplicated in indent/src/indent.ts\nfunction countColumn(string: string, end: number | null, tabSize: number, startIndex?: number, startValue?: number): number {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/)\n    if (end == -1) end = string.length\n  }\n  for (let i = startIndex || 0, n = startValue || 0;;) {\n    let nextTab = string.indexOf(\"\\t\", i)\n    if (nextTab < 0 || nextTab >= end)\n      return n + (end - i)\n    n += nextTab - i\n    n += tabSize - (n % tabSize)\n    i = nextTab + 1\n  }\n}\n\n// STRING STREAM\n\n/// Encapsulates a single line of input. Given to stream syntax code,\n/// which uses it to tokenize the content.\nexport class StringStream {\n  /// The current position on the line.\n  pos: number = 0\n  /// The start position of the current token.\n  start: number = 0\n  private lineStart: number = 0\n  private lastColumnPos: number = 0\n  private lastColumnValue: number = 0\n\n  /// @internal\n  constructor(\n    /// The line.\n    public string: string,\n    /// Current tab size.\n    public tabSize: number\n  ) {}\n\n  /// True if we are at the end of the line.\n  eol(): boolean {return this.pos >= this.string.length}\n  /// True if we are at the start of the line.\n  sol(): boolean {return this.pos == this.lineStart}\n  /// Get the next code unit after the current position, or undefined\n  /// if we're at the end of the line.\n  peek() {return this.string.charAt(this.pos) || undefined}\n  /// Read the next code unit and advance `this.pos`.\n  next(): string | void {\n    if (this.pos < this.string.length)\n      return this.string.charAt(this.pos++)\n  }\n  /// Match the next character against the given string, regular\n  /// expression, or predicate. Consume and return it if it matches.\n  eat(match: string | RegExp | ((ch: string) => boolean)): string | void {\n    let ch = this.string.charAt(this.pos)\n    let ok\n    if (typeof match == \"string\") ok = ch == match\n    else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch))\n    if (ok) {++this.pos; return ch}\n  }\n  /// Continue matching characters that match the given string,\n  /// regular expression, or predicate function. Return true if any\n  /// characters were consumed.\n  eatWhile(match: string | RegExp | ((ch: string) => boolean)): boolean {\n    let start = this.pos\n    while (this.eat(match)){}\n    return this.pos > start\n  }\n  /// Consume whitespace ahead of `this.pos`. Return true if any was\n  /// found.\n  eatSpace() {\n    let start = this.pos\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos\n    return this.pos > start\n  }\n  /// Move to the end of the line.\n  skipToEnd() {this.pos = this.string.length}\n  /// Move to directly before the given character, if found on the\n  /// current line.\n  skipTo(ch: string): boolean | void {\n    let found = this.string.indexOf(ch, this.pos)\n    if (found > -1) {this.pos = found; return true}\n  }\n  /// Move back `n` characters.\n  backUp(n: number) {this.pos -= n}\n  /// Get the column position at `this.pos`.\n  column() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)\n      this.lastColumnPos = this.start\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  }\n  /// Get the indentation column of the current line.\n  indentation() {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  }\n  /// Match the input against the given string or regular expression\n  /// (which should start with a `^`). Return true or the regexp match\n  /// if it matches.\n  ///\n  /// Unless `consume` is set to `false`, this will move `this.pos`\n  /// past the matched text.\n  ///\n  /// When matching a string `caseInsensitive` can be set to true to\n  /// make the match case-insensitive.\n  match(pattern: string | RegExp, consume?: boolean, caseInsensitive?: boolean): boolean | RegExpMatchArray | null {\n    if (typeof pattern == \"string\") {\n      let cased = (str: string) => caseInsensitive ? str.toLowerCase() : str\n      let substr = this.string.substr(this.pos, pattern.length)\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length\n        return true\n      } else return null\n    } else {\n      let match = this.string.slice(this.pos).match(pattern)\n      if (match && match.index! > 0) return null\n      if (match && consume !== false) this.pos += match[0].length\n      return match\n    }\n  }\n  /// Get the current token.\n  current(){return this.string.slice(this.start, this.pos)}\n  /// Hide the first `n` characters of the stream while running\n  /// `inner`. This can be useful for nesting modes.\n  hideFirstChars(n: number, inner: () => void) {\n    this.lineStart += n\n    try { return inner() }\n    finally { this.lineStart -= n }\n  }\n}\n\nexport class StringStreamCursor {\n  private curLineEnd: number\n  private readonly iter: TextIterator\n\n  constructor(text: Text, public offset: number, readonly tabSize: number = 4) {\n    this.iter = text.iterLines(offset)\n    this.curLineEnd = this.offset - 1\n  }\n\n  next() {\n    let {value, done} = this.iter.next()\n    if (done) throw new RangeError(\"Reached end of document\")\n    const res = new StringStream(value, this.tabSize)\n    this.offset = this.curLineEnd + 1\n    this.curLineEnd += value.length + 1\n    return res\n  }\n}\n","import {StringStream, StringStreamCursor} from \"./stringstream\"\nimport {EditorState, StateField, Syntax, languageData, Extension, Annotation} from \"../../state\"\nimport {EditorView, ViewPlugin, PluginValue, ViewUpdate} from \"../../view\"\nimport {Tree, NodeType, NodeProp, NodeGroup} from \"lezer-tree\"\nimport {defaultTags} from \"../../highlight\"\n\nexport {StringStream}\n\n/// A stream parser parses or tokenizes content from start to end,\n/// emitting tokens as it goes over it. It keeps a mutable (but\n/// copyable) object with state, in which it can store information\n/// about the current context.\nexport type StreamParser<State> = {\n  /// Read one token, advancing the stream past it, and returning a\n  /// string with the token's style. It is okay to return an empty\n  /// token, but only if that updates the state so that the next call\n  /// will return a token again.\n  token(stream: StringStream, state: State, editorState: EditorState): string | null\n  /// This notifies the parser of a blank line in the input. It can\n  /// update its state here if it needs to.\n  blankLine?(state: State, editorState: EditorState): void\n  /// Produce a start state for the parser.\n  startState?(editorState: EditorState): State\n  /// Copy a given state. By default, a shallow object copy is done\n  /// which also copies arrays held at the top level of the object.\n  copyState?(state: State): State\n  /// Compute automatic indentation for the line that starts with the\n  /// given state and text.\n  indent?(state: State, textAfter: string, editorState: EditorState): number\n  /// Syntax [node\n  /// props](https://lezer.codemirror.net/docs/ref#tree.NodeProp) to\n  /// be added to the wrapper node created around syntax 'trees'\n  /// created by this syntax.\n  docProps?: readonly [NodeProp<any>, any][]\n}\n\nclass StreamParserInstance<State> {\n  token: (stream: StringStream, state: State, editorState: EditorState) => string | null\n  blankLine: (state: State, editorState: EditorState) => void\n  // FIXME maybe support passing something from the parent when nesting\n  startState: (es: EditorState) => State\n  copyState: (state: State) => State\n  indent: (state: State, textAfter: string, editorState: EditorState) => number\n  docType: number\n\n  constructor(spec: StreamParser<State>) {\n    this.token = spec.token\n    this.blankLine = spec.blankLine || (() => {})\n    this.startState = spec.startState || (() => (true as any))\n    this.copyState = spec.copyState || defaultCopyState\n    this.indent = spec.indent || (() => -1)\n    this.docType = docID(spec.docProps || [])\n  }\n\n  readToken(state: State, stream: StringStream, editorState: EditorState) {\n    stream.start = stream.pos\n    for (let i = 0; i < 10; i++) {\n      let result = this.token(stream, state, editorState)\n      if (stream.pos > stream.start) return result\n    }\n    throw new Error(\"Stream parser failed to advance stream.\")\n  }\n}\n\nfunction defaultCopyState<State>(state: State) {\n  if (typeof state != \"object\") return state\n  let newState = {} as State\n  for (let prop in state) {\n    let val = state[prop]\n    newState[prop] = (val instanceof Array ? val.slice() : val) as any\n  }\n  return newState\n}\n\n/// A syntax provider that uses a stream parser.\nexport class StreamSyntax implements Syntax {\n  private field: StateField<SyntaxState<any>>\n  /// The extension that installs this syntax provider.\n  public extension: Extension\n  private parser: StreamParserInstance<any>\n\n  /// Create a stream syntax.\n  constructor(parser: StreamParser<any>) {\n    let parserInst = this.parser = new StreamParserInstance(parser)\n    let setSyntax = Annotation.define<SyntaxState<any>>()\n    this.field = StateField.define<SyntaxState<any>>({\n      create(state) {\n        let start = new SyntaxState(Tree.empty, [parserInst.startState(state)], 1, 0, null)\n        start.advanceFrontier(parserInst, state, Work.Apply)\n        start.tree = start.updatedTree\n        return start\n      },\n      update(value, tr, state) {\n        let set = tr.annotation(setSyntax)\n        if (set) return set\n        if (!tr.docChanged) return value\n        let {start, number} = tr.doc.lineAt(tr.changes.changedRanges()[0].fromA)\n        let newValue = number >= value.frontierLine ? value.copy() : value.cut(number, start)\n        newValue.advanceFrontier(parserInst, state, Work.Apply)\n        newValue.tree = newValue.updatedTree\n        return newValue\n      }\n    })\n    this.extension = [\n      EditorState.syntax.of(this),\n      ViewPlugin.define(view => new HighlightWorker(view, this.parser, this.field, setSyntax)),\n      this.field,\n      EditorState.indentation.of((state: EditorState, pos: number) => {\n        return state.field(this.field).getIndent(this.parser, state, pos)\n      })\n    ]\n  }\n\n  getTree(state: EditorState) {\n    return state.field(this.field).tree\n  }\n\n  parsePos(state: EditorState) {\n    return state.field(this.field).frontierPos\n  }\n\n  ensureTree(state: EditorState, upto: number, timeout = 100) {\n    let field = state.field(this.field)\n    if (field.frontierPos < upto)\n      field.advanceFrontier(this.parser, state, timeout, upto)\n    return field.frontierPos < upto ? null : field.updatedTree\n  }\n\n  get docNodeType() { return typeArray[this.parser.docType] }\n\n  languageDataAt<Interface = any>() {\n    return (typeArray[this.parser.docType].prop(languageData) || {}) as Interface\n  }\n}\n\nconst CacheStepShift = 6, CacheStep = 1 << CacheStepShift\n\nconst MaxRecomputeDistance = 20e3\n\nconst enum Work { Apply = 25, MinSlice = 50, Slice = 100, Pause = 200 }\n\nclass SyntaxState<ParseState> {\n  working = -1\n  updatedTree: Tree\n\n  constructor(public tree: Tree,\n              // Slot 0 stores the start state (line 1), slot 1 the\n              // state at the start of line 65, etc, so lineNo ==\n              // (index * CACHE_STEP) + 1\n              public cache: ParseState[],\n              public frontierLine: number,\n              public frontierPos: number,\n              public frontierState: ParseState | null) {\n    this.updatedTree = tree\n  }\n\n  copy() {\n    return new SyntaxState(this.updatedTree, this.cache.slice(), this.frontierLine, this.frontierPos, this.frontierState)\n  }\n\n  cut(line: number, pos: number) {\n    return new SyntaxState(this.updatedTree.cut(pos), this.cache.slice(0, (line >> CacheStepShift) + 1), line, pos, null)\n  }\n\n  maybeStoreState(parser: StreamParserInstance<ParseState>, lineBefore: number, state: ParseState) {\n    if (lineBefore % CacheStep == 0)\n      this.cache[(lineBefore - 1) >> CacheStepShift] = parser.copyState(state)\n  }\n\n  findState(parser: StreamParserInstance<ParseState>, editorState: EditorState, line: number) {\n    let cacheIndex = Math.min(this.cache.length - 1, (line - 1) >> CacheStepShift)\n    let cachedLine = (cacheIndex << CacheStepShift) + 1\n    let startPos = editorState.doc.line(cachedLine).start\n    if (line - cachedLine > CacheStep && editorState.doc.line(line).start - startPos > MaxRecomputeDistance)\n      return null\n    let state = parser.copyState(this.cache[cacheIndex])\n    let cursor = new StringStreamCursor(editorState.doc, startPos, editorState.tabSize)\n    for (let l = cachedLine; l < line; l++) {\n      let stream = cursor.next()\n      if (stream.eol()) {\n        parser.blankLine(state, editorState)\n      } else {\n        while (!stream.eol()) parser.readToken(state, stream, editorState)\n      }\n      this.maybeStoreState(parser, l, state)\n    }\n    return state\n  }\n\n  advanceFrontier(parser: StreamParserInstance<ParseState>, editorState: EditorState, timeout: number,\n                  upto: number = editorState.doc.length) {\n    if (this.frontierPos >= editorState.doc.length) return\n    let sliceEnd = Date.now() + timeout\n    let state = this.frontierState || this.findState(parser, editorState, this.frontierLine)!\n    let cursor = new StringStreamCursor(editorState.doc, this.frontierPos, editorState.tabSize)\n    let buffer: number[] = []\n    let line = this.frontierLine, pos = this.frontierPos\n    while (pos < upto) {\n      let stream = cursor.next(), offset = cursor.offset\n      if (stream.eol()) {\n        parser.blankLine(state, editorState)\n      } else {\n        while (!stream.eol()) {\n          let type = parser.readToken(state, stream, editorState)\n          if (type) buffer.push(tokenID(type), offset + stream.start, offset + stream.pos, 4)\n        }\n      }\n      this.maybeStoreState(parser, line, state)\n      line++\n      pos += stream.string.length + 1\n      if (Date.now() > sliceEnd) break\n    }\n    let tree = Tree.build({buffer,\n                           group: nodeGroup,\n                           topID: parser.docType}).balance()\n    this.updatedTree = this.updatedTree.append(tree).balance()\n    this.frontierLine = line\n    this.frontierPos = pos\n    this.frontierState = state\n  }\n\n  getIndent(parser: StreamParserInstance<ParseState>, state: EditorState, pos: number) {\n    let line = state.doc.lineAt(pos)\n    let parseState = this.findState(parser, state, line.number)\n    if (parseState == null) return -1\n    let text = line.slice(pos - line.start, Math.min(line.end, pos + 100) - line.start)\n    return parser.indent(parseState, /^\\s*(.*)/.exec(text)![1], state)\n  }\n}\n\ntype Deadline = {timeRemaining(): number, didTimeout: boolean}\ntype IdleCallback = (deadline?: Deadline) => void\n\nlet requestIdle: (callback: IdleCallback, options: {timeout: number}) => number =\n  typeof window != \"undefined\" && (window as any).requestIdleCallback ||\n  ((callback: IdleCallback, {timeout}: {timeout: number}) => setTimeout(callback, timeout))\nlet cancelIdle: (id: number) => void = typeof window != \"undefined\" && (window as any).cancelIdleCallback || clearTimeout\n\nclass HighlightWorker implements PluginValue {\n  working: number = -1\n\n  constructor(readonly view: EditorView,\n              readonly parser: StreamParserInstance<any>,\n              readonly field: StateField<SyntaxState<any>>,\n              readonly setSyntax: Annotation<SyntaxState<any>>) {\n    this.work = this.work.bind(this)\n    this.scheduleWork()\n  }\n\n  update(update: ViewUpdate) {\n    if (update.docChanged) this.scheduleWork()\n  }\n\n  scheduleWork() {\n    if (this.working > -1) return\n    let {state} = this.view, field = state.field(this.field)\n    if (field.frontierPos >= state.doc.length) return\n    this.working = requestIdle(this.work, {timeout: Work.Pause})\n  }\n\n  work(deadline?: Deadline) {\n    this.working = -1\n    let {state} = this.view, field = state.field(this.field)\n    if (field.frontierPos >= state.doc.length) return\n    // Advance to the end of the viewport, and no further, by default\n    let end = this.view.viewport.to\n    field.advanceFrontier(this.parser, state, deadline ? Math.max(Work.MinSlice, deadline.timeRemaining()) : Work.Slice, end)\n    if (field.frontierPos < end) this.scheduleWork()\n    else this.view.dispatch(state.t().annotate(this.setSyntax, field.copy()))\n  }\n\n  destroy() {\n    if (this.working >= 0) cancelIdle(this.working)\n  }\n}\n\nconst tokenTable: {[name: string]: number} = Object.create(null)\nconst typeArray: NodeType[] = [NodeType.none]\nconst nodeGroup = new NodeGroup(typeArray)\nconst warned: string[] = []\n\nfunction tokenID(tag: string): number {\n  let id = tokenTable[tag]\n  if (id == null) {\n    let tagID = 0\n    try {\n      tagID = defaultTags.get(tag)\n    } catch(e) {\n      if (!(e instanceof RangeError)) throw e\n      if (warned.indexOf(tag) < 0) {\n        warned.push(tag)\n        console.warn(`'${tag}' is not a valid style tag`)\n      }\n      return tokenID(\"\")\n    }\n    id = tokenTable[tag] = typeArray.length\n    typeArray.push(new NodeType(tag ? tag.replace(/ /g, \"_\") : \"_\", defaultTags.prop.set({}, tagID), id))\n  }\n  return id\n}\n\nfunction docID(props: readonly [NodeProp<any>, any][]) {\n  if (props.length == 0) return tokenID(\"\")\n  let obj = Object.create(null)\n  for (let [prop, value] of props) prop.set(obj, value)\n  let id = typeArray.length\n  typeArray.push(new NodeType(\"document\", obj, id))\n  return id\n}\n"],"names":["Annotation","StateField","Tree","EditorState","ViewPlugin","languageData","NodeType","NodeGroup","defaultTags"],"mappings":"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"}
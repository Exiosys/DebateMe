import { RangeValue, Range, RangeSet } from "../../rangeset";
import { WidgetView } from "./inlineview";
import { EditorView } from "./editorview";
export interface MarkDecorationSpec {
    inclusive?: boolean;
    inclusiveStart?: boolean;
    inclusiveEnd?: boolean;
    attributes?: {
        [key: string]: string;
    };
    class?: string;
    tagName?: string;
}
export interface WidgetDecorationSpec {
    widget: WidgetType;
    side?: number;
    block?: boolean;
}
export interface ReplaceDecorationSpec {
    widget?: WidgetType;
    inclusive?: boolean;
    inclusiveStart?: boolean;
    inclusiveEnd?: boolean;
    block?: boolean;
}
export interface LineDecorationSpec {
    attributes?: {
        [key: string]: string;
    };
}
export declare abstract class WidgetType<T = any> {
    readonly value: T;
    constructor(value: T);
    abstract toDOM(view: EditorView): HTMLElement;
    eq(value: T): boolean;
    updateDOM(_dom: HTMLElement): boolean;
    compare(other: WidgetType): boolean;
    get estimatedHeight(): number;
    ignoreEvent(_event: Event): boolean;
    get customView(): null | typeof WidgetView;
}
export declare type DecorationSet = RangeSet<Decoration>;
export declare enum BlockType {
    Text = 0,
    WidgetBefore = 1,
    WidgetAfter = 2,
    WidgetRange = 3
}
export declare abstract class Decoration extends RangeValue {
    readonly startSide: number;
    readonly endSide: number;
    readonly widget: WidgetType | null;
    readonly spec: any;
    constructor(startSide: number, endSide: number, widget: WidgetType | null, spec: any);
    get point(): boolean;
    get heightRelevant(): boolean;
    abstract eq(other: Decoration): boolean;
    static mark(spec: MarkDecorationSpec): Decoration;
    static widget(spec: WidgetDecorationSpec): Decoration;
    static replace(spec: ReplaceDecorationSpec): Decoration;
    static line(spec: LineDecorationSpec): Decoration;
    static set(of: Range<Decoration> | readonly Range<Decoration>[], sort?: boolean): DecorationSet;
    static none: DecorationSet;
    hasHeight(): boolean;
}
export declare class MarkDecoration extends Decoration {
    constructor(spec: MarkDecorationSpec);
    eq(other: Decoration): boolean;
    range(from: number, to?: number): Range<this>;
}
export declare class LineDecoration extends Decoration {
    constructor(spec: LineDecorationSpec);
    get point(): boolean;
    eq(other: Decoration): boolean;
    range(from: number, to?: number): Range<this>;
}
export declare class PointDecoration extends Decoration {
    block: boolean;
    readonly isReplace: boolean;
    constructor(spec: any, startSide: number, endSide: number, block: boolean, widget: WidgetType | null, isReplace: boolean);
    get point(): boolean;
    get type(): BlockType.WidgetBefore | BlockType.WidgetAfter | BlockType.WidgetRange;
    get heightRelevant(): boolean;
    eq(other: Decoration): boolean;
    range(from: number, to?: number): Range<this>;
}
export declare function addRange(from: number, to: number, ranges: number[]): void;
export declare function joinRanges(a: number[], b: number[]): number[];
//# sourceMappingURL=decoration.d.ts.map
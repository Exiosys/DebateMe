'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lezerHtml = require('lezer-html');
var langCss = require('../../lang-css');
var langJavascript = require('../../lang-javascript');
var syntax = require('../../syntax');
var highlight = require('../../highlight');

/// A syntax provider based on the [Lezer HTML
/// parser](https://github.com/lezer-parser/html), wired up with the
/// JavaScript and CSS parsers to parse the content of `<script>` and
/// `<style>` tags.
const htmlSyntax = new syntax.LezerSyntax(lezerHtml.configureHTML([
    { tag: "script",
        attrs(attrs) {
            return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: langJavascript.javascriptSyntax.parser },
    { tag: "style",
        attrs(attrs) {
            return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: langCss.cssSyntax.parser }
]).withProps(syntax.indentNodeProp.add(type => {
    if (type.name == "Element")
        return syntax.delimitedIndent({ closing: "</", align: false });
    if (type.name == "OpenTag" || type.name == "CloseTag" || type.name == "SelfClosingTag")
        return syntax.continuedIndent();
    return undefined;
}), syntax.foldNodeProp.add({
    Element(subtree) {
        let first = subtree.firstChild, last = subtree.lastChild;
        if (!first || first.name != "OpenTag")
            return null;
        return { from: first.end, to: last.name == "CloseTag" ? last.start : subtree.end };
    }
}), syntax.openNodeProp.add({
    "StartTag StartCloseTag": ["EndTag", "SelfCloseEndTag"],
    "OpenTag": ["CloseTag"]
}), syntax.closeNodeProp.add({
    "EndTag SelfCloseEndTag": ["StartTag", "StartCloseTag"],
    "CloseTag": ["OpenTag"]
}), highlight.styleTags({
    AttributeValue: "string",
    "Text RawText": "content",
    "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": "angleBracket",
    TagName: "typeName",
    MismatchedTagName: "typeName invalid",
    AttributeName: "propertyName",
    UnquotedAttributeValue: "string",
    Is: "operator definition",
    "EntityReference CharacterReference": "character",
    Comment: "blockComment",
    ProcessingInst: "operator meta",
    DoctypeDecl: "labelName meta"
})));
/// Returns an extension that installs the HTML syntax provider.
function html() { return htmlSyntax.extension; }

exports.html = html;
exports.htmlSyntax = htmlSyntax;

import { ViewPlugin, themeClass, EditorView } from '../../view';
import { Facet, Annotation, StateField } from '../../state';

const HoverTime = 750, HoverMaxDist = 10;
const tooltipPlugin = ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        view.scrollDOM.addEventListener("scroll", this.onscroll = this.onscroll.bind(this));
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.sources = view.state.facet(showTooltip);
        this.tooltips = this.sources.map(s => this.createTooltip(s));
    }
    update(update) {
        let sources = update.state.facet(showTooltip);
        if (sources == this.sources) {
            for (let t of this.tooltips)
                if (t.update)
                    t.update(update);
        }
        else {
            let tooltips = [];
            for (let i = 0; i < sources.length; i++) {
                let source = sources[i], known = this.sources.indexOf(source);
                if (known < 0) {
                    tooltips[i] = this.createTooltip(source);
                }
                else {
                    let tooltip = tooltips[i] = this.tooltips[known];
                    if (tooltip.update)
                        tooltip.update(update);
                }
            }
            for (let t of this.tooltips)
                if (tooltips.indexOf(t) < 0)
                    t.dom.remove();
            this.sources = sources;
            this.tooltips = tooltips;
            if (this.tooltips.length)
                this.view.requestMeasure(this.measureReq);
        }
        if (update.docChanged && this.tooltips.length)
            this.view.requestMeasure(this.measureReq);
    }
    createTooltip(source) {
        let tooltip = source(this.view);
        tooltip.dom.className = themeClass("tooltip" + (tooltip.style ? "." + tooltip.style : ""));
        this.view.dom.appendChild(tooltip.dom);
        if (tooltip.mount)
            tooltip.mount(this.view);
        return tooltip;
    }
    destroy() {
        this.view.scrollDOM.removeEventListener("scroll", this.onscroll);
        for (let { dom } of this.tooltips)
            dom.remove();
    }
    readMeasure() {
        return {
            editor: this.view.dom.getBoundingClientRect(),
            pos: this.tooltips.map(tooltip => this.view.coordsAtPos(tooltip.pos)),
            size: this.tooltips.map(({ dom }) => dom.getBoundingClientRect()),
            innerWidth: window.innerWidth,
            innerHeight: window.innerHeight
        };
    }
    writeMeasure(measured) {
        let { editor } = measured;
        for (let i = 0; i < this.tooltips.length; i++) {
            let tooltip = this.tooltips[i], pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {
                tooltip.dom.style.top = "-10000px";
                continue;
            }
            let width = size.right - size.left, height = size.bottom - size.top;
            let align = pos.left + width < measured.innerWidth;
            let above = !!tooltip.above;
            if (!tooltip.strictSide &&
                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))
                above = !above;
            tooltip.dom.style.left = ((align ? pos.left : measured.innerWidth - width) - editor.left) + "px";
            tooltip.dom.style.top = ((above ? pos.top - height : pos.bottom) - editor.top) + "px";
        }
    }
    onscroll() {
        if (this.tooltips.length)
            this.view.requestMeasure(this.measureReq);
    }
});
const baseTheme = EditorView.baseTheme({
    tooltip: {
        position: "absolute",
        border: "1px solid silver",
        background: "#f5f5f5",
        zIndex: 100
    }
});
/// Supporting extension for displaying tooltips. Allows
/// [`showTooltip`](#tooltip.showTooltip) to be used to define
/// tooltips.
function tooltips() {
    return [tooltipPlugin, baseTheme];
}
/// Behavior by which an extension can provide a tooltip to be shown.
const showTooltip = Facet.define();
class HoverPlugin {
    constructor(view, source, field, setHover) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.lastMouseMove = null;
        this.hoverTimeout = -1;
        this.mouseInside = false;
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseenter", this.mouseenter = this.mouseenter.bind(this));
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    get active() { return this.view.state.field(this.field); }
    checkHover() {
        this.hoverTimeout = -1;
        if (!this.mouseInside || this.active)
            return;
        let now = Date.now(), lastMove = this.lastMouseMove;
        if (now - lastMove.timeStamp < HoverTime) {
            this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));
            return;
        }
        let pos = this.view.contentDOM.contains(lastMove.target)
            ? this.view.posAtCoords({ x: lastMove.clientX, y: lastMove.clientY }) : -1;
        let open = pos < 0 ? null : this.source(this.view, (from, to) => {
            return from <= pos && to >= pos && (from == to || isOverRange(this.view, from, to, lastMove.clientX, lastMove.clientY));
        });
        if (open)
            this.view.dispatch(this.view.state.t().annotate(this.setHover, open));
    }
    mousemove(event) {
        this.lastMouseMove = event;
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, HoverTime);
        let active = this.active;
        if (active && !isInTooltip(event.target) &&
            (active.start == active.end
                ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != active.start
                : !isOverRange(this.view, active.start, active.end, event.clientX, event.clientY, HoverMaxDist)))
            this.view.dispatch(this.view.state.t().annotate(this.setHover, null));
    }
    mouseenter() {
        this.mouseInside = true;
    }
    mouseleave() {
        this.mouseInside = false;
        if (this.active)
            this.view.dispatch(this.view.state.t().annotate(this.setHover, null));
    }
    destroy() {
        this.view.dom.removeEventListener("mouseenter", this.mouseenter.bind(this));
        this.view.dom.removeEventListener("mouseleave", this.mouseleave.bind(this));
        this.view.dom.removeEventListener("mousemove", this.mousemove.bind(this));
    }
}
function isInTooltip(elt) {
    for (let cur = elt; cur; cur = cur.parentNode)
        if (cur.nodeType == 1 && cur.classList.contains("cm-tooltip"))
            return true;
    return false;
}
function isOverRange(view, from, to, x, y, margin = 0) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
        if (dist <= margin)
            return true;
    }
    return false;
}
/// Enable a hover tooltip, which shows up when the pointer hovers
/// over ranges of text. The callback should, for each hoverable
/// range, call its `check` argument to see if that range is being
/// hovered over, and return a tooltip description when it is.
function hoverTooltip(source, options = {}) {
    const setHover = Annotation.define();
    const hoverState = StateField.define({
        create() { return null; },
        update(value, tr) {
            if (value && options.hideOnChange && (tr.docChanged || tr.selectionSet))
                return null;
            let set = tr.annotation(setHover);
            return set === undefined ? value : set;
        }
    }).provideN(showTooltip, v => v ? [v.tooltip] : []);
    return [
        hoverState,
        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover)),
        tooltips()
    ];
}

export { hoverTooltip, showTooltip, tooltips };

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var w3cKeyname = require('w3c-keyname');
var view = require('../../view');

const mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
function normalizeKeyName(name) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (mac)
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
/// Create a view extension that registers a keymap.
///
/// You can add multiple keymap behaviors to an editor. Their
/// priorities determine their precedence (the ones specified early or
/// with high priority get to dispatch first). When a handler has
/// returned `true` for a given key, no further handlers are called.
const keymap = (map) => {
    let set = new NormalizedKeymap(map);
    return view.EditorView.domEventHandlers.of({
        keydown(view, event) {
            let handler = set.get(event);
            return handler ? handler(view) : false;
        }
    });
};
/// Stores a set of keybindings in normalized form, and helps looking
/// up the binding for a keyboard event. Only needed when binding keys
/// in some custom way.
class NormalizedKeymap {
    /// Create a normalized map.
    constructor(map) {
        this.map = Object.create(null);
        for (const prop in map)
            this.map[normalizeKeyName(prop)] = map[prop];
    }
    /// Look up the binding for the given keyboard event, or `undefined`
    /// if none is found.
    get(event) {
        const name = w3cKeyname.keyName(event), isChar = name.length == 1 && name != " ";
        const direct = this.map[modifiers(name, event, !isChar)];
        if (direct)
            return direct;
        let baseName;
        if (isChar && (event.shiftKey || event.altKey || event.metaKey) &&
            (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
            const fromCode = this.map[modifiers(baseName, event, true)];
            if (fromCode)
                return fromCode;
        }
        return undefined;
    }
}

exports.NormalizedKeymap = NormalizedKeymap;
exports.keymap = keymap;

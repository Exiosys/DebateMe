'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('../../state');
var view = require('../../view');
var gutter = require('../../gutter');

const foldAnnotation = state.Annotation.define();
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.lineAt(head));
    }
    return lines;
}
const foldState = state.StateField.define({
    create() {
        return view.Decoration.none;
    },
    update(folded, tr) {
        folded = folded.map(tr.changes);
        let ann = tr.annotation(foldAnnotation);
        if (ann) {
            let { fold = [], unfold = [] } = ann;
            if (unfold.length || fold.length)
                folded = folded.update({
                    add: fold.map(({ from, to }) => FoldWidget.decoration.range(from, to)),
                    filter: (from, to) => !unfold.some(r => r.from == from && r.to == to),
                    filterFrom: unfold.reduce((m, r) => Math.min(m, r.from), 1e8),
                    filterTo: unfold.reduce((m, r) => Math.max(m, r.to), 0)
                });
        }
        return folded;
    }
}).provide(view.EditorView.decorations);
function foldInside(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = ({ from, to });
    });
    return found;
}
const foldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let fold = [];
    for (let line of selectedLines(view)) {
        let range = view.state.facet(state.EditorState.foldable)
            .reduce((value, f) => value || f(view.state, line.from, line.to), null);
        if (range)
            fold.push(range);
    }
    if (!fold.length)
        return false;
    view.dispatch(view.state.t().annotate(foldAnnotation, { fold }));
    return true;
};
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let unfold = [];
    for (let line of selectedLines(view)) {
        let folded = foldInside(view.state, line.from, line.to);
        if (folded)
            unfold.push(folded);
    }
    if (!unfold.length)
        return false;
    view.dispatch(view.state.t().annotate(foldAnnotation, { unfold }));
    return true;
};
const defaultConfig = {
    placeholderDOM: null,
    placeholderText: "…"
};
const foldConfig = state.Facet.define({
    combine(values) { return state.combineConfig(values, defaultConfig); }
});
function codeFolding(config = {}) {
    return [
        foldConfig.of(config),
        foldState,
        baseTheme
    ];
}
class FoldWidget extends view.WidgetType {
    ignoreEvents() { return false; }
    toDOM(view$1) {
        let conf = view$1.state.facet(foldConfig);
        if (conf.placeholderDOM)
            return conf.placeholderDOM();
        let element = document.createElement("span");
        element.textContent = conf.placeholderText;
        // FIXME should this have a role? does it make sense to allow focusing by keyboard?
        element.setAttribute("aria-label", view$1.phrase("folded code"));
        element.title = view$1.phrase("unfold");
        element.className = view.themeClass("foldPlaceholder");
        element.onclick = event => {
            let line = view$1.lineAt(view$1.posAtDOM(event.target));
            let folded = foldInside(view$1.state, line.from, line.to);
            if (folded)
                view$1.dispatch(view$1.state.t().annotate(foldAnnotation, { unfold: [folded] }));
            event.preventDefault();
        };
        return element;
    }
}
FoldWidget.decoration = view.Decoration.replace({ widget: new FoldWidget(null) });
const foldGutterDefaults = {
    openText: "⌄",
    closedText: "›"
};
class FoldMarker extends gutter.GutterMarker {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
function foldGutter(config = {}) {
    let fullConfig = state.fillConfig(config, foldGutterDefaults);
    return [
        gutter.gutter({
            style: "foldGutter",
            lineMarker(view, line) {
                // FIXME optimize this. At least don't run it for updates that
                // don't change anything relevant
                let folded = foldInside(view.state, line.from, line.to);
                if (folded)
                    return new FoldMarker(fullConfig, false);
                if (view.state.facet(state.EditorState.foldable).some(f => f(view.state, line.from, line.to)))
                    return new FoldMarker(fullConfig, true);
                return null;
            },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: {
                click: (view, line) => {
                    let folded = foldInside(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch(view.state.t().annotate(foldAnnotation, { unfold: [folded] }));
                        return true;
                    }
                    let range = view.state.facet(state.EditorState.foldable)
                        .reduce((value, f) => value || f(view.state, line.from, line.to), null);
                    if (range) {
                        view.dispatch(view.state.t().annotate(foldAnnotation, { fold: [range] }));
                        return true;
                    }
                    return false;
                }
            }
        }),
        codeFolding()
    ];
}
const baseTheme = view.EditorView.baseTheme({
    foldPlaceholder: {
        background: "#eee",
        border: "1px solid silver",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    "gutterElement.foldGutter": {
        padding: "0 1px",
        cursor: "pointer"
    }
});

exports.codeFolding = codeFolding;
exports.foldCode = foldCode;
exports.foldGutter = foldGutter;
exports.unfoldCode = unfoldCode;

import { ChangeSet, ChangedRange, MapMode } from "../../state";
export declare abstract class RangeValue {
    eq(other: RangeValue): boolean;
    startSide: number;
    endSide: number;
    startMapMode: MapMode;
    endMapMode: MapMode;
    point: boolean;
    range(from: number, to?: number): Range<this>;
}
export declare class Range<T extends RangeValue> {
    readonly from: number;
    readonly to: number;
    readonly value: T;
    constructor(from: number, to: number, value: T);
}
export interface RangeComparator<T extends RangeValue> {
    compareRange(from: number, to: number, activeA: T[], activeB: T[]): void;
    comparePoint(from: number, to: number, byA: T | null, byB: T | null): void;
    minPointSize?: number;
}
export interface SpanIterator<T extends RangeValue> {
    span(from: number, to: number, active: readonly T[]): void;
    point(from: number, to: number, value: T, openStart: boolean, openEnd: boolean): void;
    minPointSize?: number;
}
declare class Chunk<T extends RangeValue> {
    readonly from: readonly number[];
    readonly to: readonly number[];
    readonly value: readonly T[];
    readonly maxPoint: number;
    constructor(from: readonly number[], to: readonly number[], value: readonly T[], maxPoint: number);
    get length(): number;
    findIndex(pos: number, end: -1 | 1, side?: number, startAt?: number): number;
    between(offset: number, from: number, to: number, f: (from: number, to: number, value: T) => void | false): void | false;
    map(offset: number, changes: ChangeSet): {
        mapped: Chunk<T> | null;
        pos: number;
    };
}
export declare type RangeCursor<T> = {
    next: () => void;
    value: T | null;
    from: number;
    to: number;
};
export declare type RangeSetUpdate<T extends RangeValue> = {
    add?: readonly Range<T>[];
    sort?: boolean;
    filter?: (from: number, to: number, value: T) => boolean;
    filterFrom?: number;
    filterTo?: number;
};
export declare class RangeSet<T extends RangeValue> {
    readonly chunkPos: readonly number[];
    readonly chunk: readonly Chunk<T>[];
    readonly nextLayer: RangeSet<T>;
    readonly maxPoint: number;
    constructor(chunkPos: readonly number[], chunk: readonly Chunk<T>[], nextLayer: RangeSet<T>, maxPoint: number);
    get length(): number;
    get size(): number;
    chunkEnd(index: number): number;
    update({ add, sort, filter, filterFrom, filterTo }: RangeSetUpdate<T>): RangeSet<T>;
    map(changes: ChangeSet): RangeSet<T>;
    between(from: number, to: number, f: (from: number, to: number, value: T) => void | false): void;
    iter(from?: number): RangeCursor<T>;
    static compare<T extends RangeValue>(oldSets: readonly RangeSet<T>[], newSets: readonly RangeSet<T>[], textDiff: readonly ChangedRange[], length: number, comparator: RangeComparator<T>): void;
    static spans<T extends RangeValue>(sets: readonly RangeSet<T>[], from: number, to: number, iterator: SpanIterator<T>): void;
    static of<T extends RangeValue>(ranges: readonly Range<T>[] | Range<T>, sort?: boolean): RangeSet<T>;
    static empty: RangeSet<any>;
}
export declare class RangeSetBuilder<T extends RangeValue> {
    private chunks;
    private chunkPos;
    private chunkStart;
    private last;
    private lastFrom;
    private lastTo;
    private from;
    private to;
    private value;
    private maxPoint;
    private setMaxPoint;
    private nextLayer;
    private finishChunk;
    add(from: number, to: number, value: T): void;
    addInner(from: number, to: number, value: T): boolean;
    addChunk(from: number, chunk: Chunk<T>): boolean;
    finish(): RangeSet<T>;
    finishInner(next: RangeSet<T>): RangeSet<T>;
}
export {};
//# sourceMappingURL=rangeset.d.ts.map
{"version":3,"file":"index.js","sources":["../src/rangeset.ts"],"sourcesContent":["import {ChangeSet, ChangedRange, MapMode} from \"../../state\"\n\n/// Each range is associated with a value, which must inherit from\n/// this class.\nexport abstract class RangeValue {\n  /// Compare this value with another value. The default\n  /// implementation compares by identity.\n  eq(other: RangeValue) { return this == other }\n  /// The bias value at the start of the range. Determines how the\n  /// range is positioned relative to other ranges starting at this\n  /// position. Defaults to 0.\n  startSide!: number\n  /// The bias value at the end of the range. Defaults to 0.\n  endSide!: number\n\n  /// The mode with which the start point of the range should be\n  /// mapped. Determines when a side is counted as deleted. Defaults\n  /// to `MapMode.TrackDel`.\n  startMapMode!: MapMode\n  /// The mode with which the end point of the range should be mapped.\n  endMapMode!: MapMode\n  /// Whether this value marks a point range, which shadows the ranges\n  /// contained in it.\n  point!: boolean\n\n  /// Create a [range](#rangeset.Range) with this value.\n  range(from: number, to = from) { return new Range(from, to, this) }\n}\n\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0\nRangeValue.prototype.point = false\nRangeValue.prototype.startMapMode = RangeValue.prototype.endMapMode = MapMode.TrackDel\n\n/// A range associates a value with a range of positions.\nexport class Range<T extends RangeValue> {\n  /// @internal\n  constructor(\n    /// The range's start position.\n    readonly from: number,\n    /// Its end position.\n    readonly to: number,\n    /// The value associated with this range.\n    readonly value: T) {}\n}\n\nfunction cmpRange<T extends RangeValue>(a: Range<T>, b: Range<T>) {\n  return a.from - b.from || a.value.startSide - b.value.startSide\n}\n\n/// Collection of methods used when comparing range sets.\nexport interface RangeComparator<T extends RangeValue> {\n  /// Notifies the comparator that the given range has the given set\n  /// of values associated with it.\n  compareRange(from: number, to: number, activeA: T[], activeB: T[]): void\n  /// Notification for a point range.\n  comparePoint(from: number, to: number, byA: T | null, byB: T | null): void\n  /// Can be used to ignore all non-point ranges and points below a\n  /// given size. Specify 0 to get all points.\n  minPointSize?: number\n}\n\n/// Methods used when iterating over the spans created by a set of\n/// ranges. The entire iterated range will be covered with either\n/// `span` or `point` calls.\nexport interface SpanIterator<T extends RangeValue> {\n  /// Called for any ranges not covered by point decorations. `active`\n  /// holds the values that the range is marked with (and may be\n  /// empty).\n  span(from: number, to: number, active: readonly T[]): void\n  /// Called when going over a point decoration. `openStart` and\n  /// `openEnd` indicate whether the point decoration exceeded the\n  /// range we're iterating over at its start and end.\n  point(from: number, to: number, value: T, openStart: boolean, openEnd: boolean): void\n  /// When given and greater than -1, only points of at least this\n  /// size are taken into account.\n  minPointSize?: number\n}\n\n      // The maximum amount of ranges to store in a single chunk\nconst ChunkSize = 250,\n      // Chunks with points of this size are never skipped during\n      // compare, since moving past those points is likely to speed\n      // up, rather than slow down, the comparison.\n      BigPointSize = 500,\n      // A large (fixnum) value to use for max/min values.\n      Far = 1e9\n\nclass Chunk<T extends RangeValue> {\n  constructor(readonly from: readonly number[],\n              readonly to: readonly number[],\n              readonly value: readonly T[],\n              // Chunks are marked with the largest point that occurs\n              // in them (or -1 for no points), so that scans that are\n              // only interested in points (such as the\n              // heightmap-related logic) can skip range-only chunks.\n              readonly maxPoint: number) {}\n\n  get length() { return this.to[this.to.length - 1] }\n\n  // With side == -1, return the first index where to >= pos. When\n  // side == 1, the first index where from > pos.\n  findIndex(pos: number, end: -1 | 1, side = end * Far, startAt = 0) {\n    if (pos <= 0) return startAt\n    let arr = end < 0 ? this.to : this.from\n    for (let lo = startAt, hi = arr.length;;) {\n      if (lo == hi) return lo\n      let mid = (lo + hi) >> 1\n      let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side\n      if (mid == lo) return diff >= 0 ? lo : hi\n      if (diff >= 0) hi = mid\n      else lo = mid + 1\n    }\n  }\n\n  between(offset: number, from: number, to: number, f: (from: number, to: number, value: T) => void | false): void | false {\n    for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n      if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false\n  }\n\n  map(offset: number, changes: ChangeSet) {\n    let value: T[] = [], from = [], to = [], newPos = -1, maxPoint = -1\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i]\n      let newFrom = changes.mapPos(this.from[i] + offset, val.startSide, val.startMapMode)\n      let newTo = changes.mapPos(this.to[i] + offset, val.endSide, val.endMapMode)\n      if (newTo < 0) {\n        if (newFrom < 0) continue\n        newTo = -(newTo + 1)\n      }\n      if (newFrom < 0) newFrom = -(newFrom + 1)\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue\n      if (newPos < 0) newPos = newFrom\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom)\n      value.push(val)\n      from.push(newFrom - newPos)\n      to.push(newTo - newPos)\n    }\n    return {mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos}\n  }\n}\n\n/// A range cursor is an object that moves to the next range every\n/// time you call `next` on it. Note that, unlike ES6 iterators, these\n/// start out pointing at the first element, so you should call `next`\n/// only after reading the first range (if any).\nexport type RangeCursor<T> = {\n  /// Move the iterator forward.\n  next: () => void\n  /// The next range's value. Holds `null` when the cursor has reached\n  /// its end.\n  value: T | null\n  /// The next range's start position.\n  from: number\n  /// The next end position.\n  to: number\n}\n\n/// Arguments passed to [`RangeSet.update`](#rangeset.RangeSet.update).\nexport type RangeSetUpdate<T extends RangeValue> = {\n  /// An array of ranges to add. If given, this should be sorted by\n  /// `from` position and `startSide` unless\n  /// [`sort`](#rangeset.RangeSetUpdate.sort) is given as `true`.\n  add?: readonly Range<T>[]\n  /// Indicates whether the library should sort the ranges in `add`.\n  sort?: boolean\n  /// Filter the ranges already in the set. Only those for which this\n  /// function returns `true` are kept.\n  filter?: (from: number, to: number, value: T) => boolean,\n  filterFrom?: number\n  /// These can be used to limit the range on which the filter is\n  /// applied. Filtering only a small range, as opposed to the entire\n  /// set, can make updates cheaper.\n  filterTo?: number\n}\n\n/// A range set stores a collection of [ranges](#rangeset.Range) in a\n/// way that makes them efficient to [map](#rangeset.RangeSet.map) and\n/// [update](#rangeset.RangeSet.update). This is an immutable data\n/// structure.\nexport class RangeSet<T extends RangeValue> {\n  /// @internal\n  constructor(\n    /// @internal\n    readonly chunkPos: readonly number[],\n    /// @internal\n    readonly chunk: readonly Chunk<T>[],\n    /// @internal\n    readonly nextLayer: RangeSet<T> = RangeSet.empty,\n    /// @internal\n    readonly maxPoint: number\n  ) {}\n\n  /// @internal\n  get length(): number {\n    let last = this.chunk.length - 1\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length)\n  }\n\n  /// @internal\n  get size(): number {\n    if (this == RangeSet.empty) return 0\n    let size = this.nextLayer.size\n    for (let chunk of this.chunk) size += chunk.value.length\n    return size\n  }\n\n  /// @internal\n  chunkEnd(index: number) {\n    return this.chunkPos[index] + this.chunk[index].length\n  }\n\n  /// Update the range set, optionally adding new ranges or filtering\n  /// out existing ones.\n  update({add = [], sort = false, filter, filterFrom = 0, filterTo = this.length}: RangeSetUpdate<T>): RangeSet<T> {\n    if (add.length == 0 && !filter) return this\n    if (sort) add.slice().sort(cmpRange)\n    if (this == RangeSet.empty) return add.length ? RangeSet.of(add) : this\n\n    let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = []\n    let builder = new RangeSetBuilder<T>()\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++]\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range)\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                 (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                 (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                 builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk()\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value!)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value!))\n            spill.push(new Range(cur.from, cur.to, cur.value!))\n        }\n        cur.next()\n      }\n    }\n\n    return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n                               : this.nextLayer.update({add: spill, filter, filterFrom, filterTo}))\n  }\n\n  /// Map this range set through a set of changes, return the new set.\n  map(changes: ChangeSet): RangeSet<T> {\n    if (changes.length == 0 || this == RangeSet.empty) return this\n\n    let chunks = [], chunkPos = [], maxPoint = -1\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i], chunk = this.chunk[i]\n      let touch = changes.touchesRange(start, start + chunk.length)\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint)\n        chunks.push(chunk)\n        chunkPos.push(changes.mapPos(start))\n      } else if (touch === true) {\n        let {mapped, pos} = chunk.map(start, changes)\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint)\n          chunks.push(mapped)\n          chunkPos.push(pos)\n        }\n      }\n    }\n    let next = this.nextLayer.map(changes)\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint)\n  }\n\n  /// Iterate over the ranges that touch the region `from` to `to`,\n  /// calling `f` for each. There is no guarantee that the ranges will\n  /// be reported in any order. When the callback returns `false`,\n  /// iteration stops.\n  between(from: number, to: number, f: (from: number, to: number, value: T) => void | false): void {\n    if (this == RangeSet.empty) return\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i], chunk = this.chunk[i]\n      if (to >= start && from <= start + chunk.length &&\n          chunk.between(start, from - start, to - start, f) === false) return\n    }\n    this.nextLayer.between(from, to, f)\n  }\n\n  /// Iterate over the ranges in the set that touch the area between\n  /// from and to, ordered by their start position and side.\n  iter(from: number = 0): RangeCursor<T> {\n    return HeapCursor.from([this]).goto(from)\n  }\n\n  /// Iterate over two groups of sets, calling methods on `comparator`\n  /// to notify it of possible differences. `textDiff` indicates how\n  /// the underlying data changed between these ranges, and is needed\n  /// to synchronize the iteration. `from` and `to` are coordinates in\n  /// the _new_ space, after these changes.\n  static compare<T extends RangeValue>(\n    oldSets: readonly RangeSet<T>[], newSets: readonly RangeSet<T>[],\n    textDiff: readonly ChangedRange[],\n    length: number,\n    comparator: RangeComparator<T>\n  ) {\n    let minPoint = comparator.minPointSize ?? -1\n    let a = oldSets.filter(set => set.maxPoint >= BigPointSize ||\n                           set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPoint)\n    let b = newSets.filter(set => set.maxPoint >= BigPointSize ||\n                           set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPoint)\n    let sharedChunks = findSharedChunks(a, b)\n    let sideA = new SpanCursor(a, sharedChunks, minPoint)\n    let sideB = new SpanCursor(b, sharedChunks, minPoint)\n\n    let posA = 0, posB = 0\n    for (let range of textDiff) {\n      compare(sideA, posA, sideB, posB, range.fromB - posB, comparator)\n      posA = range.toA\n      posB = range.toB\n    }\n    compare(sideA, posA, sideB, posB, length - posB, comparator)\n  }\n\n  /// Iterate over a group of range sets at the same time, notifying\n  /// the iterator about the ranges covering every given piece of\n  /// content.\n  static spans<T extends RangeValue>(sets: readonly RangeSet<T>[], from: number, to: number,\n                                     iterator: SpanIterator<T>) {\n    let cursor = new SpanCursor(sets, null, iterator.minPointSize ?? -1).goto(from), pos = from\n    for (;;) {\n      let curTo = Math.min(cursor.to, to)\n      if (cursor.point) iterator.point(pos, curTo, cursor.point, cursor.pointFrom < from, cursor.to > to)\n      else if (curTo > pos) iterator.span(pos, curTo, cursor.active)\n      if (cursor.to > to) break\n      pos = cursor.to\n      cursor.next()\n    }\n  }\n\n  /// Create a range set for the given range or array of ranges. By\n  /// default, this expects the ranges to be _sorted_ (by start\n  /// position and, if two start at the same position,\n  /// `value.startSide`). You can pass `true` as second argument to\n  /// cause the method to sort them.\n  static of<T extends RangeValue>(ranges: readonly Range<T>[] | Range<T>, sort = false): RangeSet<T> {\n    let build = new RangeSetBuilder<T>()\n    for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n      build.add(range.from, range.to, range.value)\n    return build.finish()\n  }\n\n  /// The empty set of ranges.\n  static empty = new RangeSet<any>([], [], null as any, -1)\n}\n\n// Awkward patch-up to create a cyclic structure.\n;(RangeSet.empty as any).nextLayer = RangeSet.empty\n\n/// A range set builder is a data structure that helps build up a\n/// [range set](#rangeset.RangeSet) directly, without first allocating\n/// an array of [`Range`](#rangeset.Range) objects.\nexport class RangeSetBuilder<T extends RangeValue> {\n  private chunks: Chunk<T>[] = []\n  private chunkPos: number[] = []\n  private chunkStart = -1\n  private last: T | null = null\n  private lastFrom = -Far\n  private lastTo = -Far\n  private from: number[] = []\n  private to: number[] = []\n  private value: T[] = []\n  private maxPoint = -1\n  private setMaxPoint = -1\n  private nextLayer: RangeSetBuilder<T> | null = null\n\n  private finishChunk(newArrays: boolean) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint))\n    this.chunkPos.push(this.chunkStart)\n    this.chunkStart = -1\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint)\n    this.maxPoint = -1\n    if (newArrays) { this.from = []; this.to = []; this.value = [] }\n  }\n\n  /// Add a range. Ranges should be added in sorted (by `from` and\n  /// `value.startSide`) order.\n  add(from: number, to: number, value: T) {\n    if (!this.addInner(from, to, value))\n      (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value)\n  }\n\n  /// @internal\n  addInner(from: number, to: number, value: T) {\n    let diff = from - this.lastTo || value.startSide - this.last!.endSide\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last!.startSide) < 0)\n      throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\")\n    if (diff < 0) return false\n    if (this.from.length == ChunkSize) this.finishChunk(true)\n    if (this.chunkStart < 0) this.chunkStart = from\n    this.from.push(from - this.chunkStart)\n    this.to.push(to - this.chunkStart)\n    this.last = value\n    this.lastFrom = from\n    this.lastTo = to\n    this.value.push(value)\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from)\n    return true\n  }\n\n  /// @internal\n  addChunk(from: number, chunk: Chunk<T>) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last!.endSide) < 0) return false\n    if (this.from.length) this.finishChunk(true)\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint)\n    this.chunks.push(chunk)\n    this.chunkPos.push(from)\n    let last = chunk.value.length - 1\n    this.last = chunk.value[last]\n    this.lastFrom = chunk.from[last] + from\n    this.lastTo = chunk.to[last] + from\n    return true\n  }\n\n  /// Finish the range set. Returns the new set. The builder can't be\n  /// used anymore after this has been called.\n  finish() { return this.finishInner(RangeSet.empty) }\n\n  /// @internal\n  finishInner(next: RangeSet<T>): RangeSet<T> {\n    if (this.from.length) this.finishChunk(false)\n    if (this.chunks.length == 0) return next\n    let result = new RangeSet(this.chunkPos, this.chunks,\n                              this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint)\n    this.from = null as any // Make sure further `add` calls produce errors\n    return result\n  }\n}\n\nfunction findSharedChunks(a: readonly RangeSet<any>[], b: readonly RangeSet<any>[]) {\n  let inA = new Map<Chunk<any>, number>()\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++)\n    if (set.chunk[i].maxPoint < BigPointSize) inA.set(set.chunk[i], set.chunkPos[i])\n  let shared = new Set<Chunk<any>>()\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++)\n    if (inA.get(set.chunk[i]) == set.chunkPos[i])\n      shared.add(set.chunk[i])\n  return shared\n}\n\nclass LayerCursor<T extends RangeValue> {\n  from!: number\n  to!: number\n  value!: T | null\n\n  chunkIndex!: number\n  rangeIndex!: number\n\n  constructor(readonly layer: RangeSet<T>, readonly skip: Set<Chunk<T>> | null, readonly minPoint: number) {}\n\n  get startSide() { return this.value ? this.value.startSide : 0 }\n  get endSide() { return this.value ? this.value.endSide : 0 }\n\n  goto(pos: number, side: number = -Far) {\n    this.chunkIndex = this.rangeIndex = 0\n    this.gotoInner(pos, side, false)\n    return this\n  }\n\n  gotoInner(pos: number, side: number, forward: boolean) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex]\n      if (!(this.skip && this.skip.has(next) ||\n            this.layer.chunkEnd(this.chunkIndex) < pos ||\n            next.maxPoint < this.minPoint)) break\n      this.chunkIndex++\n      forward = false\n    }\n    let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n      : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side)\n    if (!forward || this.rangeIndex < rangeIndex) this.rangeIndex = rangeIndex\n    this.next()\n  }\n\n  forward(pos: number, side: number) {\n    if ((this.to - pos || this.endSide - side) < 0)\n      this.gotoInner(pos, side, true)\n  }\n\n  next() {\n    for (;;) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = Far\n        this.value = null\n        break\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex]\n        let from = chunkPos + chunk.from[this.rangeIndex]\n        this.from = from\n        this.to = chunkPos + chunk.to[this.rangeIndex]\n        this.value = chunk.value[this.rangeIndex]\n        if (++this.rangeIndex == chunk.value.length) {\n          this.chunkIndex++\n          if (this.skip) {\n            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n              this.chunkIndex++\n          }\n          this.rangeIndex = 0\n        }\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break\n      }\n    }\n  }\n\n  nextChunk() {\n    this.chunkIndex++\n    this.rangeIndex = 0\n    this.next()\n  }\n\n  compare(other: LayerCursor<T>) {\n    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide\n  }\n}\n\nclass HeapCursor<T extends RangeValue> {\n  from!: number\n  to!: number\n  value!: T | null\n  \n  constructor(readonly heap: LayerCursor<T>[]) {}\n\n  static from<T extends RangeValue>(\n    sets: readonly RangeSet<T>[],\n    skip: Set<Chunk<T>> | null = null,\n    minPoint: number = -1\n  ): HeapCursor<T> | LayerCursor<T> {\n    let heap = []\n    for (let set of sets) for (let cur = set; cur != RangeSet.empty; cur = cur.nextLayer) {\n      if (cur.maxPoint >= minPoint)\n        heap.push(new LayerCursor(cur, skip, minPoint))\n    }\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap)\n  }\n\n  get startSide() { return this.value ? this.value.startSide : 0 }\n\n  goto(pos: number, side: number = -Far) {\n    for (let cur of this.heap) cur.goto(pos, side)\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i)\n    this.next()\n    return this\n  }\n\n  forward(pos: number, side: number) {\n    for (let cur of this.heap) cur.forward(pos, side)\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i)\n    if ((this.to - pos || this.value!.endSide - side) < 0) this.next()\n  }    \n\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = Far\n      this.value = null\n    } else {\n      let top = this.heap[0]\n      this.from = top.from\n      this.to = top.to\n      this.value = top.value\n      if (top.value) top.next()\n      heapBubble(this.heap, 0)\n    }\n  }\n}\n\nfunction heapBubble<T extends RangeValue>(heap: LayerCursor<T>[], index: number) {\n  for (let cur = heap[index];;) {\n    let childIndex = (index << 1) + 1\n    if (childIndex >= heap.length) break\n    let child = heap[childIndex]\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1]\n      childIndex++\n    }\n    if (cur.compare(child) < 0) break\n    heap[childIndex] = cur\n    heap[index] = child\n    index = childIndex\n  }\n}\n\nclass SpanCursor<T extends RangeValue> {\n  cursor: HeapCursor<T> | LayerCursor<T>\n\n  active: T[] = []\n  activeTo: number[] = []\n  minActive = -1\n\n  // A currently active point range, if any\n  point: T | null = null\n  pointFrom = 0\n\n  to = -Far\n  endSide = 0\n\n  constructor(sets: readonly RangeSet<T>[],\n              skip: Set<Chunk<T>> | null,\n              readonly minPoint: number) {\n    this.cursor = HeapCursor.from(sets, skip, minPoint)\n  }\n\n  goto(pos: number, side: number = -Far) {\n    this.cursor.goto(pos, side)\n    this.active.length = this.activeTo.length = 0\n    this.minActive = -1\n    this.to = pos\n    this.endSide = side\n    this.next()\n    return this\n  }\n\n  forward(pos: number, side: number) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n      this.removeActive(this.minActive)\n    this.cursor.forward(pos, side)\n  }\n\n  removeActive(index: number) {\n    remove(this.active, index)\n    remove(this.activeTo, index)\n    this.minActive = findMinIndex(this.active, this.activeTo)\n  }\n\n  // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n  next() {\n    let from = this.to\n    this.point = null\n    for (;;) {\n      let a = this.minActive\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a]\n          this.endSide = this.active[a].endSide\n          break\n        }\n        this.removeActive(a)\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = Far\n        break\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from\n        this.endSide = this.cursor.startSide\n        break\n      } else {\n        let nextVal = this.cursor.value\n        if (!nextVal.point) { // Opening a range\n          this.active.push(nextVal)\n          this.activeTo.push(this.cursor.to)\n          this.minActive = findMinIndex(this.active, this.activeTo)\n          this.cursor.next()\n        } else { // New point\n          this.point = nextVal\n          this.pointFrom = this.cursor.from\n          this.to = this.cursor.to\n          this.endSide = nextVal.endSide\n          this.cursor.next()\n          if (this.to > from) this.forward(this.to, this.endSide)\n          break\n        }\n      }\n    }\n  }\n}\n\nfunction compare<T extends RangeValue>(a: SpanCursor<T>, startA: number,\n                                       b: SpanCursor<T>, startB: number,\n                                       length: number,\n                                       comparator: RangeComparator<T>) {\n  a.goto(startA)\n  b.goto(startB)\n  let endB = startB + length\n  let pos = startB, dPos = startB - startA\n  for (;;) {\n    let diff = (a.to + dPos) - b.to || a.endSide - b.endSide\n    let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB)\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n        comparator.comparePoint(pos, clipEnd, a.point, b.point)\n    } else {\n      if (clipEnd > pos && !sameSet(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active)\n    }\n    if (end > endB) break\n    pos = end\n    if (diff <= 0) a.next()\n    if (diff >= 0) b.next()\n  }\n}\n\nfunction sameSet<T extends RangeValue>(a: T[], b: T[]) {\n  if (a.length != b.length) return false\n  outer: for (let i = 0; i < a.length; i++) {\n    for (let j = 0; j < b.length; j++)\n      if (a[i] == b[i] || a[i].eq(b[j])) continue outer\n    return false\n  }\n  return true\n}\n\nfunction remove<T>(array: T[], index: number) {\n  let last = array.pop()!\n  if (index != array.length) array[index] = last\n}\n\nfunction findMinIndex(value: RangeValue[], array: number[]) {\n  let found = -1, foundPos = Far\n  for (let i = 0; i < array.length; i++)\n    if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i\n    foundPos = array[i]\n  }\n  return found\n}\n"],"names":["MapMode"],"mappings":"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"}
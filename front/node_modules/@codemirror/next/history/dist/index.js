'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var state = require('../../state');

class Item {
    constructor(map, inverted = null, selection = null) {
        this.map = map;
        this.inverted = inverted;
        this.selection = selection;
    }
    get isChange() { return this.inverted != null; }
}
function updateBranch(branch, to, maxLen, newItem) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newItem);
    return newBranch;
}
function isAdjacent(prev, cur) {
    return !!prev && cur.from <= prev.mapPos(prev.to, 1) && cur.to >= prev.mapPos(prev.from);
}
function addChanges(branch, changes, inverted, selectionBefore, maxLen, mayMerge) {
    if (branch.length) {
        const lastItem = branch[branch.length - 1];
        if (lastItem.selection && lastItem.isChange == Boolean(inverted) && mayMerge(lastItem))
            return inverted ? updateBranch(branch, branch.length - 1, maxLen, new Item(lastItem.map.appendSet(changes.desc), inverted.appendSet(lastItem.inverted), lastItem.selection)) : branch;
    }
    return updateBranch(branch, branch.length, maxLen, new Item(changes.desc, inverted, selectionBefore));
}
function popChanges(branch, only) {
    let map = null;
    let idx = branch.length - 1;
    for (;; idx--) {
        if (idx < 0)
            throw new RangeError("popChanges called on empty branch");
        let entry = branch[idx];
        if (entry.isChange || (only == 1 /* Any */ && entry.selection))
            break;
        map = map ? entry.map.appendSet(map) : entry.map;
    }
    let changeItem = branch[idx];
    let newBranch = branch.slice(0, idx), changes = changeItem.inverted || state.ChangeSet.empty, selection = changeItem.selection;
    if (map) {
        let startIndex = changeItem.map.length;
        map = changeItem.map.appendSet(map);
        let mappedChanges = [];
        for (let i = 0; i < changes.length; i++) {
            let mapped = changes.changes[i].map(map.partialMapping(startIndex - i));
            if (mapped) {
                map = map.append(mapped.desc);
                mappedChanges.push(mapped);
            }
        }
        newBranch.push(new Item(map));
        changes = new state.ChangeSet(mappedChanges); // FIXME preserve mirror data?
        selection = selection.map(map);
    }
    return { changes, branch: newBranch, selection };
}
function nope() { return false; }
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
class HistoryState {
    constructor(done, undone, prevTime = null, prevUserEvent = undefined) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    resetTime() {
        return new HistoryState(this.done, this.undone);
    }
    addChanges(changes, inverted, selection, time, userEvent, newGroupDelay, maxLen) {
        let mayMerge = nope;
        if (this.prevTime !== null && time - this.prevTime < newGroupDelay &&
            (inverted || (this.prevUserEvent == userEvent && userEvent == "keyboard")))
            mayMerge = inverted
                ? prev => isAdjacent(prev.map.changes[prev.map.length - 1], changes.changes[0])
                : prev => eqSelectionShape(prev.selection, selection);
        return new HistoryState(addChanges(this.done, changes, inverted, selection, maxLen, mayMerge), this.undone, time, userEvent);
    }
    addMapping(map, maxLen) {
        if (this.done.length == 0)
            return this;
        return new HistoryState(updateBranch(this.done, this.done.length, maxLen, new Item(map)), this.undone);
    }
    canPop(done, only) {
        const target = done == 0 /* Done */ ? this.done : this.undone;
        for (const { isChange, selection } of target)
            if (isChange || (only == 1 /* Any */ && selection))
                return true;
        return false;
    }
    pop(done, only, transaction, maxLen) {
        let { changes, branch, selection } = popChanges(done == 0 /* Done */ ? this.done : this.undone, only);
        let oldSelection = transaction.selection;
        for (let change of changes.changes)
            transaction.change(change);
        transaction.setSelection(selection);
        let otherBranch = (done == 0 /* Done */ ? this.undone : this.done);
        otherBranch = addChanges(otherBranch, transaction.changes, transaction.changes.length > 0 ? transaction.invertedChanges() : null, oldSelection, maxLen, nope);
        return { transaction, state: new HistoryState(done == 0 /* Done */ ? branch : otherBranch, done == 0 /* Done */ ? otherBranch : branch) };
    }
    eventCount(done, only) {
        let count = 0, branch = done == 0 /* Done */ ? this.done : this.undone;
        for (const { isChange, selection } of branch)
            if (isChange || (only == 1 /* Any */ && selection))
                ++count;
        return count;
    }
}
HistoryState.empty = new HistoryState([], []);

const historyStateAnnotation = state.Annotation.define();
const closeHistoryAnnotation = state.Annotation.define();
const historyConfig = state.Facet.define({
    combine(configs) {
        return state.combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500
        }, { minDepth: Math.max, newGroupDelay: Math.min });
    }
});
const historyField = state.StateField.define({
    create() {
        return HistoryState.empty;
    },
    update(state$1, tr, newState) {
        const fromMeta = tr.annotation(historyStateAnnotation);
        if (fromMeta)
            return fromMeta;
        if (tr.annotation(closeHistoryAnnotation))
            state$1 = state$1.resetTime();
        if (!tr.changes.length && !tr.selectionSet)
            return state$1;
        let config = newState.facet(historyConfig);
        if (tr.annotation(state.Transaction.addToHistory) !== false)
            return state$1.addChanges(tr.changes, tr.changes.length ? tr.invertedChanges() : null, tr.startState.selection, tr.annotation(state.Transaction.time), tr.annotation(state.Transaction.userEvent), config.newGroupDelay, config.minDepth);
        return state$1.addMapping(tr.changes.desc, config.minDepth);
    }
});
/// Create a history extension with the given configuration.
function history(config = {}) {
    return [
        historyField,
        historyConfig.of(config)
    ];
}
function cmd(target, only) {
    return function ({ state, dispatch }) {
        let config = state.facet(historyConfig);
        let historyState = state.field(historyField, false);
        if (!historyState || !historyState.canPop(target, only))
            return false;
        const { transaction, state: newState } = historyState.pop(target, only, state.t(), config.minDepth);
        dispatch(transaction.annotate(historyStateAnnotation, newState));
        return true;
    };
}
/// Undo a single group of history events. Returns false if no group
/// was available.
const undo = cmd(0 /* Done */, 0 /* OnlyChanges */);
/// Redo a group of history events. Returns false if no group was
/// available.
const redo = cmd(1 /* Undone */, 0 /* OnlyChanges */);
/// Undo a selection change.
const undoSelection = cmd(0 /* Done */, 1 /* Any */);
/// Redo a selection change.
const redoSelection = cmd(1 /* Undone */, 1 /* Any */);
/// Set a flag on the given transaction that will prevent further steps
/// from being appended to an existing history event (so that they
/// require a separate undo command to undo).
function closeHistory(tr) {
    return tr.annotate(closeHistoryAnnotation, true);
}
function depth(target, only) {
    return function (state) {
        let histState = state.field(historyField, false);
        return histState ? histState.eventCount(target, only) : 0;
    };
}
/// The amount of undoable change events available in a given state.
const undoDepth = depth(0 /* Done */, 0 /* OnlyChanges */);
/// The amount of redoable change events available in a given state.
const redoDepth = depth(1 /* Undone */, 0 /* OnlyChanges */);
/// The amount of undoable events available in a given state.
const redoSelectionDepth = depth(0 /* Done */, 1 /* Any */);
/// The amount of redoable events available in a given state.
const undoSelectionDepth = depth(1 /* Undone */, 1 /* Any */);

exports.closeHistory = closeHistory;
exports.history = history;
exports.redo = redo;
exports.redoDepth = redoDepth;
exports.redoSelection = redoSelection;
exports.redoSelectionDepth = redoSelectionDepth;
exports.undo = undo;
exports.undoDepth = undoDepth;
exports.undoSelection = undoSelection;
exports.undoSelectionDepth = undoSelectionDepth;

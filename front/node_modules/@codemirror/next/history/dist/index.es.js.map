{"version":3,"file":"index.es.js","sources":["../src/core.ts","../src/history.ts"],"sourcesContent":["import {ChangeSet, ChangeDesc, Transaction, EditorSelection} from \"../../state\"\n\nclass Item {\n  constructor(readonly map: ChangeSet<ChangeDesc>,\n              readonly inverted: ChangeSet | null = null,\n              readonly selection: EditorSelection | null = null) {}\n  get isChange(): boolean { return this.inverted != null }\n}\nexport const enum ItemFilter { OnlyChanges, Any }\n\ntype Branch = readonly Item[]\n\nfunction updateBranch(branch: Branch, to: number, maxLen: number, newItem: Item) {\n  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0\n  let newBranch = branch.slice(start, to)\n  newBranch.push(newItem)\n  return newBranch\n}\n\nfunction isAdjacent(prev: ChangeDesc | null, cur: ChangeDesc): boolean {\n  return !!prev && cur.from <= prev.mapPos(prev.to, 1) && cur.to >= prev.mapPos(prev.from)\n}\n\nfunction addChanges(branch: Branch, changes: ChangeSet, inverted: ChangeSet | null,\n                    selectionBefore: EditorSelection, maxLen: number,\n                    mayMerge: (prevItem: Item) => boolean): Branch {\n  if (branch.length) {\n    const lastItem = branch[branch.length - 1]\n    if (lastItem.selection && lastItem.isChange == Boolean(inverted) && mayMerge(lastItem))\n      return inverted ? updateBranch(branch, branch.length - 1, maxLen, new Item(lastItem.map.appendSet(changes.desc), inverted.appendSet(lastItem.inverted!), lastItem.selection)) : branch\n  }\n  return updateBranch(branch, branch.length, maxLen, new Item(changes.desc, inverted, selectionBefore))\n}\n\nfunction popChanges(branch: Branch, only: ItemFilter): {changes: ChangeSet, branch: Branch, selection: EditorSelection} {\n  let map: ChangeSet<ChangeDesc> | null = null\n  let idx = branch.length - 1\n  for (;; idx--) {\n    if (idx < 0) throw new RangeError(\"popChanges called on empty branch\")\n    let entry = branch[idx]\n    if (entry.isChange || (only == ItemFilter.Any && entry.selection)) break\n    map = map ? entry.map.appendSet(map) : entry.map\n  }\n\n  let changeItem = branch[idx]\n  let newBranch = branch.slice(0, idx), changes = changeItem.inverted || ChangeSet.empty, selection = changeItem.selection!\n\n  if (map) {\n    let startIndex = changeItem.map.length\n    map = changeItem.map.appendSet(map)\n    let mappedChanges = []\n    for (let i = 0; i < changes.length; i++) {\n      let mapped = changes.changes[i].map(map.partialMapping(startIndex - i))\n      if (mapped) {\n        map = map.append(mapped.desc)\n        mappedChanges.push(mapped)\n      }\n    }\n    newBranch.push(new Item(map))\n    changes = new ChangeSet(mappedChanges) // FIXME preserve mirror data?\n    selection = selection.map(map)\n  }\n  return {changes, branch: newBranch, selection}\n}\n\nfunction nope() { return false }\n\nfunction eqSelectionShape(a: EditorSelection, b: EditorSelection) {\n  return a.ranges.length == b.ranges.length &&\n         a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0\n}\n\nexport const enum PopTarget { Done, Undone }\n\nexport class HistoryState {\n  private constructor(public readonly done: Branch,\n                      public readonly undone: Branch,\n                      private readonly prevTime: number | null = null,\n                      private readonly prevUserEvent: string | undefined = undefined) {}\n\n  resetTime(): HistoryState {\n    return new HistoryState(this.done, this.undone)\n  }\n\n  addChanges(changes: ChangeSet, inverted: ChangeSet | null, selection: EditorSelection,\n             time: number, userEvent: string | undefined, newGroupDelay: number, maxLen: number): HistoryState {\n    let mayMerge: (item: Item) => boolean = nope\n    if (this.prevTime !== null && time - this.prevTime < newGroupDelay &&\n        (inverted || (this.prevUserEvent == userEvent && userEvent == \"keyboard\")))\n      mayMerge = inverted\n                 ? prev => isAdjacent(prev.map.changes[prev.map.length - 1], changes.changes[0])\n                 : prev => eqSelectionShape(prev.selection!, selection)\n    return new HistoryState(addChanges(this.done, changes, inverted, selection, maxLen, mayMerge),\n                            this.undone, time, userEvent)\n  }\n\n  addMapping(map: ChangeSet<ChangeDesc>, maxLen: number): HistoryState {\n    if (this.done.length == 0) return this\n    return new HistoryState(updateBranch(this.done, this.done.length, maxLen, new Item(map)), this.undone)\n  }\n\n  canPop(done: PopTarget, only: ItemFilter): boolean {\n    const target = done == PopTarget.Done ? this.done : this.undone\n    for (const {isChange, selection} of target)\n      if (isChange || (only == ItemFilter.Any && selection)) return true\n    return false\n  }\n\n  pop(done: PopTarget, only: ItemFilter, transaction: Transaction, maxLen: number): {transaction: Transaction, state: HistoryState} {\n    let {changes, branch, selection} = popChanges(done == PopTarget.Done ? this.done : this.undone, only)\n\n    let oldSelection = transaction.selection\n    for (let change of changes.changes) transaction.change(change)\n    transaction.setSelection(selection)\n    let otherBranch = (done == PopTarget.Done ? this.undone : this.done)\n    otherBranch = addChanges(otherBranch, transaction.changes, transaction.changes.length > 0 ? transaction.invertedChanges() : null, oldSelection, maxLen, nope)\n    return {transaction, state: new HistoryState(done == PopTarget.Done ? branch : otherBranch,\n                                                 done == PopTarget.Done ? otherBranch : branch)}\n  }\n\n  eventCount(done: PopTarget, only: ItemFilter) {\n    let count = 0, branch = done == PopTarget.Done ? this.done : this.undone\n    for (const {isChange, selection} of branch)\n      if (isChange || (only == ItemFilter.Any && selection)) ++count\n    return count\n  }\n\n  static empty: HistoryState = new HistoryState([], [])\n}\n","import {combineConfig, EditorState, Transaction, StateField, StateCommand, Annotation, Facet, Extension} from \"../../state\"\nimport {HistoryState, ItemFilter, PopTarget} from \"./core\"\n\nconst historyStateAnnotation = Annotation.define<HistoryState>()\n\nconst closeHistoryAnnotation = Annotation.define<boolean>()\n\n/// Options given when creating a history extension.\nexport interface HistoryConfig {\n  /// The minimum depth (amount of events) to store. Defaults to 100.\n  minDepth?: number,\n  /// The maximum time (in milliseconds) that adjacent events can be\n  /// apart and still be grouped together. Defaults to 500.\n  newGroupDelay?: number\n}\n\nconst historyConfig = Facet.define<HistoryConfig, Required<HistoryConfig>>({\n  combine(configs) {\n    return combineConfig(configs, {\n      minDepth: 100,\n      newGroupDelay: 500\n    }, {minDepth: Math.max, newGroupDelay: Math.min})\n  }\n})\n\nconst historyField = StateField.define({\n  create() {\n    return HistoryState.empty\n  },\n\n  update(state: HistoryState, tr: Transaction, newState: EditorState): HistoryState {\n    const fromMeta = tr.annotation(historyStateAnnotation)\n    if (fromMeta) return fromMeta\n    if (tr.annotation(closeHistoryAnnotation)) state = state.resetTime()\n    if (!tr.changes.length && !tr.selectionSet) return state\n\n    let config = newState.facet(historyConfig)\n    if (tr.annotation(Transaction.addToHistory) !== false)\n      return state.addChanges(tr.changes, tr.changes.length ? tr.invertedChanges() : null,\n                              tr.startState.selection, tr.annotation(Transaction.time)!,\n                              tr.annotation(Transaction.userEvent), config.newGroupDelay, config.minDepth)\n    return state.addMapping(tr.changes.desc, config.minDepth)\n  }\n})\n\n/// Create a history extension with the given configuration.\nexport function history(config: HistoryConfig = {}): Extension {\n  return [\n    historyField,\n    historyConfig.of(config)\n  ]\n}\n\nfunction cmd(target: PopTarget, only: ItemFilter): StateCommand {\n  return function({state, dispatch}: {state: EditorState, dispatch: (tr: Transaction) => void}) {\n    let config = state.facet(historyConfig)\n    let historyState = state.field(historyField, false)\n    if (!historyState || !historyState.canPop(target, only)) return false\n    const {transaction, state: newState} = historyState.pop(target, only, state.t(), config.minDepth)\n    dispatch(transaction.annotate(historyStateAnnotation, newState))\n    return true\n  }\n}\n\n/// Undo a single group of history events. Returns false if no group\n/// was available.\nexport const undo = cmd(PopTarget.Done, ItemFilter.OnlyChanges)\n/// Redo a group of history events. Returns false if no group was\n/// available.\nexport const redo = cmd(PopTarget.Undone, ItemFilter.OnlyChanges)\n\n/// Undo a selection change.\nexport const undoSelection = cmd(PopTarget.Done, ItemFilter.Any)\n\n/// Redo a selection change.\nexport const redoSelection = cmd(PopTarget.Undone, ItemFilter.Any)\n\n/// Set a flag on the given transaction that will prevent further steps\n/// from being appended to an existing history event (so that they\n/// require a separate undo command to undo).\nexport function closeHistory(tr: Transaction): Transaction {\n  return tr.annotate(closeHistoryAnnotation, true)\n}\n\nfunction depth(target: PopTarget, only: ItemFilter) {\n  return function(state: EditorState): number {\n    let histState = state.field(historyField, false)\n    return histState ? histState.eventCount(target, only) : 0\n  }\n}\n\n/// The amount of undoable change events available in a given state.\nexport const undoDepth = depth(PopTarget.Done, ItemFilter.OnlyChanges)\n/// The amount of redoable change events available in a given state.\nexport const redoDepth = depth(PopTarget.Undone, ItemFilter.OnlyChanges)\n/// The amount of undoable events available in a given state.\nexport const redoSelectionDepth = depth(PopTarget.Done, ItemFilter.Any)\n/// The amount of redoable events available in a given state.\nexport const undoSelectionDepth = depth(PopTarget.Undone, ItemFilter.Any)\n"],"names":[],"mappings":"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"}
{"version":3,"file":"index.es.js","sources":["../src/matchbrackets.ts"],"sourcesContent":["import {combineConfig, EditorState, Facet, StateField, Extension} from \"../../state\"\nimport {EditorView, themeClass} from \"../../view\"\nimport {Decoration, DecorationSet} from \"../../view\"\nimport {Tree, Subtree, NodeType} from \"lezer-tree\"\nimport {openNodeProp, closeNodeProp} from \"../../syntax\"\n\n/// Configuration options\nexport interface Config {\n  /// Whether the bracket matching should look at the character after\n  /// the cursor when matching (if the one before isn't a bracket).\n  /// Defaults to true.\n  afterCursor?: boolean,\n  /// The bracket characters to match, as a string of pairs. Defaults\n  /// to `\"()[]{}\"`. Note that these are only used as fallback when\n  /// there is no [matching information](#syntax.openNodeProp) in the\n  /// syntax tree.\n  brackets?: string,\n  /// The maximum distance to scan for matching brackets. This is only\n  /// relevant for brackets not encoded in the syntax tree. Defaults\n  /// to 10 000.\n  maxScanDistance?: number\n}\n\nconst baseTheme = EditorView.baseTheme({\n  matchingBracket: {color: \"#0b0\"},\n  nonmatchingBracket: {color: \"#a22\"}\n})\n\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\"\n\nconst bracketMatchingConfig = Facet.define<Config, Required<Config>>({\n  combine(configs) {\n    return combineConfig(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist\n    })\n  }\n})\n\nconst matchingMark = Decoration.mark({class: themeClass(\"matchingBracket\")}),\n      nonmatchingMark = Decoration.mark({class: themeClass(\"nonmatchingBracket\")})\n\nconst bracketMatchingState = StateField.define<DecorationSet>({\n  create() { return Decoration.none },\n  update(deco, tr, state) {\n    if (!tr.docChanged && !tr.selectionSet) return deco\n    let decorations = []\n    let config = state.facet(bracketMatchingConfig)\n    for (let range of state.selection.ranges) {\n      if (!range.empty) continue\n      let match = matchBrackets(state, range.head, -1, config)\n        || (range.head > 0 && matchBrackets(state, range.head - 1, 1, config))\n        || (config.afterCursor &&\n            (matchBrackets(state, range.head, 1, config) ||\n             (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1, config))))\n      if (!match) continue\n      let mark = match.matched ? matchingMark : nonmatchingMark\n      decorations.push(mark.range(match.start.from, match.start.to))\n      if (match.end) decorations.push(mark.range(match.end.from, match.end.to))\n    }\n    return Decoration.set(decorations, true)\n  }\n}).provide(EditorView.decorations)\n\nconst bracketMatchingUnique = [\n  bracketMatchingState,\n  baseTheme\n]\n\n/// Create an extension that enables bracket matching. Whenever the\n/// cursor is next to a bracket, that bracket and the one it matches\n/// are highlighted. Or, when no matching bracket is found, another\n/// highlighting style is used to indicate this.\nexport function bracketMatching(config: Config = {}): Extension {\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique]\n}\n\nfunction matchingNodes(node: NodeType, dir: -1 | 1, brackets: string): null | readonly string[] {\n  let byProp = node.prop(dir < 0 ? closeNodeProp : openNodeProp)\n  if (byProp) return byProp\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name)\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n      return [brackets[index + dir]]\n  }\n  return null\n}\n\n\n/// The result returned from `matchBrackets`.\nexport interface MatchResult {\n  /// The extent of the bracket token found.\n  start: {from: number, to: number},\n  /// The extent of the matched token, if any was found.\n  end?: {from: number, to: number},\n  /// Whether the tokens match. This can be false even when `end` has\n  /// a value, if that token doesn't match the opening token.\n  matched: boolean\n}\n\n/// Find the matching bracket for the token at `pos`, scanning\n/// direction `dir`. Only the `brackets` and `maxScanDistance`\n/// properties are used from `config`, if given. Returns null if no\n/// bracket was found at `pos`, or a match result otherwise.\nexport function matchBrackets(state: EditorState, pos: number, dir: -1 | 1, config: Config = {}): MatchResult | null {\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets\n  let tree = state.tree, sub = tree.resolve(pos, dir), matches\n  if (matches = matchingNodes(sub.type, dir, brackets))\n    return matchMarkedBrackets(state, pos, dir, sub, matches, brackets)\n  else\n    return matchPlainBrackets(state, pos, dir, tree, sub.type, maxScanDistance, brackets)\n}\n\nfunction matchMarkedBrackets(_state: EditorState, _pos: number, dir: -1 | 1, token: Subtree,\n                             matching: readonly string[], brackets: string) {\n  let parent = token.parent, firstToken = {from: token.start, to: token.end}\n  let depth = 0\n  return (parent && parent.iterate({\n    from: dir < 0 ? token.start : token.end,\n    to: dir < 0 ? parent.start : parent.end,\n    enter(type, from, to) {\n      if (dir < 0 ? to > token.start : from < token.end) return undefined\n      if (depth == 0 && matching.indexOf(type.name) > -1) {\n        return {start: firstToken, end: {from, to}, matched: true}\n      } else if (matchingNodes(type, dir, brackets)) {\n        depth++\n      } else if (matchingNodes(type, -dir as -1 | 1, brackets)) {\n        depth--\n        if (depth == 0) return {start: firstToken, end: {from, to}, matched: false}\n      }\n      return false\n    }\n  })) || {start: firstToken, matched: false}\n}\n\nfunction matchPlainBrackets(state: EditorState, pos: number, dir: number, tree: Tree,\n                            tokenType: NodeType, maxScanDistance: number, brackets: string) {\n  let startCh = dir < 0 ? state.doc.slice(pos - 1, pos) : state.doc.slice(pos, pos + 1)\n  let bracket = brackets.indexOf(startCh)\n  if (bracket < 0 || (bracket % 2 == 0) != (dir > 0)) return null\n\n  let startToken = {from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos}\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0\n  for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n    let text = iter.value\n    if (dir < 0) distance += text.length\n    let basePos = pos + distance * dir\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos])\n      if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType) continue\n      if ((found % 2 == 0) == (dir > 0)) {\n        depth++\n      } else if (depth == 1) { // Closing\n        return {start: startToken, end: {from: basePos + pos, to: basePos + pos + 1}, matched: (found >> 1) == (bracket >> 1)}\n      } else {\n        depth--\n      }\n    }\n    if (dir > 0) distance += text.length\n  }\n  return iter.done ? {start: startToken, matched: false} : null\n}\n"],"names":[],"mappings":"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"}
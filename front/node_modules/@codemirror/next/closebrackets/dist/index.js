'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var view = require('../../view');
var state = require('../../state');
var text = require('../../text');
var w3cKeyname = require('w3c-keyname');

const defaults = {
    closeBrackets: ["(", "[", "{", "'", '"'],
    closeBracketsBefore: ")]}'\":;>"
};
/// Extension to enable bracket-closing behavior. When a closeable
/// bracket is typed, its closing bracket is immediately inserted
/// after the cursor. When closing a bracket directly in front of that
/// closing bracket, the cursor moves over the existing bracket. When
/// backspacing in between brackets, both are removed.
const closeBrackets = view.EditorView.domEventHandlers.of({ keydown });
const definedClosing = "()[]{}<>";
function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
        if (definedClosing.charCodeAt(i) == ch)
            return definedClosing.charAt(i + 1);
    return text.fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config(state$1, pos) {
    let syntax = state$1.facet(state.EditorState.syntax);
    if (syntax.length == 0)
        return defaults;
    return syntax[0].languageDataAt(state$1, pos);
}
function keydown(view, event) {
    if (event.ctrlKey || event.metaKey)
        return false;
    if (event.keyCode == 8) { // Backspace
        let tr = handleBackspace(view.state);
        if (!tr)
            return false;
        view.dispatch(tr);
        return true;
    }
    let key = w3cKeyname.keyName(event);
    if (key.length > 2 || key.length == 2 && text.codePointAt(key, 0) < text.minPairCodePoint)
        return false;
    let tr = handleInsertion(view.state, key);
    if (!tr)
        return false;
    view.dispatch(tr);
    return true;
}
/// Function that implements the extension's backspace behavior.
/// Exported mostly for testing purposes.
function handleBackspace(state$1) {
    let conf = config(state$1, state$1.selection.primary.head);
    let tokens = conf.closeBrackets || defaults.closeBrackets;
    let tr = state$1.t(), dont = null;
    tr.forEachRange(range => {
        if (!range.empty)
            return dont = range;
        let before = prevChar(state$1.doc, range.head);
        for (let token of tokens) {
            if (token == before && nextChar(state$1.doc, range.head) == closing(text.codePointAt(token, 0))) {
                tr.replace(range.head - token.length, range.head + token.length, "");
                return new state.SelectionRange(range.head - token.length);
            }
        }
        return dont = range;
    });
    return dont ? null : tr.scrollIntoView();
}
/// Implements the extension's behavior on text insertion. Again,
/// exported mostly for testing.
function handleInsertion(state, ch) {
    let conf = config(state, state.selection.primary.head);
    let tokens = conf.closeBrackets || defaults.closeBrackets;
    for (let tok of tokens) {
        let closed = closing(text.codePointAt(tok, 0));
        if (ch == tok)
            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1)
                : handleOpen(state, tok, closed, conf.closeBracketsBefore || defaults.closeBracketsBefore);
        if (ch == closed)
            return handleClose(state, tok, closed);
    }
    return null;
}
function nextChar(doc, pos) {
    let next = doc.slice(pos, pos + 2);
    return next.length == 2 && text.codePointAt(next, 0) < text.minPairCodePoint ? next.slice(0, 1) : next;
}
function prevChar(doc, pos) {
    let prev = doc.slice(pos - 2, pos);
    return prev.length == 2 && text.codePointAt(prev, 0) < text.minPairCodePoint ? prev.slice(1) : prev;
}
function handleOpen(state$1, open, close, closeBefore) {
    let tr = state$1.t(), dont = null;
    tr.forEachRange(range => {
        if (!range.empty) {
            tr.replace(range.to, range.to, close);
            tr.replace(range.from, range.from, open);
            return new state.SelectionRange(range.anchor + open.length, range.head + open.length);
        }
        let next = nextChar(state$1.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1) {
            tr.replace(range.head, range.head, open + close);
            return new state.SelectionRange(range.head + open.length, range.head + open.length);
        }
        return dont = range;
    });
    return dont ? null : tr.scrollIntoView();
}
function handleClose(state$1, open, close) {
    let tr = state$1.t(), dont = null;
    tr.forEachRange(range => {
        if (range.empty && close == nextChar(state$1.doc, range.head))
            return new state.SelectionRange(range.head + close.length);
        return dont = range;
    });
    return dont ? null : tr.scrollIntoView();
}
// Handles cases where the open and close token are the same, and
// possibly triple quotes (as in `"""abc"""`-style quoting).
function handleSame(state$1, token, allowTriple) {
    let tr = state$1.t(), dont = null;
    tr.forEachRange(range => {
        if (!range.empty) {
            tr.replace(range.to, range.to, token);
            tr.replace(range.from, range.from, token);
            return new state.SelectionRange(range.anchor + token.length, range.head + token.length);
        }
        let pos = range.head, next = nextChar(state$1.doc, pos);
        if (next == token) {
            if (nodeStart(state$1, pos)) {
                tr.replace(pos, pos, token + token);
                return new state.SelectionRange(pos + token.length);
            }
            else {
                let isTriple = allowTriple && state$1.doc.slice(pos, pos + token.length * 3) == token + token + token;
                return new state.SelectionRange(pos + token.length * (isTriple ? 3 : 1));
            }
        }
        else if (allowTriple && state$1.doc.slice(pos - 2 * token.length, pos) == token + token &&
            nodeStart(state$1, pos - 2 * token.length)) {
            tr.replace(pos, pos, token + token + token + token);
            return new state.SelectionRange(pos + token.length);
        }
        else if (!text.isWordChar(next)) {
            let prev = state$1.doc.slice(pos - 1, pos);
            if (!text.isWordChar(prev) && prev != token) {
                tr.replace(pos, pos, token + token);
                return new state.SelectionRange(pos + token.length);
            }
        }
        return dont = range;
    });
    return dont ? null : tr.scrollIntoView();
}
function nodeStart(state, pos) {
    let tree = state.tree.resolve(pos + 1);
    return tree.parent && tree.start == pos;
}

exports.closeBrackets = closeBrackets;
exports.handleBackspace = handleBackspace;
exports.handleInsertion = handleInsertion;

import { TagMap } from "./parse";
export interface ChangedRange {
    fromA: number;
    toA: number;
    fromB: number;
    toB: number;
}
export declare abstract class Subtree {
    abstract parent: Subtree | null;
    abstract type: number;
    abstract start: number;
    abstract end: number;
    readonly depth: number;
    readonly root: Tree;
    abstract toString(tags?: TagMap<any>): string;
    abstract iterate(from: number, to: number, enter: (type: number, start: number, end: number) => any, leave?: (type: number, start: number, end: number) => void): void;
    abstract resolve(pos: number): Subtree;
    abstract childBefore(pos: number): Subtree | null;
    abstract childAfter(pos: number): Subtree | null;
}
export declare class Tree extends Subtree {
    readonly children: (Tree | TreeBuffer)[];
    readonly positions: number[];
    readonly type: number;
    readonly length: number;
    parent: null;
    constructor(children: (Tree | TreeBuffer)[], positions: number[], type?: number, length?: number);
    readonly start: number;
    toString(tags?: TagMap<any>): string;
    readonly end: number;
    partial(start: number, end: number, offset: number, children: (Tree | TreeBuffer)[], positions: number[]): void;
    unchanged(changes: readonly ChangedRange[]): Tree;
    cut(at: number): Tree;
    static empty: Tree;
    iterate(from: number, to: number, enter: (type: number, start: number, end: number) => any, leave?: (type: number, start: number, end: number) => void): void;
    iterInner(from: number, to: number, offset: number, enter: (type: number, start: number, end: number) => any, leave?: (type: number, start: number, end: number) => void): void;
    resolve(pos: number): Subtree;
    childBefore(pos: number): Subtree | null;
    childAfter(pos: number): Subtree | null;
    findChild(pos: number, side: number, start: number, parent: Subtree): Subtree | null;
    resolveInner(pos: number, start: number, parent: Subtree): Subtree;
    append(other: Tree): Tree;
    static fromBuffer(buffer: readonly number[]): Tree;
}
export declare class TreeBuffer {
    readonly buffer: Uint16Array;
    constructor(buffer: Uint16Array);
    readonly nodeCount: number;
    readonly length: number;
    toString(tags?: TagMap<any>): string;
    childToString(index: number, parts: string[], tags?: TagMap<any>): number;
    cut(at: number): TreeBuffer;
    iterInner(from: number, to: number, offset: number, enter: (type: number, start: number, end: number) => any, leave?: (type: number, start: number, end: number) => void): void;
    iterChild(from: number, to: number, offset: number, index: number, enter: (type: number, start: number, end: number) => any, leave?: (type: number, start: number, end: number) => void): number;
    findIndex(pos: number, side: number, start: number, from: number, to: number): number;
}
export declare const REUSED_VALUE = -1;
export declare const DEFAULT_BUFFER_LENGTH = 2048;
export declare let MAX_BUFFER_LENGTH: number;
export declare function setBufferLength(len: number): void;
export interface BufferCursor {
    pos: number;
    type: number;
    start: number;
    end: number;
    size: number;
    next(): void;
    fork(): BufferCursor;
}
export declare function buildTree(cursor: BufferCursor, distribute: boolean, reused?: Tree[]): Tree;

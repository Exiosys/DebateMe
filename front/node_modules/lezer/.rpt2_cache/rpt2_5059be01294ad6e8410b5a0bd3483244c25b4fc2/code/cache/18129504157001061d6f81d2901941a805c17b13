{"code":"import { Stack, BADNESS_WILD } from \"./stack\";\nimport { ParseState, REDUCE_DEPTH_SIZE, ACTION_SKIP } from \"./state\";\nimport { TokenGroup } from \"./token\";\nimport { TERM_EOF, TERM_ERR } from \"./term\";\nimport { DEFAULT_BUFFER_LENGTH, Tree, TreeBuffer, TagMap } from \"lezer-tree\";\nimport { decodeArray } from \"./decode\";\nvar verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nexport var SPECIALIZE = 0, EXTEND = 1;\nvar CacheCursor = /** @class */ (function () {\n    function CacheCursor(tree) {\n        this.start = [0];\n        this.index = [0];\n        this.nextStart = 0;\n        this.trees = [tree];\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    CacheCursor.prototype.nodeAt = function (pos) {\n        if (pos < this.nextStart)\n            return null;\n        for (;;) {\n            var last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextStart = 1e9;\n                return null;\n            }\n            var top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            var next = top.children[index];\n            var start = this.start[last] + top.positions[index];\n            if (next instanceof TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else if (start >= pos) {\n                return start == pos ? next : null;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    };\n    return CacheCursor;\n}());\nvar CachedToken = /** @class */ (function () {\n    function CachedToken(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.start = -1;\n        this.end = -1;\n        this.term = -1;\n        this.extended = -1;\n    }\n    return CachedToken;\n}());\nvar TokenCache = /** @class */ (function () {\n    function TokenCache(parser, input) {\n        this.parser = parser;\n        this.input = input;\n        this.tokens = [];\n        this.actions = [];\n        this.mainToken = null;\n    }\n    TokenCache.prototype.getActions = function (stack) {\n        var actionIndex = 0;\n        var main = null;\n        var _loop_1 = function (i) {\n            if (((1 << i) & stack.state.tokenizerMask) == 0)\n                return \"continue\";\n            var tokenizer = this_1.parser.tokenizers[i];\n            var token = this_1.tokens.find(function (c) { return c.tokenizer == tokenizer; });\n            if (!token)\n                this_1.tokens.push(token = new CachedToken(tokenizer));\n            if (tokenizer.contextual || token.start != stack.inputPos)\n                this_1.updateCachedToken(token, stack);\n            var startIndex = actionIndex;\n            if (token.extended > -1)\n                actionIndex = this_1.addActions(stack.state, token.extended, token.end, actionIndex);\n            actionIndex = this_1.addActions(stack.state, token.term, token.end, actionIndex);\n            if (actionIndex > startIndex) {\n                main = token;\n                return \"break\";\n            }\n            if (!main || token.term != TERM_ERR)\n                main = token;\n        };\n        var this_1 = this;\n        for (var i = 0; i < this.parser.tokenizers.length; i++) {\n            var state_1 = _loop_1(i);\n            if (state_1 === \"break\")\n                break;\n        }\n        if (this.actions.length > actionIndex)\n            this.actions.length = actionIndex;\n        this.mainToken = main;\n        return this.actions;\n    };\n    TokenCache.prototype.updateCachedToken = function (token, stack) {\n        var input = this.input;\n        token.start = stack.inputPos;\n        token.extended = -1;\n        token.tokenizer.token(input.goto(stack.inputPos), stack);\n        if (input.token > -1) {\n            token.end = input.tokenEnd;\n            token.term = input.token;\n            var specIndex = findOffset(this.parser.data, this.parser.specializeTable, token.term);\n            if (specIndex >= 0) {\n                var found = this.parser.specializations[specIndex][input.read(token.start, token.end)];\n                if (found != null) {\n                    if ((found & 1) == SPECIALIZE)\n                        token.term = found >> 1;\n                    else\n                        token.extended = found >> 1;\n                }\n            }\n        }\n        else if (stack.inputPos == input.length) {\n            token.term = TERM_EOF;\n            token.end = token.start;\n        }\n        else {\n            token.term = TERM_ERR;\n            token.end = token.start + 1;\n        }\n    };\n    TokenCache.prototype.putAction = function (action, token, end, index) {\n        // Don't add duplicate actions\n        for (var i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    };\n    TokenCache.prototype.addActions = function (state, token, end, index) {\n        var data = this.parser.data;\n        for (var i = state.actions, next = void 0; (next = data[i]) != TERM_ERR; i += 3) {\n            if (next == token)\n                index = this.putAction(encode(data[i + 1], data[i + 2]), token, end, index);\n        }\n        if (findOffset(data, state.skip, token) > -1)\n            index = this.putAction(ACTION_SKIP, token, end, index);\n        return index;\n    };\n    return TokenCache;\n}());\nexport function parse(input, parser, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? null : _c, _d = _b.strict, strict = _d === void 0 ? false : _d, _e = _b.bufferLength, bufferLength = _e === void 0 ? DEFAULT_BUFFER_LENGTH : _e;\n    var parses = [Stack.start(parser, bufferLength)];\n    var cacheCursor = cache && new CacheCursor(cache);\n    var tokens = new TokenCache(parser, input);\n    var _loop_2 = function () {\n        var stack = Stack.take(parses), start = stack.inputPos;\n        if (cacheCursor) { //  && !stack.state.ambiguous) { // FIXME implement fragility check\n            for (var cached = cacheCursor.nodeAt(start); cached;) {\n                var match = parser.getGoto(stack.state.id, cached.type);\n                if (match > -1) {\n                    stack.useCached(cached, parser.states[match]);\n                    if (verbose)\n                        console.log(stack + (\" (via reuse of \" + parser.getName(cached.type) + \")\"));\n                    stack.put(parses);\n                    return \"continue-parse\";\n                }\n                if (cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                var inner = cached.children[0];\n                if (inner instanceof Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        var defaultReduce = stack.state.defaultReduce;\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            stack.put(parses);\n            if (verbose)\n                console.log(stack + (\" (via always-reduce \" + parser.getName(defaultReduce >> REDUCE_DEPTH_SIZE) + \")\"));\n            return \"continue\";\n        }\n        var actions = tokens.getActions(stack);\n        for (var i = 0; i < actions.length;) {\n            var action = actions[i++], term_1 = actions[i++], end_1 = actions[i++];\n            var localStack = i == actions.length ? stack : stack.split();\n            localStack.apply(action, term_1, end_1);\n            if (verbose)\n                console.log(localStack + (\" (via \" + (action < 0 ? \"shift\" : \"reduce of \" + parser.getName(action >> REDUCE_DEPTH_SIZE)) + \" for \" + parser.getName(term_1) + \" @ \" + start + (localStack == stack ? \"\" : \", split\") + \")\"));\n            localStack.put(parses, action >= 0);\n        }\n        if (actions.length > 0)\n            return \"continue\";\n        // If we're here, the stack failed to advance normally\n        if (start == input.length && (stack.state.accepting || parses.length == 0)) {\n            while (!stack.state.accepting && stack.forceReduce()) { }\n            return { value: stack.toTree() };\n        }\n        var _a = tokens.mainToken, end = _a.end, term = _a.term;\n        if (!strict &&\n            !(stack.badness > BADNESS_WILD && parses.some(function (s) { return s.pos >= stack.inputPos && s.badness <= stack.badness; }))) {\n            var inserted = stack.recoverByInsert(term, end);\n            if (inserted) {\n                if (verbose)\n                    console.log(inserted + \" (via recover-insert)\");\n                inserted.put(parses);\n            }\n            if (end == start) {\n                if (start == input.length)\n                    return \"continue\";\n                end++;\n                term = TERM_ERR;\n            }\n            stack.recoverByDelete(term, end);\n            if (verbose)\n                console.log(stack + \" (via recover-delete)\");\n            stack.put(parses);\n        }\n        else if (!parses.length) {\n            // Only happens in strict mode\n            throw new SyntaxError(\"No parse at \" + start + \" with \" + parser.getName(term) + \" (stack is \" + stack + \")\");\n        }\n    };\n    parse: for (;;) {\n        var state_2 = _loop_2();\n        if (typeof state_2 === \"object\")\n            return state_2.value;\n        switch (state_2) {\n            case \"continue-parse\": continue parse;\n        }\n    }\n}\nvar Parser = /** @class */ (function () {\n    function Parser(states, data, goto, tags, tokenizers, repeatTable, repeatCount, specializeTable, specializations, tokenPrecTable, skippedNodes, termNames) {\n        if (termNames === void 0) { termNames = null; }\n        this.states = states;\n        this.data = data;\n        this.goto = goto;\n        this.tags = tags;\n        this.tokenizers = tokenizers;\n        this.repeatTable = repeatTable;\n        this.repeatCount = repeatCount;\n        this.specializeTable = specializeTable;\n        this.specializations = specializations;\n        this.tokenPrecTable = tokenPrecTable;\n        this.skippedNodes = skippedNodes;\n        this.termNames = termNames;\n    }\n    Parser.prototype.getName = function (term) {\n        return this.termNames ? this.termNames[term] : this.tags.get(term) || String(term);\n    };\n    // Term should be a repeat term\n    Parser.prototype.getRepeat = function (term) {\n        return this.data[this.repeatTable + (term >> 1)];\n    };\n    Parser.prototype.parse = function (input, options) {\n        return parse(input, this, options);\n    };\n    Parser.prototype.getGoto = function (state, term, loose) {\n        if (loose === void 0) { loose = false; }\n        var table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (var pos = table[term + 1];;) {\n            var groupTag = table[pos++], last = groupTag & 1;\n            var target = table[pos++];\n            if (last && loose)\n                return target;\n            for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    };\n    Parser.prototype.hasAction = function (state, terminal) {\n        var data = this.data;\n        for (var i = state.actions, next = void 0; (next = data[i]) != TERM_ERR; i += 3) {\n            if (next == terminal)\n                return encode(data[i + 1], data[i + 2]);\n        }\n        if (findOffset(this.data, state.skip, terminal) > -1)\n            return ACTION_SKIP;\n        return 0;\n    };\n    Parser.prototype.getRecover = function (state, terminal) {\n        for (var i = state.recover, next = void 0; (next = this.data[i]) != TERM_ERR; i += 2)\n            if (next == terminal)\n                return this.data[i + 1];\n        return 0;\n    };\n    Parser.prototype.anyReduce = function (state) {\n        if (state.defaultReduce > 0)\n            return state.defaultReduce;\n        for (var i = state.actions;; i += 3) {\n            if (this.data[i] == TERM_ERR)\n                return 0;\n            var reduce = this.data[i + 1];\n            if (reduce > 0)\n                return reduce | (this.data[i + 2] << REDUCE_DEPTH_SIZE);\n        }\n    };\n    Parser.prototype.repeats = function (term) {\n        return (term >> 1) < this.repeatCount;\n    };\n    Parser.prototype.isSkipped = function (term) {\n        for (var i = this.skippedNodes, cur = void 0; (cur = this.data[i]) != TERM_ERR; i++)\n            if (cur == term)\n                return true;\n        return false;\n    };\n    Parser.prototype.overrides = function (token, prev) {\n        var iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    };\n    Parser.prototype.tagMap = function (values) {\n        var content = [];\n        for (var i = 0; i < this.tags.content.length; i++) {\n            var tag = this.tags.content[i];\n            content.push(Object.prototype.hasOwnProperty.call(values, tag) ? values[tag] :\n                tag[0] == '\"' && Object.prototype.hasOwnProperty.call(values, JSON.parse(tag)) ? values[JSON.parse(tag)] : null);\n        }\n        return new TagMap(content);\n    };\n    Parser.deserialize = function (states, stateData, goto, tags, tokenData, tokenizers, repeatTable, repeatCount, specializeTable, specializations, tokenPrec, skippedNodes, termNames) {\n        var arr = decodeArray(states, Uint32Array), stateObjs = [];\n        for (var i = 0, id = 0; i < arr.length;)\n            stateObjs.push(new ParseState(id++, arr[i++], arr[i++], arr[i++], arr[i++], arr[i++], arr[i++]));\n        var tokenArray = decodeArray(tokenData);\n        return new Parser(stateObjs, decodeArray(stateData), decodeArray(goto), new TagMap(tags), tokenizers.map(function (value) { return typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value; }), repeatTable, repeatCount, specializeTable, specializations.map(withoutPrototype), tokenPrec, skippedNodes, termNames);\n    };\n    Object.defineProperty(Parser.prototype, \"default\", {\n        // FIXME Horrid module interop kludge needed when consuming parser packages through ts-node\n        get: function () { return this; },\n        enumerable: true,\n        configurable: true\n    });\n    return Parser;\n}());\nexport { Parser };\nfunction encode(reduce, value) {\n    return reduce ? reduce | (value << REDUCE_DEPTH_SIZE) : -value;\n}\nfunction findOffset(data, start, term) {\n    for (var i = start, next = void 0; (next = data[i]) != TERM_ERR; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction withoutPrototype(obj) {\n    if (!(obj instanceof Object))\n        return obj;\n    var result = Object.create(null);\n    for (var prop in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, prop))\n            result[prop] = obj[prop];\n    return result;\n}\n//# sourceMappingURL=parse.js.map","map":"{\"version\":3,\"file\":\"parse.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/parse.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/parse.d.ts","writeByteOrderMark":false,"text":"import { ParseState } from \"./state\";\nimport { InputStream, Tokenizer } from \"./token\";\nimport { Tree, TagMap } from \"lezer-tree\";\nexport declare const SPECIALIZE = 0, EXTEND = 1;\nexport declare type ParseOptions = {\n    cache?: Tree | null;\n    strict?: boolean;\n    bufferLength?: number;\n};\nexport declare function parse(input: InputStream, parser: Parser, { cache, strict, bufferLength }?: ParseOptions): Tree;\nexport declare class Parser {\n    readonly states: readonly ParseState[];\n    readonly data: Readonly<Uint16Array>;\n    readonly goto: Readonly<Uint16Array>;\n    readonly tags: TagMap<string>;\n    readonly tokenizers: readonly Tokenizer[];\n    readonly repeatTable: number;\n    readonly repeatCount: number;\n    readonly specializeTable: number;\n    readonly specializations: readonly {\n        [value: string]: number;\n    }[];\n    readonly tokenPrecTable: number;\n    readonly skippedNodes: number;\n    readonly termNames: null | {\n        [id: number]: string;\n    };\n    constructor(states: readonly ParseState[], data: Readonly<Uint16Array>, goto: Readonly<Uint16Array>, tags: TagMap<string>, tokenizers: readonly Tokenizer[], repeatTable: number, repeatCount: number, specializeTable: number, specializations: readonly {\n        [value: string]: number;\n    }[], tokenPrecTable: number, skippedNodes: number, termNames?: null | {\n        [id: number]: string;\n    });\n    getName(term: number): string;\n    getRepeat(term: number): number;\n    parse(input: InputStream, options?: ParseOptions): Tree;\n    getGoto(state: number, term: number, loose?: boolean): number;\n    hasAction(state: ParseState, terminal: number): number;\n    getRecover(state: ParseState, terminal: number): number;\n    anyReduce(state: ParseState): number;\n    repeats(term: number): boolean;\n    isSkipped(term: number): boolean;\n    overrides(token: number, prev: number): boolean;\n    tagMap<T>(values: {\n        [name: string]: T;\n    }): TagMap<T>;\n    static deserialize(states: string, stateData: string, goto: string, tags: readonly string[], tokenData: string, tokenizers: (Tokenizer | number)[], repeatTable: number, repeatCount: number, specializeTable: number, specializations: readonly {\n        [term: string]: number;\n    }[], tokenPrec: number, skippedNodes: number, termNames?: {\n        [id: number]: string;\n    }): Parser;\n    readonly default: this;\n}\n"}}

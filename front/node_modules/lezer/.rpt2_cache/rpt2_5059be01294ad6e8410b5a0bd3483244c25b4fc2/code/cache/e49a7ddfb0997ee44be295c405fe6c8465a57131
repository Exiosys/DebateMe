{"code":"import { REDUCE_DEPTH_MASK, REDUCE_DEPTH_SIZE, ACTION_SKIP } from \"./state\";\nimport { TERM_TAGGED, TERM_ERR } from \"./term\";\nimport { Tree, REUSED_VALUE } from \"lezer-tree\";\nvar BADNESS_INCREMENT = 100;\n// Limits in between which stacks are less agressively pruned\nvar BADNESS_STABILIZING = 50;\nexport var BADNESS_WILD = 150;\n// Badness is a measure of how off-the-rails a given parse is. It is\n// bumped when a recovery strategy is applied, and then reduced (by\n// multiplication with a constant < 1) for every successful (real)\n// token shifted.\n//\n// Stacks with a low badness are relatively credible parses that have\n// shifts matching the input in their recent history. Stacks with a\n// high badness are deeply in the weeds and likely wrong. In either of\n// these situations, we prune agressively by dropping stacks when\n// another stack at the same position is looking better.\n//\n// For those in the BADNESS_STABILIZING - BADNESS_WILD range, we\n// assume that they are in the process of trying to recover and allow\n// a bunch of them to continue alongside each other to see which one\n// works out better.\n//\n// Stacks with the same low badness score are likely to be valid GLR\n// parsing branches, so in that case it's often a good idea to let\n// both continue.\n//\n// When a stack fails to find an advancing action, recovery is only\n// applied when its badness is < BADNESS_WILD, or no better parse\n// exists at that point.\nvar StackContext = /** @class */ (function () {\n    function StackContext(parser, reused, maxBufferLength) {\n        this.parser = parser;\n        this.reused = reused;\n        this.maxBufferLength = maxBufferLength;\n    }\n    return StackContext;\n}());\nvar Stack = /** @class */ (function () {\n    function Stack(cx, \n    // Holds state, pos, value stack pos (15 bits array index, 15 bits buffer index) triplets for all but the top state\n    stack, state, pos, inputPos, badness, \n    // Holds type,start,end,nodeCount quads\n    buffer, bufferBase, parent) {\n        this.cx = cx;\n        this.stack = stack;\n        this.state = state;\n        this.pos = pos;\n        this.inputPos = inputPos;\n        this.badness = badness;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    Stack.prototype.toString = function () {\n        return \"[\" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state.id).join(\",\") + \"]\";\n    };\n    Stack.start = function (parser, maxBufferLength) {\n        return new Stack(new StackContext(parser, [], maxBufferLength), [], parser.states[0], 0, 0, 0, [], 0, null);\n    };\n    Stack.prototype.pushState = function (state, start) {\n        this.stack.push(this.state.id, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    };\n    Stack.prototype.reduce = function (action) {\n        var depth = (action & REDUCE_DEPTH_MASK) - 1, type = action >> REDUCE_DEPTH_SIZE;\n        if (depth == 0) {\n            this.pushState(this.cx.parser.states[this.cx.parser.getGoto(this.state.id, type, true)], this.pos);\n            return;\n        }\n        var base = this.stack.length - ((depth - 1) * 3);\n        var start = this.stack[base - 2];\n        var count = this.bufferBase + this.buffer.length - this.stack[base - 1];\n        if ((type & TERM_TAGGED) > 0 ||\n            this.cx.parser.repeats(type) && this.pos - start > this.cx.maxBufferLength && count > 0) {\n            var storeType = type & TERM_TAGGED ? type : this.cx.parser.getRepeat(type);\n            if (this.inputPos == this.pos) { // Simple case, just append\n                this.buffer.push(storeType, start, this.pos, count + 4);\n            }\n            else { // There may be skipped nodes that have to be moved forward\n                var index = this.buffer.length;\n                while (index > 0 && this.buffer[index - 2] > this.pos) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    count -= 4;\n                }\n                this.buffer[index] = storeType;\n                this.buffer[index + 1] = start;\n                this.buffer[index + 2] = this.pos;\n                this.buffer[index + 3] = count + 4;\n            }\n        }\n        var baseStateID = this.stack[base - 3];\n        this.state = this.cx.parser.states[this.cx.parser.getGoto(baseStateID, type, true)];\n        if (depth > 1)\n            this.stack.length = base;\n    };\n    Stack.prototype.shiftValue = function (term, start, end, childCount) {\n        if (childCount === void 0) { childCount = 4; }\n        if (term == TERM_ERR) { // Try to omit superfluous error nodes\n            var cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == TERM_ERR &&\n                (start == end || cur.buffer[top - 2] >= start))\n                return;\n        }\n        this.buffer.push(term, start, end, childCount);\n    };\n    Stack.prototype.apply = function (action, next, nextEnd) {\n        if (action >= 0) {\n            this.reduce(action);\n        }\n        else if (action != ACTION_SKIP) { // Shift, not skipped\n            var start = this.inputPos;\n            if (nextEnd > this.inputPos || (next & TERM_TAGGED))\n                this.pos = this.inputPos = nextEnd;\n            this.pushState(this.cx.parser.states[-action], start);\n            if (next & TERM_TAGGED)\n                this.buffer.push(next, start, nextEnd, 4);\n            this.badness = (this.badness >> 1) + (this.badness >> 2); // (* 0.75)\n        }\n        else { // Skipped\n            if (next & TERM_TAGGED)\n                this.buffer.push(next, this.inputPos, nextEnd, 4);\n            this.inputPos = nextEnd;\n        }\n    };\n    Stack.prototype.useCached = function (value, next) {\n        var index = this.cx.reused.length - 1;\n        if (index < 0 || this.cx.reused[index] != value) {\n            this.cx.reused.push(value);\n            index++;\n        }\n        var start = this.inputPos;\n        this.pos = this.inputPos = start + value.length;\n        this.pushState(next, start);\n        this.badness >> 1; // FIXME\n        this.buffer.push(index, start, this.pos, REUSED_VALUE);\n    };\n    Stack.prototype.split = function () {\n        var parent = this;\n        var off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.pos)\n            off -= 4;\n        var buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.cx, this.stack.slice(), this.state, this.pos, this.inputPos, this.badness, buffer, base, parent);\n    };\n    Stack.prototype.recoverByDelete = function (next, nextEnd) {\n        if (next & TERM_TAGGED)\n            this.shiftValue(next, this.inputPos, nextEnd);\n        this.shiftValue(TERM_ERR, this.inputPos, nextEnd, (next & TERM_TAGGED) ? 8 : 4);\n        this.inputPos = nextEnd;\n        this.badness += BADNESS_INCREMENT;\n    };\n    Stack.prototype.canShift = function (term) {\n        for (var sim = new SimulatedStack(this);;) {\n            var action = sim.top.defaultReduce || this.cx.parser.hasAction(sim.top, term);\n            if (action < 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    };\n    Stack.prototype.canRecover = function (next) {\n        // Scan for a state that has either a direct action or a recovery\n        // action for next, without actually building up a new stack\n        var visited = null, parser = this.cx.parser;\n        for (var sim = new SimulatedStack(this), i = 0;; i++) {\n            if (parser.hasAction(sim.top, next) || parser.getRecover(sim.top, next) != 0)\n                return true;\n            // Find a way to reduce from here\n            var reduce = parser.anyReduce(sim.top);\n            if (reduce == 0 && ((reduce = sim.top.forcedReduce) & REDUCE_DEPTH_MASK) == 0)\n                return false;\n            sim.reduce(reduce);\n            if (i > 10) {\n                // Guard against getting stuck in a cycle\n                if (!visited)\n                    visited = [];\n                else if (i == 100 || visited.includes(sim.top.id))\n                    return false;\n                visited.push(sim.top.id);\n            }\n        }\n    };\n    Stack.prototype.recoverByInsert = function (next, nextEnd) {\n        if (!this.canRecover(next))\n            return null;\n        // Now that we know there's a recovery to be found, run the\n        // reduces again, the expensive way, updating the stack\n        var result = this.split(), parser = this.cx.parser;\n        result.pos = result.inputPos;\n        result.badness += BADNESS_INCREMENT;\n        for (;;) {\n            for (;;) {\n                if (parser.hasAction(result.state, next))\n                    return result;\n                var recover = parser.getRecover(result.state, next);\n                if (!recover)\n                    break;\n                var pos = result.pos;\n                result.pushState(this.cx.parser.states[recover], pos);\n                result.shiftValue(TERM_ERR, pos, pos);\n            }\n            result.forceReduce();\n        }\n    };\n    Stack.prototype.forceReduce = function () {\n        var reduce = this.cx.parser.anyReduce(this.state);\n        if (reduce == 0) {\n            // FIXME somehow mark the resulting node as not suitable for reuse\n            reduce = this.state.forcedReduce;\n            if (reduce <= 0)\n                return false;\n            this.shiftValue(TERM_ERR, this.pos, this.pos);\n        }\n        this.reduce(reduce);\n        return true;\n    };\n    Stack.prototype.compare = function (other) {\n        return this.inputPos - other.inputPos || this.badness - other.badness;\n    };\n    Stack.prototype.put = function (parses, strict) {\n        if (strict === void 0) { strict = this.badness < BADNESS_STABILIZING || this.badness > BADNESS_WILD; }\n        for (var i = 0; i < parses.length; i++) {\n            var other = parses[i];\n            if ((strict || other.state == this.state) && other.inputPos == this.inputPos) {\n                var diff = this.badness - other.badness || (this.badness < BADNESS_STABILIZING ? 0 : this.stack.length - other.stack.length);\n                if (diff < 0) {\n                    parses[i] = this;\n                    return true;\n                }\n                else if (diff > 0)\n                    return false;\n            }\n        }\n        // Binary heap add\n        var index = parses.push(this) - 1;\n        while (index > 0) {\n            var parentIndex = index >> 1, parent = parses[parentIndex];\n            if (this.compare(parent) >= 0)\n                break;\n            parses[index] = parent;\n            parses[parentIndex] = this;\n            index = parentIndex;\n        }\n        return true;\n    };\n    Stack.take = function (parses) {\n        // Binary heap pop\n        var elt = parses[0], replacement = parses.pop();\n        if (parses.length == 0)\n            return elt;\n        parses[0] = replacement;\n        for (var index = 0;;) {\n            var childIndex = (index << 1) + 1;\n            if (childIndex >= parses.length)\n                break;\n            var child = parses[childIndex];\n            if (childIndex + 1 < parses.length && child.compare(parses[childIndex + 1]) >= 0) {\n                child = parses[childIndex + 1];\n                childIndex++;\n            }\n            if (replacement.compare(child) < 0)\n                break;\n            parses[childIndex] = replacement;\n            parses[index] = child;\n            index = childIndex;\n        }\n        return elt;\n    };\n    Stack.prototype.toTree = function () {\n        return Tree.build(StackBufferCursor.create(this), this.cx.maxBufferLength, this.cx.reused);\n    };\n    return Stack;\n}());\nexport { Stack };\nvar SimulatedStack = /** @class */ (function () {\n    function SimulatedStack(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    SimulatedStack.prototype.reduce = function (action) {\n        var term = action >> REDUCE_DEPTH_SIZE, depth = (action & REDUCE_DEPTH_MASK) - 1;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top.id, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        var goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = this.stack.cx.parser.states[goto];\n    };\n    return SimulatedStack;\n}());\nvar StackBufferCursor = /** @class */ (function () {\n    function StackBufferCursor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    StackBufferCursor.create = function (stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    };\n    StackBufferCursor.prototype.maybeNext = function () {\n        var next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    };\n    Object.defineProperty(StackBufferCursor.prototype, \"type\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    StackBufferCursor.prototype.next = function () {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    };\n    StackBufferCursor.prototype.fork = function () {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    };\n    return StackBufferCursor;\n}());\n//# sourceMappingURL=stack.js.map","map":"{\"version\":3,\"file\":\"stack.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/stack.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAa,iBAAiB,EAAE,iBAAiB,EAAE,WAAW,EAAC,MAAM,SAAS,CAAA;AACrF,OAAO,EAAC,WAAW,EAAE,QAAQ,EAAC,MAAM,QAAQ,CAAA;AAE5C,OAAO,EAAC,IAAI,EAAE,YAAY,EAAe,MAAM,YAAY,CAAA;AAE3D,IAAM,iBAAiB,GAAG,GAAG,CAAA;AAC7B,6DAA6D;AAC7D,IAAM,mBAAmB,GAAG,EAAE,CAAA;AAC9B,MAAM,CAAC,IAAM,YAAY,GAAG,GAAG,CAAA;AAE/B,oEAAoE;AACpE,mEAAmE;AACnE,kEAAkE;AAClE,iBAAiB;AACjB,EAAE;AACF,qEAAqE;AACrE,mEAAmE;AACnE,sEAAsE;AACtE,iEAAiE;AACjE,wDAAwD;AACxD,EAAE;AACF,gEAAgE;AAChE,qEAAqE;AACrE,oEAAoE;AACpE,oBAAoB;AACpB,EAAE;AACF,oEAAoE;AACpE,kEAAkE;AAClE,iBAAiB;AACjB,EAAE;AACF,mEAAmE;AACnE,iEAAiE;AACjE,wBAAwB;AAExB;IACE,sBAAqB,MAAc,EACd,MAAc,EACd,eAAuB;QAFvB,WAAM,GAAN,MAAM,CAAQ;QACd,WAAM,GAAN,MAAM,CAAQ;QACd,oBAAe,GAAf,eAAe,CAAQ;IAAG,CAAC;IAClD,mBAAC;AAAD,CAAC,AAJD,IAIC;AAED;IACE,eAAqB,EAAgB;IACzB,mHAAmH;IAC1G,KAAe,EACjB,KAAiB,EACjB,GAAW,EACX,QAAgB,EAChB,OAAe;IACtB,uCAAuC;IAC9B,MAAgB,EAChB,UAAkB,EAClB,MAAoB;QAVpB,OAAE,GAAF,EAAE,CAAc;QAEhB,UAAK,GAAL,KAAK,CAAU;QACjB,UAAK,GAAL,KAAK,CAAY;QACjB,QAAG,GAAH,GAAG,CAAQ;QACX,aAAQ,GAAR,QAAQ,CAAQ;QAChB,YAAO,GAAP,OAAO,CAAQ;QAEb,WAAM,GAAN,MAAM,CAAU;QAChB,eAAU,GAAV,UAAU,CAAQ;QAClB,WAAM,GAAN,MAAM,CAAc;IAAG,CAAC;IAE7C,wBAAQ,GAAR;QACE,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAG,CAAC,IAAI,CAAC,EAAV,CAAU,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAA;IAC5F,CAAC;IAEM,WAAK,GAAZ,UAAa,MAAc,EAAE,eAAuB;QAClD,OAAO,IAAI,KAAK,CAAC,IAAI,YAAY,CAAC,MAAM,EAAE,EAAE,EAAE,eAAe,CAAC,EAC7C,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAA;IAC9D,CAAC;IAED,yBAAS,GAAT,UAAU,KAAiB,EAAE,KAAa;QACxC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QAC3E,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;IACpB,CAAC;IAED,sBAAM,GAAN,UAAO,MAAc;QACnB,IAAI,KAAK,GAAG,CAAC,MAAM,GAAG,iBAAiB,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,MAAM,IAAI,iBAAiB,CAAA;QAChF,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAA;YAClG,OAAM;SACP;QAED,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;QAChD,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;QAChC,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;QACvE,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC,GAAG,CAAC;YACxB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,GAAG,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC,eAAe,IAAI,KAAK,GAAG,CAAC,EAAE;YAC3F,IAAI,SAAS,GAAG,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA;YAC1E,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,GAAG,EAAE,EAAE,2BAA2B;gBAC1D,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,CAAC,CAAC,CAAA;aACxD;iBAAM,EAAE,2DAA2D;gBAClE,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;gBAC9B,OAAO,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,EAAE;oBACrD,2BAA2B;oBAC3B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;oBAC3C,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;oBAC/C,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;oBAC/C,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;oBAC/C,KAAK,IAAI,CAAC,CAAA;oBACV,KAAK,IAAI,CAAC,CAAA;iBACX;gBACD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,SAAS,CAAA;gBAC9B,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,KAAK,CAAA;gBAC9B,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAA;gBACjC,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,CAAA;aACnC;SACF;QACD,IAAI,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;QACtC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC,CAAA;QACnF,IAAI,KAAK,GAAG,CAAC;YAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAA;IACzC,CAAC;IAED,0BAAU,GAAV,UAAW,IAAY,EAAE,KAAa,EAAE,GAAW,EAAE,UAAc;QAAd,2BAAA,EAAA,cAAc;QACjE,IAAI,IAAI,IAAI,QAAQ,EAAE,EAAE,sCAAsC;YAC5D,IAAI,GAAG,GAAiB,IAAI,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;YACtD,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,MAAM,EAAE;gBAC1B,GAAG,GAAG,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAA;gBAC5C,GAAG,GAAG,GAAG,CAAC,MAAM,CAAA;aACjB;YACD,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,QAAQ;gBAC1C,CAAC,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC;gBAAE,OAAM;SAC3D;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,CAAC,CAAA;IAChD,CAAC;IAED,qBAAK,GAAL,UAAM,MAAc,EAAE,IAAY,EAAE,OAAe;QACjD,IAAI,MAAM,IAAI,CAAC,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;SACpB;aAAM,IAAI,MAAM,IAAI,WAAW,EAAE,EAAE,qBAAqB;YACvD,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAA;YACzB,IAAI,OAAO,GAAG,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,GAAG,WAAW,CAAC;gBACjD,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAA;YACpC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,EAAE,KAAK,CAAC,CAAA;YACrD,IAAI,IAAI,GAAG,WAAW;gBAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAC,CAAA;YACjE,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,CAAA,CAAC,WAAW;SACrE;aAAM,EAAE,UAAU;YACjB,IAAI,IAAI,GAAG,WAAW;gBAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAC,CAAA;YACzE,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAA;SACxB;IACH,CAAC;IAED,yBAAS,GAAT,UAAU,KAAW,EAAE,IAAgB;QACrC,IAAI,KAAK,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAA;QACrC,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE;YAC/C,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAC1B,KAAK,EAAE,CAAA;SACR;QACD,IAAI,KAAK,GAAG,IAAI,CAAC,QAAQ,CAAA;QACzB,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,QAAQ,GAAG,KAAK,GAAG,KAAK,CAAC,MAAM,CAAA;QAC/C,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QAC3B,IAAI,CAAC,OAAO,IAAI,CAAC,CAAA,CAAC,QAAQ;QAC1B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,YAAY,CAAC,CAAA;IACxD,CAAC;IAED,qBAAK,GAAL;QACE,IAAI,MAAM,GAAiB,IAAI,CAAA;QAC/B,IAAI,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAA;QAC9B,gEAAgE;QAChE,+DAA+D;QAC/D,kEAAkE;QAClE,4DAA4D;QAC5D,OAAO,GAAG,GAAG,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG;YAAE,GAAG,IAAI,CAAC,CAAA;QAC/D,IAAI,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,MAAM,CAAC,UAAU,GAAG,GAAG,CAAA;QACrE,uFAAuF;QACvF,OAAO,MAAM,IAAI,IAAI,IAAI,MAAM,CAAC,UAAU;YAAE,MAAM,GAAG,MAAM,CAAC,MAAM,CAAA;QAClE,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,QAAQ,EAChE,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAA;IACtD,CAAC;IAED,+BAAe,GAAf,UAAgB,IAAY,EAAE,OAAe;QAC3C,IAAI,IAAI,GAAG,WAAW;YAAE,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;QACrE,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;QAC/E,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAA;QACvB,IAAI,CAAC,OAAO,IAAI,iBAAiB,CAAA;IACnC,CAAC;IAED,wBAAQ,GAAR,UAAS,IAAY;QACnB,KAAK,IAAI,GAAG,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI;YACzC,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,aAAa,IAAI,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAA;YAC7E,IAAI,MAAM,GAAG,CAAC;gBAAE,OAAO,IAAI,CAAA;YAC3B,IAAI,MAAM,IAAI,CAAC;gBAAE,OAAO,KAAK,CAAA;YAC7B,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;SACnB;IACH,CAAC;IAED,0BAAU,GAAV,UAAW,IAAY;QACrB,iEAAiE;QACjE,4DAA4D;QAC5D,IAAI,OAAO,GAAoB,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,CAAA;QAC5D,KAAK,IAAI,GAAG,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE;YACpD,IAAI,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC;gBAAE,OAAO,IAAI,CAAA;YACzF,iCAAiC;YACjC,IAAI,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;YACtC,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,iBAAiB,CAAC,IAAI,CAAC;gBAAE,OAAO,KAAK,CAAA;YAC3F,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;YAClB,IAAI,CAAC,GAAG,EAAE,EAAE;gBACV,yCAAyC;gBACzC,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAA;qBACrB,IAAI,CAAC,IAAI,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;oBAAE,OAAO,KAAK,CAAA;gBAC/D,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;aACzB;SACF;IACH,CAAC;IAED,+BAAe,GAAf,UAAgB,IAAY,EAAE,OAAe;QAC3C,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAA;QAEvC,2DAA2D;QAC3D,uDAAuD;QACvD,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,CAAA;QAClD,MAAM,CAAC,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAA;QAC5B,MAAM,CAAC,OAAO,IAAI,iBAAiB,CAAA;QACnC,SAAS;YACP,SAAS;gBACP,IAAI,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC;oBAAE,OAAO,MAAM,CAAA;gBACvD,IAAI,OAAO,GAAG,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;gBACnD,IAAI,CAAC,OAAO;oBAAE,MAAK;gBACnB,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,CAAA;gBACpB,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,GAAG,CAAC,CAAA;gBACrD,MAAM,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,GAAG,CAAC,CAAA;aACtC;YAED,MAAM,CAAC,WAAW,EAAE,CAAA;SACrB;IACH,CAAC;IAED,2BAAW,GAAX;QACE,IAAI,MAAM,GAAG,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACjD,IAAI,MAAM,IAAI,CAAC,EAAE;YACf,kEAAkE;YAClE,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,YAAY,CAAA;YAChC,IAAI,MAAM,IAAI,CAAC;gBAAE,OAAO,KAAK,CAAA;YAC7B,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,CAAA;SAC9C;QACD,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QACnB,OAAO,IAAI,CAAA;IACb,CAAC;IAED,uBAAO,GAAP,UAAQ,KAAY;QAClB,OAAO,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAA;IACvE,CAAC;IAED,mBAAG,GAAH,UAAI,MAAe,EAAE,MAA0E;QAA1E,uBAAA,EAAA,SAAS,IAAI,CAAC,OAAO,GAAG,mBAAmB,IAAI,IAAI,CAAC,OAAO,GAAG,YAAY;QAC7F,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtC,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;YACrB,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,EAAE;gBAC5E,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;gBAC5H,IAAI,IAAI,GAAG,CAAC,EAAE;oBAAE,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;oBAAC,OAAO,IAAI,CAAA;iBAAE;qBAC1C,IAAI,IAAI,GAAG,CAAC;oBAAE,OAAO,KAAK,CAAA;aAChC;SACF;QAED,kBAAkB;QAClB,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QACjC,OAAO,KAAK,GAAG,CAAC,EAAE;YAChB,IAAI,WAAW,GAAG,KAAK,IAAI,CAAC,EAAE,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC,CAAA;YAC1D,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC;gBAAE,MAAK;YACpC,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAA;YACtB,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAA;YAC1B,KAAK,GAAG,WAAW,CAAA;SACpB;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAEM,UAAI,GAAX,UAAY,MAAe;QACzB,kBAAkB;QAClB,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE,WAAW,GAAG,MAAM,CAAC,GAAG,EAAG,CAAA;QAChD,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC;YAAE,OAAO,GAAG,CAAA;QAClC,MAAM,CAAC,CAAC,CAAC,GAAG,WAAW,CAAA;QACvB,KAAK,IAAI,KAAK,GAAG,CAAC,IAAI;YACpB,IAAI,UAAU,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAA;YACjC,IAAI,UAAU,IAAI,MAAM,CAAC,MAAM;gBAAE,MAAK;YACtC,IAAI,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;YAC9B,IAAI,UAAU,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;gBAChF,KAAK,GAAG,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAA;gBAC9B,UAAU,EAAE,CAAA;aACb;YACD,IAAI,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC;gBAAE,MAAK;YACzC,MAAM,CAAC,UAAU,CAAC,GAAG,WAAW,CAAA;YAChC,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAA;YACrB,KAAK,GAAG,UAAU,CAAA;SACnB;QACD,OAAO,GAAG,CAAA;IACZ,CAAC;IAED,sBAAM,GAAN;QACE,OAAO,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,CAAA;IAC5F,CAAC;IACH,YAAC;AAAD,CAAC,AAhPD,IAgPC;;AAED;IAIE,wBAAqB,KAAY;QAAZ,UAAK,GAAL,KAAK,CAAO;QAC/B,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAA;QACtB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,KAAK,CAAA;QACvB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAA;IAChC,CAAC;IAED,+BAAM,GAAN,UAAO,MAAc;QACnB,IAAI,IAAI,GAAG,MAAM,IAAI,iBAAiB,EAAE,KAAK,GAAG,CAAC,MAAM,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAA;QAChF,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK;gBAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAA;YAChE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;YACjC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAA;SACjB;aAAM;YACL,IAAI,CAAC,MAAM,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAA;SAC/B;QACD,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,CAAA;QAC/E,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAC9C,CAAC;IACH,qBAAC;AAAD,CAAC,AAtBD,IAsBC;AAED;IAGE,2BAAmB,KAAY,EAAS,GAAW,EAAS,KAAa;QAAtD,UAAK,GAAL,KAAK,CAAO;QAAS,QAAG,GAAH,GAAG,CAAQ;QAAS,UAAK,GAAL,KAAK,CAAQ;QACvE,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAA;QAC1B,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC;YAAE,IAAI,CAAC,SAAS,EAAE,CAAA;IACvC,CAAC;IAEM,wBAAM,GAAb,UAAc,KAAY;QACxB,OAAO,IAAI,iBAAiB,CAAC,KAAK,EAAE,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;IAClG,CAAC;IAED,qCAAS,GAAT;QACE,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAA;QAC5B,IAAI,IAAI,IAAI,IAAI,EAAE;YAChB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAA;YACpD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;YACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAA;SAC1B;IACH,CAAC;IAED,sBAAI,mCAAI;aAAR,cAAa,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IACjD,sBAAI,oCAAK;aAAT,cAAc,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAClD,sBAAI,kCAAG;aAAP,cAAY,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAChD,sBAAI,mCAAI;aAAR,cAAa,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAEjD,gCAAI,GAAJ;QACE,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA;QACf,IAAI,CAAC,GAAG,IAAI,CAAC,CAAA;QACb,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC;YAAE,IAAI,CAAC,SAAS,EAAE,CAAA;IACvC,CAAC;IAED,gCAAI,GAAJ;QACE,OAAO,IAAI,iBAAiB,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,CAAC,CAAA;IAChE,CAAC;IACH,wBAAC;AAAD,CAAC,AAnCD,IAmCC\"}","dts":{"name":"/home/marijn/src/lezer/lezer/stack.d.ts","writeByteOrderMark":false,"text":"import { ParseState } from \"./state\";\nimport { Parser } from \"./parse\";\nimport { Tree } from \"lezer-tree\";\nexport declare const BADNESS_WILD = 150;\ndeclare class StackContext {\n    readonly parser: Parser;\n    readonly reused: Tree[];\n    readonly maxBufferLength: number;\n    constructor(parser: Parser, reused: Tree[], maxBufferLength: number);\n}\nexport declare class Stack {\n    readonly cx: StackContext;\n    readonly stack: number[];\n    state: ParseState;\n    pos: number;\n    inputPos: number;\n    badness: number;\n    readonly buffer: number[];\n    readonly bufferBase: number;\n    readonly parent: Stack | null;\n    constructor(cx: StackContext, stack: number[], state: ParseState, pos: number, inputPos: number, badness: number, buffer: number[], bufferBase: number, parent: Stack | null);\n    toString(): string;\n    static start(parser: Parser, maxBufferLength: number): Stack;\n    pushState(state: ParseState, start: number): void;\n    reduce(action: number): void;\n    shiftValue(term: number, start: number, end: number, childCount?: number): void;\n    apply(action: number, next: number, nextEnd: number): void;\n    useCached(value: Tree, next: ParseState): void;\n    split(): Stack;\n    recoverByDelete(next: number, nextEnd: number): void;\n    canShift(term: number): boolean;\n    canRecover(next: number): boolean;\n    recoverByInsert(next: number, nextEnd: number): Stack | null;\n    forceReduce(): boolean;\n    compare(other: Stack): number;\n    put(parses: Stack[], strict?: boolean): boolean;\n    static take(parses: Stack[]): Stack;\n    toTree(): Tree;\n}\nexport {};\n"}}

{"code":"import { __extends } from \"tslib\";\nimport { Stack } from \"./stack\";\nimport { Token, StringStream, TokenGroup } from \"./token\";\nimport { DefaultBufferLength, Tree, TreeBuffer, NodeGroup, NodeType, NodeProp } from \"lezer-tree\";\nimport { decodeArray } from \"./decode\";\n// Environment variable used to control console output\nvar verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nvar CacheCursor = /** @class */ (function () {\n    function CacheCursor(tree) {\n        this.start = [0];\n        this.index = [0];\n        this.nextStart = 0;\n        this.trees = [tree];\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    CacheCursor.prototype.nodeAt = function (pos) {\n        if (pos < this.nextStart)\n            return null;\n        for (;;) {\n            var last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextStart = 1e9;\n                return null;\n            }\n            var top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            var next = top.children[index];\n            var start = this.start[last] + top.positions[index];\n            if (start >= pos)\n                return start == pos ? next : null;\n            if (next instanceof TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    };\n    return CacheCursor;\n}());\nvar CachedToken = /** @class */ (function (_super) {\n    __extends(CachedToken, _super);\n    function CachedToken() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.extended = -1;\n        _this.mask = 0;\n        return _this;\n    }\n    CachedToken.prototype.clear = function (start) {\n        this.start = start;\n        this.value = this.extended = -1;\n    };\n    return CachedToken;\n}(Token));\nvar dummyToken = new Token;\nvar TokenCache = /** @class */ (function () {\n    function TokenCache(parser) {\n        this.tokens = [];\n        this.mainToken = dummyToken;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(function (_) { return new CachedToken; });\n    }\n    TokenCache.prototype.getActions = function (stack, input) {\n        var actionIndex = 0;\n        var main = null;\n        var parser = stack.cx.parser, tokenizers = parser.tokenizers;\n        var mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        for (var i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            var tokenizer = tokenizers[i], token = this.tokens[i];\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask) {\n                this.updateCachedToken(token, tokenizer, stack, input);\n                token.mask = mask;\n            }\n            var startIndex = actionIndex;\n            if (token.extended > -1)\n                actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n            actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n            if (actionIndex > startIndex) {\n                main = token;\n                break;\n            }\n            if (!main || token.value != 0 /* Err */)\n                main = token;\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (!main) {\n            main = dummyToken;\n            main.start = stack.pos;\n            if (stack.pos == input.length)\n                main.accept(stack.cx.parser.eofTerm, stack.pos);\n            else\n                main.accept(0 /* Err */, stack.pos + 1);\n        }\n        this.mainToken = main;\n        return this.actions;\n    };\n    TokenCache.prototype.updateCachedToken = function (token, tokenizer, stack, input) {\n        token.clear(stack.pos);\n        tokenizer.token(input, token, stack);\n        if (token.value > -1) {\n            var parser = stack.cx.parser;\n            var specIndex = findOffset(parser.data, parser.specializeTable, token.value);\n            if (specIndex >= 0) {\n                var found = parser.specializations[specIndex][input.read(token.start, token.end)];\n                if (found != null) {\n                    if ((found & 1) == 0 /* Specialize */)\n                        token.value = found >> 1;\n                    else\n                        token.extended = found >> 1;\n                }\n            }\n        }\n        else if (stack.pos == input.length) {\n            token.accept(stack.cx.parser.eofTerm, stack.pos);\n        }\n        else {\n            token.accept(0 /* Err */, stack.pos + 1);\n        }\n    };\n    TokenCache.prototype.putAction = function (action, token, end, index) {\n        // Don't add duplicate actions\n        for (var i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    };\n    TokenCache.prototype.addActions = function (stack, token, end, index) {\n        var state = stack.state, parser = stack.cx.parser, data = parser.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == token || (next == 0 /* Err */ && index == 0))\n                    index = this.putAction(data[i + 1] | (data[i + 2] << 16), token, end, index);\n            }\n        }\n        return index;\n    };\n    return TokenCache;\n}());\nvar StackContext = /** @class */ (function () {\n    function StackContext(parser, maxBufferLength, input, parent, wrapType // Set to -2 when a stack descending from this nesting event finishes\n    ) {\n        if (parent === void 0) { parent = null; }\n        if (wrapType === void 0) { wrapType = -1; }\n        this.parser = parser;\n        this.maxBufferLength = maxBufferLength;\n        this.input = input;\n        this.parent = parent;\n        this.wrapType = wrapType;\n        this.reused = [];\n        this.tokens = new TokenCache(parser);\n    }\n    return StackContext;\n}());\nexport { StackContext };\nvar recoverDist = 5, maxRemainingPerStep = 3, minBufferLengthPrune = 200, forceReduceLimit = 10;\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nvar ParseContext = /** @class */ (function () {\n    /// @internal\n    function ParseContext(parser, input, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? undefined : _c, _d = _b.strict, strict = _d === void 0 ? false : _d, _e = _b.bufferLength, bufferLength = _e === void 0 ? DefaultBufferLength : _e;\n        // The position to which the parse has advanced.\n        this.pos = 0;\n        this.recovering = 0;\n        this.tokenCount = 0;\n        this.stacks = [Stack.start(new StackContext(parser, bufferLength, input))];\n        this.strict = strict;\n        this.cache = cache ? new CacheCursor(cache) : null;\n    }\n    /// @internal\n    ParseContext.prototype.putStack = function (stack) {\n        this.stacks.push(stack);\n        if (this.pos < 0 || stack.pos < this.pos)\n            this.pos = stack.pos;\n    };\n    /// Move the parser forward. This will process all parse stacks at\n    /// `this.pos` and try to advance them to a further position. If no\n    /// stack for such a position is found, it'll start error-recovery.\n    ///\n    /// When the parse is finished, this will return a syntax tree. When\n    /// not, it returns `null`.\n    ParseContext.prototype.advance = function () {\n        var stacks = this.stacks, pos = this.pos;\n        // This will now hold stacks beyond `pos`.\n        this.stacks = [];\n        // Will be reset to the next position by `putStack`.\n        this.pos = -1;\n        var stopped = null, stoppedTokens = null;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (var i = 0; i < stacks.length; i++) {\n            var stack = stacks[i];\n            for (;;) {\n                if (stack.pos > pos) {\n                    this.putStack(stack);\n                }\n                else {\n                    var result = this.advanceStack(stack, stacks);\n                    if (result) {\n                        stack = result;\n                        continue;\n                    }\n                    else {\n                        if (!stopped) {\n                            stopped = [];\n                            stoppedTokens = [];\n                        }\n                        stopped.push(stack);\n                        var tok = stack.cx.tokens.mainToken;\n                        stoppedTokens.push(tok.value, tok.end);\n                    }\n                }\n                break;\n            }\n        }\n        if (!this.stacks.length) {\n            var finished = stopped && findFinished(stopped);\n            if (finished)\n                return finished.toTree();\n            if (this.strict)\n                throw new SyntaxError(\"No parse at \" + pos);\n            if (!this.recovering)\n                this.recovering = recoverDist;\n        }\n        if (this.recovering && stopped) {\n            var finished = this.runRecovery(stopped, stoppedTokens);\n            if (finished)\n                return finished.forceAll().toTree();\n        }\n        if (this.recovering) {\n            var maxRemaining = this.recovering == 1 ? 1 : this.recovering * maxRemainingPerStep;\n            if (this.stacks.length > maxRemaining) {\n                this.stacks.sort(function (a, b) { return a.recovered - b.recovered; });\n                this.stacks.length = maxRemaining;\n            }\n            if (this.stacks.some(function (s) { return s.reducePos > pos; }))\n                this.recovering--;\n        }\n        else if (this.stacks.length > 1 && this.stacks[0].buffer.length > minBufferLengthPrune) {\n            // Prune stacks that have been running without splitting for a\n            // while, to avoid getting stuck with multiple successful stacks\n            // running endlessly on.\n            var minLen = 1e9, minI = -1;\n            for (var i = 0; i < this.stacks.length; i++) {\n                var stack = this.stacks[i];\n                if (stack.buffer.length < minLen) {\n                    minLen = stack.buffer.length;\n                    minI = i;\n                }\n            }\n            if (minLen > minBufferLengthPrune)\n                this.stacks.splice(minI, 1);\n        }\n        this.tokenCount++;\n        return null;\n    };\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` is given, stacks split\n    // off by ambiguous operations will be pushed to that, or given to\n    // `putStack` if they move `pos` forward.\n    ParseContext.prototype.advanceStack = function (stack, split) {\n        var start = stack.pos, _a = stack.cx, input = _a.input, parser = _a.parser;\n        var base = verbose ? stack + \" -> \" : \"\";\n        if (this.cache) {\n            for (var cached = this.cache.nodeAt(start); cached;) {\n                var match = parser.group.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + stack + (\" (via reuse of \" + parser.getName(cached.type.id) + \")\"));\n                    return stack;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                var inner = cached.children[0];\n                if (inner instanceof Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        var nest = parser.startNested(stack.state);\n        maybeNest: if (nest > -1) {\n            var _b = parser.nested[nest], grammar = _b.grammar, endToken = _b.end, placeholder = _b.placeholder;\n            var filterEnd = undefined, parseNode = null, nested = void 0, wrapType = undefined;\n            if (typeof grammar == \"function\") {\n                var query = grammar(input, stack);\n                if (query.stay)\n                    break maybeNest;\n                (parseNode = query.parseNode, nested = query.parser, filterEnd = query.filterEnd, wrapType = query.wrapType);\n            }\n            else {\n                nested = grammar;\n            }\n            var end = this.scanForNestEnd(stack, endToken, filterEnd);\n            var clippedInput = stack.cx.input.clip(end);\n            if (parseNode || !nested) {\n                var node = parseNode ? parseNode(clippedInput, stack.pos) : Tree.empty;\n                if (node.length != end - stack.pos)\n                    node = new Tree(node.type, node.children, node.positions, end - stack.pos);\n                if (wrapType != null)\n                    node = new Tree(parser.group.types[wrapType], [node], [0], node.length);\n                stack.useNode(node, parser.getGoto(stack.state, placeholder, true));\n                return stack;\n            }\n            else {\n                var newStack = Stack.start(new StackContext(nested, stack.cx.maxBufferLength, clippedInput, stack, wrapType), stack.pos);\n                if (verbose)\n                    console.log(base + newStack + \" (nested)\");\n                return newStack;\n            }\n        }\n        var defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + stack + (\" (via always-reduce \" + parser.getName(defaultReduce & 65535 /* ValueMask */) + \")\"));\n            return stack;\n        }\n        var actions = stack.cx.tokens.getActions(stack, input);\n        for (var i = 0; i < actions.length;) {\n            var action = actions[i++], term = actions[i++], end = actions[i++];\n            var last = i == actions.length || !split;\n            var localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + localStack + (\" (via \" + ((action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : \"reduce of \" + parser.getName(action & 65535 /* ValueMask */)) + \" for \" + parser.getName(term) + \" @ \" + start + (localStack == stack ? \"\" : \", split\") + \")\"));\n            if (last)\n                return localStack;\n            else if (localStack.pos > start)\n                this.putStack(localStack);\n            else\n                split.push(localStack);\n        }\n        if (stack.cx.parent && stack.pos == input.length)\n            return finishNested(stack);\n        return null;\n    };\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `putStack`.\n    ParseContext.prototype.advanceFully = function (stack) {\n        var pos = stack.pos;\n        for (;;) {\n            var result = this.advanceStack(stack, null);\n            if (!result)\n                return stack;\n            if (result.pos > pos) {\n                this.putStack(result);\n                return null;\n            }\n            stack = result;\n        }\n    };\n    ParseContext.prototype.runRecovery = function (stacks, tokens) {\n        var finished = null;\n        for (var i = 0; i < stacks.length; i++) {\n            var stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            var base = verbose ? stack + \" -> \" : \"\";\n            var force = stack.split(), forceBase = base;\n            for (var j = 0; force.forceReduce() && j < forceReduceLimit; j++) {\n                if (verbose)\n                    console.log(forceBase + force + \" (via force-reduce)\");\n                var stopped = this.advanceFully(force);\n                if (!stopped)\n                    break;\n                force = stopped;\n                if (verbose)\n                    forceBase = stopped + \" -> \";\n            }\n            for (var _i = 0, _a = stack.recoverByInsert(token); _i < _a.length; _i++) {\n                var insert = _a[_i];\n                if (verbose)\n                    console.log(base + insert + \" (via recover-insert)\");\n                this.advanceFully(insert);\n            }\n            if (stack.cx.input.length > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + stack + (\" (via recover-delete \" + stack.cx.parser.getName(token) + \")\"));\n                this.putStack(stack);\n            }\n            else if (!stack.cx.parent && (!finished || finished.recovered > stack.recovered)) {\n                finished = stack;\n            }\n        }\n        return finished;\n    };\n    /// Force the parse to finish, generating a tree containing the nodes\n    /// parsed so far.\n    ParseContext.prototype.forceFinish = function () {\n        return this.stacks[0].split().forceAll().toTree();\n    };\n    Object.defineProperty(ParseContext.prototype, \"badness\", {\n        /// A value that indicates how successful the parse is so far, as\n        /// the number of error-recovery steps taken divided by the number\n        /// of tokens parsed. Could be used to decide to abort a parse when\n        /// the input doesn't appear to match the grammar at all.\n        get: function () {\n            return this.stacks[0].recovered * 2 /* Token */ / this.tokenCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ParseContext.prototype.scanForNestEnd = function (stack, endToken, filter) {\n        var input = stack.cx.input;\n        for (var pos = stack.pos; pos < input.length; pos++) {\n            dummyToken.start = pos;\n            dummyToken.value = -1;\n            endToken.token(input, dummyToken, stack);\n            if (dummyToken.value > -1 && (!filter || filter(input.read(pos, dummyToken.end))))\n                return pos;\n        }\n        return input.length;\n    };\n    return ParseContext;\n}());\nexport { ParseContext };\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nvar Parser = /** @class */ (function () {\n    /// @internal\n    function Parser(\n    /// The parse states for this grammar @internal\n    states, \n    /// A blob of data that the parse states, as well as some\n    /// of `Parser`'s fields, point into @internal\n    data, \n    /// The goto table. See `computeGotoTable` in\n    /// lezer-generator for details on the format @internal\n    goto, \n    /// A node group with the node types used by this parser.\n    group, \n    /// The first repeat-related term id @internal\n    minRepeatTerm, \n    /// The tokenizer objects used by the grammar @internal\n    tokenizers, \n    /// Metadata about nested grammars used in this grammar @internal\n    nested, \n    /// Points into this.data at an array of token types that\n    /// are specialized @internal\n    specializeTable, \n    /// For each specialized token type, this holds an object mapping\n    /// names to numbers, with the first bit indicating whether the\n    /// specialization extends or replaces the original token, and the\n    /// rest of the bits holding the specialized token type. @internal\n    specializations, \n    /// Points into this.data at an array that holds the\n    /// precedence order (higher precedence first) for ambiguous\n    /// tokens @internal\n    tokenPrecTable, \n    /// An optional object mapping term ids to name strings @internal\n    termNames) {\n        if (termNames === void 0) { termNames = null; }\n        this.states = states;\n        this.data = data;\n        this.goto = goto;\n        this.group = group;\n        this.minRepeatTerm = minRepeatTerm;\n        this.tokenizers = tokenizers;\n        this.nested = nested;\n        this.specializeTable = specializeTable;\n        this.specializations = specializations;\n        this.tokenPrecTable = tokenPrecTable;\n        this.termNames = termNames;\n        this.nextStateCache = [];\n        this.maxNode = this.group.types.length - 1;\n        this.maxRepeatWrap = this.group.types.length + (this.group.types.length - minRepeatTerm) - 1;\n        for (var i = 0, l = this.states.length / 6 /* Size */; i < l; i++)\n            this.nextStateCache[i] = null;\n    }\n    /// Parse a given string or stream.\n    Parser.prototype.parse = function (input, options) {\n        if (typeof input == \"string\")\n            input = new StringStream(input);\n        var cx = new ParseContext(this, input, options);\n        for (;;) {\n            var done = cx.advance();\n            if (done)\n                return done;\n        }\n    };\n    /// Create a `ParseContext`.\n    Parser.prototype.startParse = function (input, options) {\n        if (typeof input == \"string\")\n            input = new StringStream(input);\n        return new ParseContext(this, input, options);\n    };\n    /// Get a goto table entry @internal\n    Parser.prototype.getGoto = function (state, term, loose) {\n        if (loose === void 0) { loose = false; }\n        var table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (var pos = table[term + 1];;) {\n            var groupTag = table[pos++], last = groupTag & 1;\n            var target = table[pos++];\n            if (last && loose)\n                return target;\n            for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    };\n    /// Check if this state has an action for a given terminal @internal\n    Parser.prototype.hasAction = function (state, terminal) {\n        var data = this.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == terminal || next == 0 /* Err */)\n                    return data[i + 1] | (data[i + 2] << 16);\n            }\n        }\n        return 0;\n    };\n    /// @internal\n    Parser.prototype.stateSlot = function (state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    };\n    /// @internal\n    Parser.prototype.stateFlag = function (state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    };\n    /// @internal\n    Parser.prototype.startNested = function (state) {\n        var flags = this.stateSlot(state, 0 /* Flags */);\n        return flags & 4 /* StartNest */ ? flags >> 10 /* NestShift */ : -1;\n    };\n    /// @internal\n    Parser.prototype.validAction = function (state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (var i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */)\n                return false;\n            if (action == (this.data[i + 1] | (this.data[i + 2] << 16)))\n                return true;\n        }\n    };\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    Parser.prototype.nextStates = function (state) {\n        var cached = this.nextStateCache[state];\n        if (cached)\n            return cached;\n        var result = [];\n        for (var i = this.stateSlot(state, 1 /* Actions */); this.data[i] != 65535 /* End */; i += 3) {\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0 && !result.includes(this.data[i + 1]))\n                result.push(this.data[i + 1]);\n        }\n        var table = this.goto, max = table[0];\n        for (var term = 0; term < max; term++) {\n            for (var pos = table[term + 1];;) {\n                var groupTag = table[pos++], target = table[pos++];\n                for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                    if (table[pos] == state && !result.includes(target))\n                        result.push(target);\n                if (groupTag & 1)\n                    break;\n            }\n        }\n        return this.nextStateCache[state] = result;\n    };\n    /// @internal\n    Parser.prototype.overrides = function (token, prev) {\n        var iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    };\n    /// Create a new `Parser` instance with different values for (some\n    /// of) the nested grammars. This can be used to, for example, swap\n    /// in a different language for a nested grammar or fill in a nested\n    /// grammar that was left blank by the original grammar.\n    Parser.prototype.withNested = function (spec) {\n        return new Parser(this.states, this.data, this.goto, this.group, this.minRepeatTerm, this.tokenizers, this.nested.map(function (obj) {\n            if (!Object.prototype.hasOwnProperty.call(spec, obj.name))\n                return obj;\n            return { name: obj.name, grammar: spec[obj.name], end: obj.end, placeholder: obj.placeholder };\n        }), this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames);\n    };\n    /// Create a new `Parser` instance whose node types have the given\n    /// props added. You should use [`NodeProp.add`](#tree.NodeProp.add)\n    /// to create the arguments to this method.\n    Parser.prototype.withProps = function () {\n        var _a;\n        var props = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            props[_i] = arguments[_i];\n        }\n        return new Parser(this.states, this.data, this.goto, (_a = this.group).extend.apply(_a, props), this.minRepeatTerm, this.tokenizers, this.nested, this.specializeTable, this.specializations, this.tokenPrecTable, this.termNames);\n    };\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    Parser.prototype.getName = function (term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.group.types[term].name || term);\n    };\n    Object.defineProperty(Parser.prototype, \"eofTerm\", {\n        /// The eof term id is always allocated directly after the node\n        /// types. @internal\n        get: function () { return this.maxRepeatWrap + 1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Parser.prototype, \"hasNested\", {\n        /// Tells you whether this grammar has any nested grammars.\n        get: function () { return this.nested.length > 0; },\n        enumerable: true,\n        configurable: true\n    });\n    /// (Used by the output of the parser generator) @internal\n    Parser.deserialize = function (spec) {\n        var tokenArray = decodeArray(spec.tokenData);\n        var nodeNames = spec.nodeNames.split(\" \"), minRepeatTerm = nodeNames.length;\n        for (var i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        var nodeProps = [];\n        for (var i = 0; i < nodeNames.length; i++)\n            nodeProps.push(noProps);\n        function setProp(nodeID, prop, value) {\n            if (nodeProps[nodeID] == noProps)\n                nodeProps[nodeID] = Object.create(null);\n            prop.set(nodeProps[nodeID], prop.deserialize(value));\n        }\n        setProp(0, NodeProp.error, \"\");\n        if (spec.nodeProps)\n            for (var _i = 0, _a = spec.nodeProps; _i < _a.length; _i++) {\n                var propSpec = _a[_i];\n                var prop = propSpec[0];\n                for (var i = 1; i < propSpec.length; i += 2)\n                    setProp(propSpec[i], prop, propSpec[i + 1]);\n            }\n        var group = new NodeGroup(nodeNames.map(function (name, i) { return new NodeType(name, nodeProps[i], i); }));\n        return new Parser(decodeArray(spec.states, Uint32Array), decodeArray(spec.stateData), decodeArray(spec.goto), group, minRepeatTerm, spec.tokenizers.map(function (value) { return typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value; }), (spec.nested || []).map(function (_a) {\n            var name = _a[0], grammar = _a[1], endToken = _a[2], placeholder = _a[3];\n            return ({ name: name, grammar: grammar, end: new TokenGroup(decodeArray(endToken), 0), placeholder: placeholder });\n        }), spec.specializeTable, (spec.specializations || []).map(withoutPrototype), spec.tokenPrec, spec.termNames);\n    };\n    return Parser;\n}());\nexport { Parser };\nvar noProps = Object.create(null);\nfunction findOffset(data, start, term) {\n    for (var i = start, next = void 0; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\n// Strip the prototypes from objects, so that they can safely be\n// accessed as maps.\nfunction withoutPrototype(obj) {\n    if (!(obj instanceof Object))\n        return obj;\n    var result = Object.create(null);\n    for (var prop in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, prop))\n            result[prop] = obj[prop];\n    return result;\n}\nfunction findFinished(stacks) {\n    var best = null;\n    for (var _i = 0, stacks_1 = stacks; _i < stacks_1.length; _i++) {\n        var stack = stacks_1[_i];\n        if (stack.pos == stack.cx.input.length &&\n            stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.recovered > stack.recovered))\n            best = stack;\n    }\n    return best;\n}\nfunction finishNested(stack) {\n    if (stack.cx.wrapType == -2)\n        return null; // Another nested stack already finished\n    var parent = stack.cx.parent, tree = stack.forceAll().toTree();\n    var parentParser = parent.cx.parser, info = parentParser.nested[parentParser.startNested(parent.state)];\n    tree = new Tree(tree.type, tree.children, tree.positions.map(function (p) { return p - parent.pos; }), stack.pos - parent.pos);\n    if (stack.cx.wrapType > -1)\n        tree = new Tree(parentParser.group.types[stack.cx.wrapType], [tree], [0], tree.length);\n    stack.cx.wrapType = -2;\n    parent.useNode(tree, parentParser.getGoto(parent.state, info.placeholder, true));\n    if (verbose)\n        console.log(parent + (\" (via unnest \" + (stack.cx.wrapType > -1 ? parentParser.getName(stack.cx.wrapType) : tree.type.name) + \")\"));\n    return parent;\n}\n//# sourceMappingURL=parse.js.map","map":"{\"version\":3,\"file\":\"parse.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/parse.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/parse.d.ts","writeByteOrderMark":false,"text":"import { Stack } from \"./stack\";\nimport { InputStream, Token, Tokenizer, TokenGroup } from \"./token\";\nimport { Tree, TreeBuffer, NodeGroup, NodeProp, NodePropSource } from \"lezer-tree\";\nexport declare type NestedGrammar = null | Parser | ((input: InputStream, stack: Stack) => NestedGrammarSpec);\nexport interface NestedGrammarSpec {\n    parser?: Parser;\n    stay?: boolean;\n    parseNode?: (input: InputStream, start: number) => Tree;\n    wrapType?: number;\n    filterEnd?: (endToken: string) => boolean;\n}\ndeclare class CachedToken extends Token {\n    extended: number;\n    mask: number;\n    clear(start: number): void;\n}\ndeclare class TokenCache {\n    tokens: CachedToken[];\n    mainToken: Token;\n    actions: number[];\n    constructor(parser: Parser);\n    getActions(stack: Stack, input: InputStream): number[];\n    updateCachedToken(token: CachedToken, tokenizer: Tokenizer, stack: Stack, input: InputStream): void;\n    putAction(action: number, token: number, end: number, index: number): number;\n    addActions(stack: Stack, token: number, end: number, index: number): number;\n}\nexport interface ParseOptions {\n    cache?: Tree;\n    strict?: boolean;\n    bufferLength?: number;\n}\nexport declare class StackContext {\n    readonly parser: Parser;\n    readonly maxBufferLength: number;\n    readonly input: InputStream;\n    readonly parent: Stack | null;\n    wrapType: number;\n    reused: (Tree | TreeBuffer)[];\n    tokens: TokenCache;\n    constructor(parser: Parser, maxBufferLength: number, input: InputStream, parent?: Stack | null, wrapType?: number);\n}\nexport declare class ParseContext {\n    private stacks;\n    pos: number;\n    private recovering;\n    private tokenCount;\n    private cache;\n    private strict;\n    constructor(parser: Parser, input: InputStream, { cache, strict, bufferLength }?: ParseOptions);\n    putStack(stack: Stack): void;\n    advance(): Tree;\n    private advanceStack;\n    private advanceFully;\n    private runRecovery;\n    forceFinish(): Tree;\n    get badness(): number;\n    private scanForNestEnd;\n}\nexport declare class Parser {\n    readonly states: Readonly<Uint32Array>;\n    readonly data: Readonly<Uint16Array>;\n    readonly goto: Readonly<Uint16Array>;\n    readonly group: NodeGroup;\n    readonly minRepeatTerm: number;\n    readonly tokenizers: readonly Tokenizer[];\n    readonly nested: readonly {\n        name: string;\n        grammar: NestedGrammar;\n        end: TokenGroup;\n        placeholder: number;\n    }[];\n    readonly specializeTable: number;\n    readonly specializations: readonly {\n        [value: string]: number;\n    }[];\n    readonly tokenPrecTable: number;\n    readonly termNames: null | {\n        [id: number]: string;\n    };\n    maxNode: number;\n    maxRepeatWrap: number;\n    private nextStateCache;\n    constructor(states: Readonly<Uint32Array>, data: Readonly<Uint16Array>, goto: Readonly<Uint16Array>, group: NodeGroup, minRepeatTerm: number, tokenizers: readonly Tokenizer[], nested: readonly {\n        name: string;\n        grammar: NestedGrammar;\n        end: TokenGroup;\n        placeholder: number;\n    }[], specializeTable: number, specializations: readonly {\n        [value: string]: number;\n    }[], tokenPrecTable: number, termNames?: null | {\n        [id: number]: string;\n    });\n    parse(input: InputStream | string, options?: ParseOptions): Tree;\n    startParse(input: InputStream | string, options?: ParseOptions): ParseContext;\n    getGoto(state: number, term: number, loose?: boolean): number;\n    hasAction(state: number, terminal: number): number;\n    stateSlot(state: number, slot: number): number;\n    stateFlag(state: number, flag: number): boolean;\n    startNested(state: number): number;\n    validAction(state: number, action: number): boolean;\n    nextStates(state: number): readonly number[];\n    overrides(token: number, prev: number): boolean;\n    withNested(spec: {\n        [name: string]: NestedGrammar | null;\n    }): Parser;\n    withProps(...props: NodePropSource[]): Parser;\n    getName(term: number): string;\n    get eofTerm(): number;\n    get hasNested(): boolean;\n    static deserialize(spec: {\n        states: string;\n        stateData: string;\n        goto: string;\n        nodeNames: string;\n        repeatNodeCount: number;\n        nodeProps?: [NodeProp<any>, ...(string | number)[]][];\n        tokenData: string;\n        tokenizers: (Tokenizer | number)[];\n        nested?: [string, null | NestedGrammar, string, number][];\n        specializeTable: number;\n        specializations?: readonly {\n            [term: string]: number;\n        }[];\n        tokenPrec: number;\n        termNames?: {\n            [id: number]: string;\n        };\n    }): Parser;\n}\nexport {};\n"}}

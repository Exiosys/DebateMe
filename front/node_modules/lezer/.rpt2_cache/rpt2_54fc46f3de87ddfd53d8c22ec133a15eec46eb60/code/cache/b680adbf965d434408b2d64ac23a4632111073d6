{"code":"import { Stack } from \"./stack\";\nimport { ParseState } from \"./state\";\nimport { StringStream, TokenGroup } from \"./token\";\nimport { DefaultBufferLength, grammarID, termID, Tree, TreeBuffer, TagMap } from \"lezer-tree\";\nimport { decodeArray } from \"./decode\";\nvar verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nvar CacheCursor = /** @class */ (function () {\n    function CacheCursor(tree) {\n        this.start = [0];\n        this.index = [0];\n        this.nextStart = 0;\n        this.trees = [tree];\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    CacheCursor.prototype.nodeAt = function (pos) {\n        if (pos < this.nextStart)\n            return null;\n        for (;;) {\n            var last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextStart = 1e9;\n                return null;\n            }\n            var top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            var next = top.children[index];\n            var start = this.start[last] + top.positions[index];\n            if (next instanceof TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else if (start >= pos) {\n                return start == pos ? next : null;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    };\n    return CacheCursor;\n}());\nvar CachedToken = /** @class */ (function () {\n    function CachedToken(tokenizer) {\n        this.tokenizer = tokenizer;\n        this.start = -1;\n        this.end = -1;\n        this.term = -1;\n        this.extended = -1;\n    }\n    CachedToken.prototype.asError = function (pos, eof) {\n        this.start = pos;\n        if (pos == eof) {\n            this.term = 0 /* Eof */;\n            this.end = pos;\n        }\n        else {\n            this.term = 1 /* Err */;\n            this.end = pos + 1;\n        }\n        return this;\n    };\n    return CachedToken;\n}());\nvar dummyToken = new CachedToken(null);\nvar TokenCache = /** @class */ (function () {\n    function TokenCache() {\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n    }\n    TokenCache.prototype.getActions = function (stack, input) {\n        var actionIndex = 0;\n        var main = null;\n        var tokenizers = stack.cx.parser.tokenizers;\n        var _loop_1 = function (i) {\n            if (((1 << i) & stack.state.tokenizerMask) == 0)\n                return \"continue\";\n            var tokenizer = tokenizers[i];\n            var token = this_1.tokens.find(function (c) { return c.tokenizer == tokenizer; });\n            if (!token)\n                this_1.tokens.push(token = new CachedToken(tokenizer));\n            if (tokenizer.contextual || token.start != stack.inputPos)\n                this_1.updateCachedToken(token, stack, input);\n            var startIndex = actionIndex;\n            if (token.extended > -1)\n                actionIndex = this_1.addActions(stack, token.extended, token.end, actionIndex);\n            actionIndex = this_1.addActions(stack, token.term, token.end, actionIndex);\n            if (actionIndex > startIndex) {\n                main = token;\n                return \"break\";\n            }\n            if (!main || token.term != 1 /* Err */)\n                main = token;\n        };\n        var this_1 = this;\n        for (var i = 0; i < tokenizers.length; i++) {\n            var state_1 = _loop_1(i);\n            if (state_1 === \"break\")\n                break;\n        }\n        if (this.actions.length > actionIndex)\n            this.actions.length = actionIndex;\n        this.mainToken = main || dummyToken.asError(stack.inputPos, input.length);\n        return this.actions;\n    };\n    TokenCache.prototype.updateCachedToken = function (token, stack, input) {\n        token.extended = -1;\n        token.tokenizer.token(input.goto(stack.inputPos), stack);\n        if (input.token > -1) {\n            token.start = stack.inputPos;\n            token.end = input.tokenEnd;\n            token.term = input.token;\n            var parser = stack.cx.parser;\n            var specIndex = findOffset(parser.data, parser.specializeTable, token.term);\n            if (specIndex >= 0) {\n                var found = parser.specializations[specIndex][input.read(token.start, token.end)];\n                if (found != null) {\n                    if ((found & 1) == 0 /* Specialize */)\n                        token.term = found >> 1;\n                    else\n                        token.extended = found >> 1;\n                }\n            }\n        }\n        else {\n            token.asError(stack.inputPos, input.length);\n        }\n    };\n    TokenCache.prototype.putAction = function (action, token, end, index) {\n        // Don't add duplicate actions\n        for (var i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    };\n    TokenCache.prototype.addActions = function (stack, token, end, index) {\n        var state = stack.state, data = stack.cx.parser.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = set ? state.skip : state.actions, next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == token || (next == 1 /* Err */ && index == 0))\n                    index = this.putAction(data[i + 1] | (data[i + 2] << 16), token, end, index);\n            }\n        }\n        return index;\n    };\n    return TokenCache;\n}());\nvar StackContext = /** @class */ (function () {\n    function StackContext(parser, maxBufferLength, input, parent) {\n        if (parent === void 0) { parent = null; }\n        this.parser = parser;\n        this.maxBufferLength = maxBufferLength;\n        this.input = input;\n        this.parent = parent;\n        this.reused = [];\n        this.tokens = new TokenCache;\n    }\n    return StackContext;\n}());\nexport { StackContext };\nvar ParseContext = /** @class */ (function () {\n    // @internal\n    function ParseContext(parser, input, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? null : _c, _d = _b.strict, strict = _d === void 0 ? false : _d, _e = _b.bufferLength, bufferLength = _e === void 0 ? DefaultBufferLength : _e;\n        this.reused = [];\n        this.stacks = [Stack.start(new StackContext(parser, bufferLength, input))];\n        this.strict = strict;\n        this.cache = cache ? new CacheCursor(cache) : null;\n    }\n    ParseContext.prototype.takeStack = function () {\n        // Binary heap pop\n        var stacks = this.stacks, elt = stacks[0], replacement = stacks.pop();\n        if (stacks.length == 0)\n            return elt;\n        stacks[0] = replacement;\n        for (var index = 0;;) {\n            var childIndex = (index << 1) + 1;\n            if (childIndex >= stacks.length)\n                break;\n            var child = stacks[childIndex];\n            if (childIndex + 1 < stacks.length && child.compare(stacks[childIndex + 1]) >= 0) {\n                child = stacks[childIndex + 1];\n                childIndex++;\n            }\n            if (replacement.compare(child) < 0)\n                break;\n            stacks[childIndex] = replacement;\n            stacks[index] = child;\n            index = childIndex;\n        }\n        return elt;\n    };\n    ParseContext.prototype.putStack = function (stack, strict) {\n        if (strict === void 0) { strict = stack.badness < 50 /* Stabilizing */ || stack.badness > 150 /* Wild */; }\n        var stacks = this.stacks;\n        for (var i = 0; i < stacks.length; i++) {\n            var other = stacks[i];\n            if ((strict || other.state == stack.state) && other.inputPos == stack.inputPos) {\n                var diff = stack.badness - other.badness || (stack.badness < 50 /* Stabilizing */ ? 0 : stack.stack.length - other.stack.length);\n                if (diff < 0) {\n                    stacks[i] = stack;\n                    return true;\n                }\n                else if (diff > 0)\n                    return false;\n            }\n        }\n        // Binary heap add\n        var index = stacks.push(stack) - 1;\n        while (index > 0) {\n            var parentIndex = index >> 1, parent = stacks[parentIndex];\n            if (stack.compare(parent) >= 0)\n                break;\n            stacks[index] = parent;\n            stacks[parentIndex] = stack;\n            index = parentIndex;\n        }\n        return true;\n    };\n    Object.defineProperty(ParseContext.prototype, \"pos\", {\n        get: function () { return this.stacks[0].inputPos; },\n        enumerable: true,\n        configurable: true\n    });\n    ParseContext.prototype.forceFinish = function () {\n        var stack = this.stacks[0].split();\n        while (!stack.state.accepting && stack.forceReduce()) { }\n        return stack.toTree();\n    };\n    ParseContext.prototype.advance = function () {\n        var stack = this.takeStack(), start = stack.inputPos, _a = stack.cx, input = _a.input, parser = _a.parser;\n        if (this.cache) {\n            for (var cached = this.cache.nodeAt(start); cached;) {\n                if (grammarID(cached.type) != parser.id)\n                    continue;\n                var match = parser.getGoto(stack.state.id, termID(cached.type));\n                if (match > -1 && !isFragile(cached)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(stack + (\" (via reuse of \" + parser.getName(cached.type) + \")\"));\n                    this.putStack(stack);\n                    return null;\n                }\n                if (cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                var inner = cached.children[0];\n                if (inner instanceof Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        var nest = stack.state.startNested;\n        maybeNest: if (nest > -1) {\n            var _b = parser.nested[nest], grammar = _b.grammar, endToken = _b.end, type = _b.type, placeholder = _b.placeholder;\n            var filterEnd = undefined, parseNode = null, nested = void 0;\n            if (typeof grammar == \"function\") {\n                var query = grammar(input.goto(stack.inputPos), stack);\n                if (query.stay)\n                    break maybeNest;\n                (parseNode = query.parseNode, nested = query.parser, filterEnd = query.filterEnd);\n            }\n            else {\n                nested = grammar;\n            }\n            var end_1 = this.scanForNestEnd(stack, endToken, filterEnd);\n            var clippedInput = stack.cx.input.clip(end_1);\n            if (parseNode || !nested) {\n                var node = parseNode ? parseNode(clippedInput) : Tree.empty;\n                stack.useNode(new Tree(node.children, node.positions, node.type & 1 /* Tagged */ || type < 0 ? node.type : type | parser.id, end_1 - stack.inputPos), parser.getGoto(stack.state.id, placeholder, true));\n                this.putStack(stack);\n            }\n            else {\n                var newStack = Stack.start(new StackContext(nested, stack.cx.maxBufferLength, clippedInput, stack), stack.inputPos);\n                if (verbose)\n                    console.log(newStack + \" (nested)\");\n                this.putStack(newStack);\n            }\n            return null;\n        }\n        var defaultReduce = stack.state.defaultReduce;\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            this.putStack(stack);\n            if (verbose)\n                console.log(stack + (\" (via always-reduce \" + parser.getName(defaultReduce & 65535 /* ValueMask */) + \")\"));\n            return null;\n        }\n        var actions = stack.cx.tokens.getActions(stack, input);\n        for (var i = 0; i < actions.length;) {\n            var action = actions[i++], term_1 = actions[i++], end_2 = actions[i++];\n            var localStack = i == actions.length ? stack : stack.split();\n            localStack.apply(action, term_1, end_2);\n            if (verbose)\n                console.log(localStack + (\" (via \" + ((action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : \"reduce of \" + parser.getName(action & 65535 /* ValueMask */)) + \" for \" + parser.getName(term_1) + \" @ \" + start + (localStack == stack ? \"\" : \", split\") + \")\"));\n            this.putStack(localStack, (action & 65536 /* ReduceFlag */) != 0);\n        }\n        if (actions.length > 0)\n            return null;\n        // If we're here, the stack failed to advance normally\n        if (start == input.length && (stack.state.accepting || this.stacks.length == 0)) {\n            while (!stack.state.accepting && stack.forceReduce()) { }\n            var tree = stack.toTree(), parent_1 = stack.cx.parent;\n            if (parent_1) {\n                // This is a nested parse—add its result to the parent stack and\n                // continue with that one.\n                var parentParser = parent_1.cx.parser, info = parentParser.nested[parent_1.state.startNested];\n                var node = new Tree(tree.children, tree.positions.map(function (p) { return p - parent_1.inputPos; }), info.type >= 0 ? info.type | parentParser.id : tree.type, stack.inputPos - parent_1.inputPos);\n                parent_1.useNode(node, parentParser.getGoto(parent_1.state.id, info.placeholder, true));\n                if (verbose)\n                    console.log(parent_1 + (\" (via unnest \" + parentParser.getName(info.type) + \")\"));\n                this.putStack(parent_1);\n                return null;\n            }\n            else {\n                // Actual end of parse\n                return stack.toTree();\n            }\n        }\n        var _c = stack.cx.tokens.mainToken, end = _c.end, term = _c.term;\n        if (!this.strict &&\n            !(stack.badness > 150 /* Wild */ && this.stacks.some(function (s) { return s.pos >= stack.inputPos && s.badness <= stack.badness; }))) {\n            var inserted = stack.recoverByInsert(term, end);\n            if (inserted) {\n                if (verbose)\n                    console.log(inserted + \" (via recover-insert)\");\n                this.putStack(inserted);\n            }\n            if (end == start) {\n                if (start == input.length)\n                    return null;\n                end++;\n                term = 1 /* Err */;\n            }\n            stack.recoverByDelete(term, end);\n            if (verbose)\n                console.log(stack + (\" (via recover-delete \" + parser.getName(term) + \")\"));\n            this.putStack(stack);\n        }\n        else if (!this.stacks.length) {\n            // Only happens in strict mode\n            throw new SyntaxError(\"No parse at \" + start + \" with \" + parser.getName(term) + \" (stack is \" + stack + \")\");\n        }\n        return null;\n    };\n    ParseContext.prototype.scanForNestEnd = function (stack, endToken, filter) {\n        var input = stack.cx.input;\n        for (var pos = stack.inputPos; pos < input.length; pos++) {\n            endToken.token(input.goto(pos), stack);\n            if (input.token > -1 && (!filter || filter(input.read(pos, input.tokenEnd))))\n                return pos;\n        }\n        return input.length;\n    };\n    return ParseContext;\n}());\nexport { ParseContext };\nvar nextGrammarID = 0;\nvar Parser = /** @class */ (function () {\n    function Parser(id, states, data, goto, tags, tokenizers, nested, specializeTable, specializations, tokenPrecTable, skippedNodes, termNames) {\n        if (termNames === void 0) { termNames = null; }\n        this.id = id;\n        this.states = states;\n        this.data = data;\n        this.goto = goto;\n        this.tags = tags;\n        this.tokenizers = tokenizers;\n        this.nested = nested;\n        this.specializeTable = specializeTable;\n        this.specializations = specializations;\n        this.tokenPrecTable = tokenPrecTable;\n        this.skippedNodes = skippedNodes;\n        this.termNames = termNames;\n    }\n    Parser.prototype.getName = function (term) {\n        return this.termNames ? this.termNames[term] : this.tags.get(term) || String(term);\n    };\n    Parser.prototype.parse = function (input, options) {\n        if (typeof input == \"string\")\n            input = new StringStream(input);\n        var cx = new ParseContext(this, input, options);\n        for (;;) {\n            var done = cx.advance();\n            if (done)\n                return done;\n        }\n    };\n    Parser.prototype.startParse = function (input, options) {\n        return new ParseContext(this, input, options);\n    };\n    Parser.prototype.getGoto = function (state, term, loose) {\n        if (loose === void 0) { loose = false; }\n        var table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (var pos = table[term + 1];;) {\n            var groupTag = table[pos++], last = groupTag & 1;\n            var target = table[pos++];\n            if (last && loose)\n                return target;\n            for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    };\n    Parser.prototype.hasAction = function (state, terminal) {\n        var data = this.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = set ? state.skip : state.actions, next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == terminal || next == 1 /* Err */)\n                    return data[i + 1] | (data[i + 2] << 16);\n            }\n        }\n        return 0;\n    };\n    Parser.prototype.getRecover = function (state, terminal) {\n        for (var i = state.recover, next = void 0; (next = this.data[i]) != 65535 /* End */; i += 2)\n            if (next == terminal)\n                return this.data[i + 1];\n        return 0;\n    };\n    Parser.prototype.anyReduce = function (state) {\n        if (state.defaultReduce > 0)\n            return state.defaultReduce;\n        for (var i = state.actions;; i += 3) {\n            if (this.data[i] == 65535 /* End */)\n                return 0;\n            var isReduce = this.data[i + 2];\n            if (isReduce)\n                return this.data[i + 1] | (isReduce << 16);\n        }\n    };\n    Parser.prototype.isSkipped = function (term) {\n        for (var i = this.skippedNodes, cur = void 0; (cur = this.data[i]) != 65535 /* End */; i++)\n            if (cur == term)\n                return true;\n        return false;\n    };\n    Parser.prototype.overrides = function (token, prev) {\n        var iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    };\n    Parser.prototype.tagMap = function (values) {\n        var content = [];\n        var tagArray = this.tags.grammars[this.id >> 16] || [];\n        for (var i = 0; i < tagArray.length; i++) {\n            var tag = tagArray[i];\n            content.push(Object.prototype.hasOwnProperty.call(values, tag) ? values[tag] :\n                tag[0] == '\"' && Object.prototype.hasOwnProperty.call(values, JSON.parse(tag)) ? values[JSON.parse(tag)] : null);\n        }\n        var grammars = [];\n        grammars[this.id >> 16] = content;\n        return new TagMap(grammars);\n    };\n    Parser.prototype.withNested = function (spec) {\n        return new Parser(this.id, this.states, this.data, this.goto, this.tags, this.tokenizers, this.nested.map(function (obj) {\n            if (!Object.prototype.hasOwnProperty.call(spec, obj.name))\n                return obj;\n            return { name: obj.name, grammar: spec[obj.name], end: obj.end, type: obj.type, placeholder: obj.placeholder };\n        }), this.specializeTable, this.specializations, this.tokenPrecTable, this.skippedNodes, this.termNames);\n    };\n    Parser.deserialize = function (states, stateData, goto, tags, tokenData, tokenizers, nested, specializeTable, specializations, tokenPrec, skippedNodes, termNames) {\n        var arr = decodeArray(states, Uint32Array), stateObjs = [];\n        for (var i = 0, id_1 = 0; i < arr.length;)\n            stateObjs.push(new ParseState(id_1++, arr[i++], arr[i++], arr[i++], arr[i++], arr[i++], arr[i++], arr[i++]));\n        var tokenArray = decodeArray(tokenData), id = Parser.allocateID();\n        return new Parser(id, stateObjs, decodeArray(stateData), decodeArray(goto), TagMap.single(id, tags), tokenizers.map(function (value) { return typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value; }), nested.map(function (_a) {\n            var name = _a[0], grammar = _a[1], endToken = _a[2], type = _a[3], placeholder = _a[4];\n            return ({ name: name, grammar: grammar, end: new TokenGroup(decodeArray(endToken), 0), type: type, placeholder: placeholder });\n        }), specializeTable, specializations.map(withoutPrototype), tokenPrec, skippedNodes, termNames);\n    };\n    Parser.allocateID = function () { return (nextGrammarID++) << 16; };\n    return Parser;\n}());\nexport { Parser };\nfunction findOffset(data, start, term) {\n    for (var i = start, next = void 0; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction withoutPrototype(obj) {\n    if (!(obj instanceof Object))\n        return obj;\n    var result = Object.create(null);\n    for (var prop in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, prop))\n            result[prop] = obj[prop];\n    return result;\n}\nfunction isFragile(node) {\n    var doneStart = false, doneEnd = false, fragile = node.type == 1 /* Err */;\n    if (!fragile)\n        node.iterate(0, node.length, function (type) {\n            return doneStart || (type == 1 /* Err */ ? fragile = doneStart = true : undefined);\n        }, function (type) {\n            doneStart = true;\n        });\n    if (!fragile)\n        node.iterate(node.length, 0, function (type) {\n            return doneEnd || (type == 1 /* Err */ ? fragile = doneEnd = true : undefined);\n        }, function (type) {\n            doneEnd = true;\n        });\n    return fragile;\n}\n//# sourceMappingURL=parse.js.map","map":"{\"version\":3,\"file\":\"parse.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/parse.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/parse.d.ts","writeByteOrderMark":false,"text":"import { Stack } from \"./stack\";\nimport { ParseState } from \"./state\";\nimport { InputStream, Tokenizer, TokenGroup } from \"./token\";\nimport { Tree, TagMap } from \"lezer-tree\";\nexport declare type NestedGrammar = null | Parser | ((input: InputStream, stack: Stack) => {\n    stay?: boolean;\n    parseNode?: (input: InputStream) => Tree;\n    parser?: Parser;\n    filterEnd?: (endToken: string) => boolean;\n});\ndeclare class CacheCursor {\n    trees: Tree[];\n    start: number[];\n    index: number[];\n    nextStart: number;\n    constructor(tree: Tree);\n    nodeAt(pos: number): Tree | null;\n}\ndeclare class CachedToken {\n    readonly tokenizer: Tokenizer;\n    start: number;\n    end: number;\n    term: number;\n    extended: number;\n    constructor(tokenizer: Tokenizer);\n    asError(pos: number, eof: number): this;\n}\ndeclare class TokenCache {\n    tokens: CachedToken[];\n    mainToken: CachedToken;\n    actions: number[];\n    getActions(stack: Stack, input: InputStream): number[];\n    updateCachedToken(token: CachedToken, stack: Stack, input: InputStream): void;\n    putAction(action: number, token: number, end: number, index: number): number;\n    addActions(stack: Stack, token: number, end: number, index: number): number;\n}\nexport declare type ParseOptions = {\n    cache?: Tree | null;\n    strict?: boolean;\n    bufferLength?: number;\n};\nexport declare class StackContext {\n    readonly parser: Parser;\n    readonly maxBufferLength: number;\n    readonly input: InputStream;\n    readonly parent: Stack | null;\n    reused: Tree[];\n    tokens: TokenCache;\n    constructor(parser: Parser, maxBufferLength: number, input: InputStream, parent?: Stack | null);\n}\nexport declare class ParseContext {\n    reused: Tree[];\n    stacks: Stack[];\n    cache: CacheCursor | null;\n    strict: boolean;\n    constructor(parser: Parser, input: InputStream, { cache, strict, bufferLength }?: ParseOptions);\n    takeStack(): Stack;\n    putStack(stack: Stack, strict?: boolean): boolean;\n    readonly pos: number;\n    forceFinish(): Tree;\n    advance(): Tree;\n    scanForNestEnd(stack: Stack, endToken: TokenGroup, filter?: ((token: string) => boolean)): number;\n}\nexport declare class Parser {\n    readonly id: number;\n    readonly states: readonly ParseState[];\n    readonly data: Readonly<Uint16Array>;\n    readonly goto: Readonly<Uint16Array>;\n    readonly tags: TagMap<string>;\n    readonly tokenizers: readonly Tokenizer[];\n    readonly nested: readonly {\n        name: string;\n        grammar: null | NestedGrammar;\n        end: TokenGroup;\n        type: number;\n        placeholder: number;\n    }[];\n    readonly specializeTable: number;\n    readonly specializations: readonly {\n        [value: string]: number;\n    }[];\n    readonly tokenPrecTable: number;\n    readonly skippedNodes: number;\n    readonly termNames: null | {\n        [id: number]: string;\n    };\n    constructor(id: number, states: readonly ParseState[], data: Readonly<Uint16Array>, goto: Readonly<Uint16Array>, tags: TagMap<string>, tokenizers: readonly Tokenizer[], nested: readonly {\n        name: string;\n        grammar: null | NestedGrammar;\n        end: TokenGroup;\n        type: number;\n        placeholder: number;\n    }[], specializeTable: number, specializations: readonly {\n        [value: string]: number;\n    }[], tokenPrecTable: number, skippedNodes: number, termNames?: null | {\n        [id: number]: string;\n    });\n    getName(term: number): string;\n    parse(input: InputStream | string, options?: ParseOptions): Tree;\n    startParse(input: InputStream, options?: ParseOptions): ParseContext;\n    getGoto(state: number, term: number, loose?: boolean): number;\n    hasAction(state: ParseState, terminal: number): number;\n    getRecover(state: ParseState, terminal: number): number;\n    anyReduce(state: ParseState): number;\n    isSkipped(term: number): boolean;\n    overrides(token: number, prev: number): boolean;\n    tagMap<T>(values: {\n        [name: string]: T;\n    }): TagMap<T>;\n    withNested(spec: {\n        [name: string]: NestedGrammar | null;\n    }): Parser;\n    static deserialize(states: string, stateData: string, goto: string, tags: readonly string[], tokenData: string, tokenizers: (Tokenizer | number)[], nested: [string, null | NestedGrammar, string, number, number][], specializeTable: number, specializations: readonly {\n        [term: string]: number;\n    }[], tokenPrec: number, skippedNodes: number, termNames?: {\n        [id: number]: string;\n    }): Parser;\n    static allocateID(): number;\n}\nexport {};\n"}}

{"code":"import { Tree } from \"lezer-tree\";\nexport var Badness;\n(function (Badness) {\n    // Amount to add for a single recover action\n    Badness[Badness[\"Unit\"] = 100] = \"Unit\";\n    // Limits in between which stacks are less agressively pruned\n    Badness[Badness[\"Stabilizing\"] = 50] = \"Stabilizing\";\n    Badness[Badness[\"Wild\"] = 150] = \"Wild\";\n})(Badness || (Badness = {}));\n// Badness is a measure of how off-the-rails a given parse is. It is\n// bumped when a recovery strategy is applied, and then reduced (by\n// multiplication with a constant < 1) for every successful (real)\n// token shifted.\n//\n// Stacks with a low badness are relatively credible parses that have\n// shifts matching the input in their recent history. Stacks with a\n// high badness are deeply in the weeds and likely wrong. In either of\n// these situations, we prune agressively by dropping stacks when\n// another stack at the same position is looking better.\n//\n// For those in the `Badness.Stabilizing` to `Badness.Wild` range, we\n// assume that they are in the process of trying to recover and allow\n// a bunch of them to continue alongside each other to see which one\n// works out better.\n//\n// Stacks with the same low badness score are likely to be valid GLR\n// parsing branches, so in that case it's often a good idea to let\n// both continue.\n//\n// When a stack fails to find an advancing action, recovery is only\n// applied when its badness is < `Badness.Wild`, or no better parse\n// exists at that point.\nvar Stack = /** @class */ (function () {\n    function Stack(cx, \n    // Holds state, pos, value stack pos (15 bits array index, 15 bits buffer index) triplets for all but the top state\n    stack, state, pos, inputPos, badness, \n    // Holds type,start,end,nodeCount quads\n    buffer, bufferBase, parent) {\n        this.cx = cx;\n        this.stack = stack;\n        this.state = state;\n        this.pos = pos;\n        this.inputPos = inputPos;\n        this.badness = badness;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    Stack.prototype.toString = function () {\n        return \"[\" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state.id).join(\",\") + \"]\";\n    };\n    Stack.start = function (cx, pos) {\n        if (pos === void 0) { pos = 0; }\n        return new Stack(cx, [], cx.parser.states[0], pos, pos, 0, [], 0, null);\n    };\n    Stack.prototype.pushState = function (state, start) {\n        this.stack.push(this.state.id, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    };\n    Stack.prototype.reduce = function (action) {\n        var depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        if (depth == 0) {\n            this.pushState(this.cx.parser.states[this.cx.parser.getGoto(this.state.id, type, true)], this.pos);\n            return;\n        }\n        var base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        var start = this.stack[base - 2];\n        var bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        if ((type & 1 /* Tagged */) || (action & 131072 /* RepeatFlag */)) {\n            var pos = this.state.skipped ? this.inputPos : this.pos;\n            if (this.inputPos == pos) { // Simple case, just append\n                this.buffer.push(type, start, pos, count + 4);\n            }\n            else { // There may be skipped nodes that have to be moved forward\n                var index = this.buffer.length;\n                while (index > 0 && this.buffer[index - 2] > pos) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    count -= 4;\n                }\n                this.buffer[index] = type;\n                this.buffer[index + 1] = start;\n                this.buffer[index + 2] = pos;\n                this.buffer[index + 3] = count + 4;\n            }\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.cx.parser.states[this.stack[base]];\n        }\n        else {\n            var baseStateID = this.stack[base - 3];\n            this.state = this.cx.parser.states[this.cx.parser.getGoto(baseStateID, type, true)];\n        }\n        if (base < this.stack.length)\n            this.stack.length = base;\n    };\n    Stack.prototype.shiftValue = function (term, start, end, childCount) {\n        if (childCount === void 0) { childCount = 4; }\n        if (term == 1 /* Err */) { // Try to omit superfluous error nodes\n            var cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 1 /* Err */ &&\n                (start == end || cur.buffer[top - 2] >= start))\n                return;\n        }\n        this.buffer.push(term, start, end, childCount);\n    };\n    Stack.prototype.shift = function (action, next, nextEnd) {\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(this.cx.parser.states[action & 65535 /* ValueMask */], this.inputPos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            var start = this.inputPos, nextState = this.cx.parser.states[action];\n            if (nextEnd > this.inputPos || (next & 1 /* Tagged */)) {\n                this.inputPos = nextEnd;\n                if (!nextState.skipped)\n                    this.pos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            if (next & 1 /* Tagged */)\n                this.buffer.push(next, start, nextEnd, 4);\n            this.badness = (this.badness >> 1) + (this.badness >> 2); // (* 0.75)\n        }\n        else { // Shift-and-stay, which means this is skipped token\n            if (next & 1 /* Tagged */)\n                this.buffer.push(next, this.inputPos, nextEnd, 4);\n            this.inputPos = nextEnd;\n        }\n    };\n    Stack.prototype.apply = function (action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    };\n    Stack.prototype.useNode = function (value, next) {\n        var index = this.cx.reused.length - 1;\n        if (index < 0 || this.cx.reused[index] != value) {\n            this.cx.reused.push(value);\n            index++;\n        }\n        var start = this.inputPos;\n        this.pos = this.inputPos = start + value.length;\n        this.pushState(this.cx.parser.states[next], start);\n        this.badness >>= 2; // (* 0.25)\n        this.buffer.push(index, start, this.pos, -1 /* size < 0 means this is a reused value */);\n    };\n    Stack.prototype.split = function () {\n        var parent = this;\n        var off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.pos)\n            off -= 4;\n        var buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.cx, this.stack.slice(), this.state, this.pos, this.inputPos, this.badness, buffer, base, parent);\n    };\n    Stack.prototype.recoverByDelete = function (next, nextEnd) {\n        if (next & 1 /* Tagged */)\n            this.shiftValue(next, this.inputPos, nextEnd);\n        this.shiftValue(1 /* Err */, this.inputPos, nextEnd, (next & 1 /* Tagged */) ? 8 : 4);\n        this.inputPos = nextEnd;\n        this.badness += 100 /* Unit */;\n    };\n    Stack.prototype.canShift = function (term) {\n        for (var sim = new SimulatedStack(this);;) {\n            var action = sim.top.defaultReduce || this.cx.parser.hasAction(sim.top, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    };\n    Object.defineProperty(Stack.prototype, \"ruleStart\", {\n        get: function () {\n            var force = this.state.forcedReduce;\n            if (!(force & 65536 /* ReduceFlag */))\n                return 0;\n            var base = this.stack.length - (3 * ((force >> 19 /* ReduceDepthShift */) - 1));\n            return this.stack[base - 2];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Stack.prototype.canRecover = function (next) {\n        // Scan for a state that has either a direct action or a recovery\n        // action for next, without actually building up a new stack\n        var visited = null, parser = this.cx.parser;\n        for (var sim = new SimulatedStack(this), i = 0;; i++) {\n            if (parser.hasAction(sim.top, next) || parser.getRecover(sim.top, next) != 0)\n                return true;\n            // Find a way to reduce from here\n            var reduce = parser.anyReduce(sim.top);\n            if (reduce == 0 && ((reduce = sim.top.forcedReduce) & 65536 /* ReduceFlag */) == 0)\n                return false;\n            sim.reduce(reduce);\n            if (i > 10) {\n                // Guard against getting stuck in a cycle\n                if (!visited)\n                    visited = [];\n                else if (i == 100 || visited.includes(sim.top.id))\n                    return false;\n                visited.push(sim.top.id);\n            }\n        }\n    };\n    Stack.prototype.recoverByInsert = function (next, nextEnd) {\n        if (!this.canRecover(next))\n            return null;\n        // Now that we know there's a recovery to be found, run the\n        // reduces again, the expensive way, updating the stack\n        var result = this.split(), parser = this.cx.parser;\n        result.pos = result.inputPos;\n        result.badness += 100 /* Unit */;\n        for (;;) {\n            for (;;) {\n                if (parser.hasAction(result.state, next))\n                    return result;\n                var recover = parser.getRecover(result.state, next);\n                if (!recover)\n                    break;\n                result.pushState(this.cx.parser.states[recover], result.pos);\n                result.shiftValue(1 /* Err */, result.pos, result.pos);\n            }\n            result.forceReduce();\n        }\n    };\n    Stack.prototype.forceReduce = function () {\n        var reduce = this.cx.parser.anyReduce(this.state);\n        if (reduce == 0) {\n            reduce = this.state.forcedReduce;\n            if ((reduce & 65536 /* ReduceFlag */) == 0)\n                return false;\n            this.shiftValue(1 /* Err */, this.pos, this.pos);\n        }\n        this.reduce(reduce);\n        return true;\n    };\n    Stack.prototype.compare = function (other) {\n        return this.inputPos - other.inputPos || this.badness - other.badness;\n    };\n    Stack.prototype.toTree = function () {\n        return Tree.build(StackBufferCursor.create(this), this.cx.parser.id, this.cx.maxBufferLength, this.cx.reused);\n    };\n    return Stack;\n}());\nexport { Stack };\nvar SimulatedStack = /** @class */ (function () {\n    function SimulatedStack(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    SimulatedStack.prototype.reduce = function (action) {\n        var term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top.id, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        var goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = this.stack.cx.parser.states[goto];\n    };\n    return SimulatedStack;\n}());\nvar StackBufferCursor = /** @class */ (function () {\n    function StackBufferCursor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    StackBufferCursor.create = function (stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    };\n    StackBufferCursor.prototype.maybeNext = function () {\n        var next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    };\n    Object.defineProperty(StackBufferCursor.prototype, \"type\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    StackBufferCursor.prototype.next = function () {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    };\n    StackBufferCursor.prototype.fork = function () {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    };\n    return StackBufferCursor;\n}());\n//# sourceMappingURL=stack.js.map","map":"{\"version\":3,\"file\":\"stack.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/stack.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/stack.d.ts","writeByteOrderMark":false,"text":"import { ParseState } from \"./state\";\nimport { StackContext } from \"./parse\";\nimport { Tree } from \"lezer-tree\";\nexport declare const enum Badness {\n    Unit = 100,\n    Stabilizing = 50,\n    Wild = 150\n}\nexport declare class Stack {\n    readonly cx: StackContext;\n    readonly stack: number[];\n    state: ParseState;\n    pos: number;\n    inputPos: number;\n    badness: number;\n    readonly buffer: number[];\n    readonly bufferBase: number;\n    readonly parent: Stack | null;\n    constructor(cx: StackContext, stack: number[], state: ParseState, pos: number, inputPos: number, badness: number, buffer: number[], bufferBase: number, parent: Stack | null);\n    toString(): string;\n    static start(cx: StackContext, pos?: number): Stack;\n    pushState(state: ParseState, start: number): void;\n    reduce(action: number): void;\n    shiftValue(term: number, start: number, end: number, childCount?: number): void;\n    shift(action: number, next: number, nextEnd: number): void;\n    apply(action: number, next: number, nextEnd: number): void;\n    useNode(value: Tree, next: number): void;\n    split(): Stack;\n    recoverByDelete(next: number, nextEnd: number): void;\n    canShift(term: number): boolean;\n    readonly ruleStart: number;\n    canRecover(next: number): boolean;\n    recoverByInsert(next: number, nextEnd: number): Stack | null;\n    forceReduce(): boolean;\n    compare(other: Stack): number;\n    toTree(): Tree;\n}\n"}}

{"code":"import { Tree } from \"lezer-tree\";\nexport var Badness;\n(function (Badness) {\n    // Amount to add for a single recover action\n    Badness[Badness[\"Unit\"] = 100] = \"Unit\";\n    // Limits in between which stacks are less agressively pruned\n    Badness[Badness[\"Stabilizing\"] = 50] = \"Stabilizing\";\n    Badness[Badness[\"Wild\"] = 150] = \"Wild\";\n})(Badness || (Badness = {}));\n// Badness is a measure of how off-the-rails a given parse is. It is\n// bumped when a recovery strategy is applied, and then reduced (by\n// multiplication with a constant < 1) for every successful (real)\n// token shifted.\n//\n// Stacks with a low badness are relatively credible parses that have\n// shifts matching the input in their recent history. Stacks with a\n// high badness are deeply in the weeds and likely wrong. In either of\n// these situations, we prune agressively by dropping stacks when\n// another stack at the same position is looking better.\n//\n// For those in the `Badness.Stabilizing` to `Badness.Wild` range, we\n// assume that they are in the process of trying to recover and allow\n// a bunch of them to continue alongside each other to see which one\n// works out better.\n//\n// Stacks with the same low badness score are likely to be valid GLR\n// parsing branches, so in that case it's often a good idea to let\n// both continue.\n//\n// When a stack fails to find an advancing action, recovery is only\n// applied when its badness is < `Badness.Wild`, or no better parse\n// exists at that point.\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nvar Stack = /** @class */ (function () {\n    /// @internal\n    function Stack(\n    // A group of values that the stack will share with all\n    // split instances\n    ///@internal\n    cx, \n    // Holds state, pos, value stack pos (15 bits array index, 15 bits\n    // buffer index) triplets for all but the top state\n    /// @internal\n    stack, \n    // The current parse state\n    /// @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    // The input position up to which this stack has parsed.\n    pos, \n    // A measure of the amount of error-recovery that recently\n    // happened on this stack\n    /// @internal\n    badness, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.cx = cx;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.badness = badness;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    /// @internal\n    Stack.prototype.toString = function () {\n        return \"[\" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state).join(\",\") + \"]\";\n    };\n    // Start an empty stack\n    /// @internal\n    Stack.start = function (cx, pos) {\n        if (pos === void 0) { pos = 0; }\n        return new Stack(cx, [], cx.parser.states[0], pos, pos, 0, [], 0, null);\n    };\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    Stack.prototype.pushState = function (state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    };\n    // Apply a reduce action\n    /// @internal\n    Stack.prototype.reduce = function (action) {\n        var depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        if (depth == 0) {\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            this.pushState(this.cx.parser.getGoto(this.state, type, true), this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        var base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        var start = this.stack[base - 2];\n        var bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        if ((type & 1 /* Tagged */) || (action & 131072 /* RepeatFlag */)) {\n            var pos = this.cx.parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            if (this.pos == pos) { // Simple case, just append\n                this.buffer.push(type, start, pos, count + 4);\n            }\n            else { // There may be skipped nodes that have to be moved forward\n                var index = this.buffer.length;\n                while (index > 0 && this.buffer[index - 2] > pos) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    count -= 4;\n                }\n                this.buffer[index] = type;\n                this.buffer[index + 1] = start;\n                this.buffer[index + 2] = pos;\n                this.buffer[index + 3] = count + 4;\n            }\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            var baseStateID = this.stack[base - 3];\n            this.state = this.cx.parser.getGoto(baseStateID, type, true);\n        }\n        if (base < this.stack.length)\n            this.stack.length = base;\n    };\n    // Shift a value into the buffer\n    /// @internal\n    Stack.prototype.shiftValue = function (term, start, end, childCount) {\n        if (childCount === void 0) { childCount = 4; }\n        if (term == 1 /* Err */) { // Try to omit superfluous error nodes\n            var cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 1 /* Err */ &&\n                (start == end || cur.buffer[top - 2] >= start))\n                return;\n        }\n        this.buffer.push(term, start, end, childCount);\n    };\n    // Apply a shift action\n    /// @internal\n    Stack.prototype.shift = function (action, next, nextEnd) {\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            var start = this.pos, nextState = action;\n            if (nextEnd > this.pos || (next & 1 /* Tagged */)) {\n                this.pos = nextEnd;\n                if (!this.cx.parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            if (next & 1 /* Tagged */)\n                this.buffer.push(next, start, nextEnd, 4);\n            this.badness = (this.badness >> 1) + (this.badness >> 2); // (* 0.75)\n        }\n        else { // Shift-and-stay, which means this is skipped token\n            if (next & 1 /* Tagged */)\n                this.buffer.push(next, this.pos, nextEnd, 4);\n            this.pos = nextEnd;\n        }\n    };\n    // Apply an action\n    /// @internal\n    Stack.prototype.apply = function (action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    };\n    // Add a prebuilt node into the buffer. This may be a reused node or\n    // the result of running a nested parser.\n    /// @internal\n    Stack.prototype.useNode = function (value, next) {\n        var index = this.cx.reused.length - 1;\n        if (index < 0 || this.cx.reused[index] != value) {\n            this.cx.reused.push(value);\n            index++;\n        }\n        var start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.badness >>= 2; // (* 0.25)\n        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);\n    };\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    Stack.prototype.split = function () {\n        var parent = this;\n        var off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        var buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.badness, buffer, base, parent);\n    };\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    Stack.prototype.recoverByDelete = function (next, nextEnd) {\n        if (next & 1 /* Tagged */)\n            this.shiftValue(next, this.pos, nextEnd);\n        this.shiftValue(1 /* Err */, this.pos, nextEnd, (next & 1 /* Tagged */) ? 8 : 4);\n        this.pos = nextEnd;\n        this.badness += 100 /* Unit */;\n    };\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    Stack.prototype.canShift = function (term) {\n        for (var sim = new SimulatedStack(this);;) {\n            var action = this.cx.parser.stateSlot(sim.top, 5 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    };\n    Object.defineProperty(Stack.prototype, \"ruleStart\", {\n        /// Find the start position of the rule that is currently being parsed.\n        get: function () {\n            var force = this.cx.parser.stateSlot(this.state, 6 /* ForcedReduce */);\n            if (!(force & 65536 /* ReduceFlag */))\n                return 0;\n            var base = this.stack.length - (3 * (force >> 19 /* ReduceDepthShift */));\n            return this.stack[base + 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// Find the start position of the innermost instance of any of the\n    /// given term types, or return `-1` when none of them are found.\n    ///\n    /// **Note:** this is only reliable when there is at least some\n    /// state that unambiguously matches the given rule on the stack.\n    /// I.e. if you have a grammar like this, where the difference\n    /// between `a` and `b` is only apparent at the third token:\n    ///\n    ///     a { b | c }\n    ///     b { \"x\" \"y\" \"x\" }\n    ///     c { \"x\" \"y\" \"z\" }\n    ///\n    /// Then a parse state after `\"x\"` will not reliably tell you that\n    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n    /// for either of those two rules (assuming that `a` isn't part of\n    /// some rule that includes other things starting with `\"x\"`).\n    Stack.prototype.startOf = function (types) {\n        for (var frame = this.stack.length - 3; frame >= 0; frame -= 3) {\n            var force = this.cx.parser.stateSlot(this.stack[frame], 6 /* ForcedReduce */);\n            if (types.includes(force & 65535 /* ValueMask */)) {\n                var base = frame - (3 * (force >> 19 /* ReduceDepthShift */));\n                return this.stack[base + 1];\n            }\n        }\n        return -1;\n    };\n    // Scan for a state that has either a direct action or a recovery\n    // action for next, without actually building up a new stack\n    /// @internal\n    Stack.prototype.canRecover = function (next) {\n        var visited = null, parser = this.cx.parser;\n        for (var sim = new SimulatedStack(this), i = 0;; i++) {\n            if (parser.hasAction(sim.top, next) || parser.getRecover(sim.top, next) != 0)\n                return true;\n            // Find a way to reduce from here\n            var reduce = parser.anyReduce(sim.top);\n            if (reduce == 0 && ((reduce = this.cx.parser.stateSlot(sim.top, 6 /* ForcedReduce */)) & 65536 /* ReduceFlag */) == 0)\n                return false;\n            sim.reduce(reduce);\n            if (i > 10) {\n                // Guard against getting stuck in a cycle\n                if (!visited)\n                    visited = [];\n                else if (i == 100 || visited.includes(sim.top))\n                    return false;\n                visited.push(sim.top);\n            }\n        }\n    };\n    // Try to apply a recovery action that conceptually\n    // inserts some missing content and syncs back to a state that will\n    // match `next`. If it finds one, it'll return a new stack with the\n    // insertion applied. If not, it'll return null.\n    /// @internal\n    Stack.prototype.recoverByInsert = function (next) {\n        if (!this.canRecover(next))\n            return null;\n        // Now that we know there's a recovery to be found, run the\n        // reduces again, the expensive way, updating the stack\n        var result = this.split(), parser = this.cx.parser;\n        result.reducePos = result.pos;\n        result.badness += 100 /* Unit */;\n        for (;;) {\n            for (;;) {\n                if (parser.hasAction(result.state, next))\n                    return result;\n                var recover = parser.getRecover(result.state, next);\n                if (!recover)\n                    break;\n                result.pushState(recover, result.pos);\n                result.shiftValue(1 /* Err */, result.pos, result.pos);\n            }\n            result.forceReduce();\n        }\n    };\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    Stack.prototype.forceReduce = function () {\n        var reduce = this.cx.parser.anyReduce(this.state);\n        if (reduce == 0) {\n            reduce = this.cx.parser.stateSlot(this.state, 6 /* ForcedReduce */);\n            if ((reduce & 65536 /* ReduceFlag */) == 0)\n                return false;\n            this.shiftValue(1 /* Err */, this.pos, this.pos);\n        }\n        this.reduce(reduce);\n        return true;\n    };\n    // Compare two stacks to get a number that indicates which one is\n    // behind or, if they are at the same position, which one has less\n    // badness.\n    /// @internal\n    Stack.prototype.compare = function (other) {\n        return this.pos - other.pos || this.badness - other.badness;\n    };\n    // Convert the stack's buffer to a syntax tree.\n    /// @internal\n    Stack.prototype.toTree = function () {\n        return Tree.build(StackBufferCursor.create(this), this.cx.parser.tags, this.cx.maxBufferLength, this.cx.reused);\n    };\n    return Stack;\n}());\nexport { Stack };\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nvar SimulatedStack = /** @class */ (function () {\n    function SimulatedStack(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    SimulatedStack.prototype.reduce = function (action) {\n        var term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        var goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = goto;\n    };\n    return SimulatedStack;\n}());\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nvar StackBufferCursor = /** @class */ (function () {\n    function StackBufferCursor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    StackBufferCursor.create = function (stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    };\n    StackBufferCursor.prototype.maybeNext = function () {\n        var next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    };\n    Object.defineProperty(StackBufferCursor.prototype, \"type\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    StackBufferCursor.prototype.next = function () {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    };\n    StackBufferCursor.prototype.fork = function () {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    };\n    return StackBufferCursor;\n}());\n//# sourceMappingURL=stack.js.map","map":"{\"version\":3,\"file\":\"stack.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/stack.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/stack.d.ts","writeByteOrderMark":false,"text":"import { StackContext } from \"./parse\";\nimport { Tree } from \"lezer-tree\";\nexport declare const enum Badness {\n    Unit = 100,\n    Stabilizing = 50,\n    Wild = 150\n}\nexport declare class Stack {\n    readonly cx: StackContext;\n    readonly stack: number[];\n    state: number;\n    reducePos: number;\n    pos: number;\n    badness: number;\n    readonly buffer: number[];\n    readonly bufferBase: number;\n    readonly parent: Stack | null;\n    constructor(cx: StackContext, stack: number[], state: number, reducePos: number, pos: number, badness: number, buffer: number[], bufferBase: number, parent: Stack | null);\n    toString(): string;\n    static start(cx: StackContext, pos?: number): Stack;\n    pushState(state: number, start: number): void;\n    reduce(action: number): void;\n    shiftValue(term: number, start: number, end: number, childCount?: number): void;\n    shift(action: number, next: number, nextEnd: number): void;\n    apply(action: number, next: number, nextEnd: number): void;\n    useNode(value: Tree, next: number): void;\n    split(): Stack;\n    recoverByDelete(next: number, nextEnd: number): void;\n    canShift(term: number): boolean;\n    readonly ruleStart: number;\n    startOf(types: readonly number[]): number;\n    canRecover(next: number): boolean;\n    recoverByInsert(next: number): Stack | null;\n    forceReduce(): boolean;\n    compare(other: Stack): number;\n    toTree(): Tree;\n}\n"}}

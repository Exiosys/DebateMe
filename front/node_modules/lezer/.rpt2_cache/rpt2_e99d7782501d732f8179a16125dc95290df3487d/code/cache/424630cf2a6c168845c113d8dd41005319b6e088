{"code":"import * as tslib_1 from \"tslib\";\nimport { Stack } from \"./stack\";\nimport { Token, StringStream, TokenGroup } from \"./token\";\nimport { DefaultBufferLength, Tree, TreeBuffer, Tag } from \"lezer-tree\";\nimport { decodeArray } from \"./decode\";\n// Environment variable used to control console output\nvar verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nvar CacheCursor = /** @class */ (function () {\n    function CacheCursor(tree) {\n        this.start = [0];\n        this.index = [0];\n        this.nextStart = 0;\n        this.trees = [tree];\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    CacheCursor.prototype.nodeAt = function (pos) {\n        if (pos < this.nextStart)\n            return null;\n        for (;;) {\n            var last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextStart = 1e9;\n                return null;\n            }\n            var top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            var next = top.children[index];\n            var start = this.start[last] + top.positions[index];\n            if (next instanceof TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else if (start >= pos) {\n                return start == pos ? next : null;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    };\n    return CacheCursor;\n}());\nvar CachedToken = /** @class */ (function (_super) {\n    tslib_1.__extends(CachedToken, _super);\n    function CachedToken(tokenizer) {\n        var _this = _super.call(this) || this;\n        _this.tokenizer = tokenizer;\n        _this.extended = -1;\n        return _this;\n    }\n    CachedToken.prototype.clear = function (start) {\n        this.start = start;\n        this.value = this.extended = -1;\n    };\n    return CachedToken;\n}(Token));\nvar dummyToken = new Token;\nvar TokenCache = /** @class */ (function () {\n    function TokenCache() {\n        this.tokens = [];\n        this.mainToken = dummyToken;\n        this.actions = [];\n    }\n    TokenCache.prototype.getActions = function (stack, input) {\n        var actionIndex = 0;\n        var main = null;\n        var parser = stack.cx.parser, tokenizers = parser.tokenizers;\n        var _loop_1 = function (i) {\n            if (((1 << i) & parser.stateSlot(stack.state, 4 /* TokenizerMask */)) == 0)\n                return \"continue\";\n            var tokenizer = tokenizers[i];\n            var token = this_1.tokens.find(function (c) { return c.tokenizer == tokenizer; });\n            if (!token)\n                this_1.tokens.push(token = new CachedToken(tokenizer));\n            if (tokenizer.contextual || token.start != stack.pos)\n                this_1.updateCachedToken(token, stack, input);\n            var startIndex = actionIndex;\n            if (token.extended > -1)\n                actionIndex = this_1.addActions(stack, token.extended, token.end, actionIndex);\n            actionIndex = this_1.addActions(stack, token.value, token.end, actionIndex);\n            if (actionIndex > startIndex) {\n                main = token;\n                return \"break\";\n            }\n            if (!main || token.value != 1 /* Err */)\n                main = token;\n        };\n        var this_1 = this;\n        for (var i = 0; i < tokenizers.length; i++) {\n            var state_1 = _loop_1(i);\n            if (state_1 === \"break\")\n                break;\n        }\n        if (this.actions.length > actionIndex)\n            this.actions.length = actionIndex;\n        this.mainToken = main || dummyToken.asError(stack.pos, input.length);\n        return this.actions;\n    };\n    TokenCache.prototype.updateCachedToken = function (token, stack, input) {\n        token.clear(stack.pos);\n        token.tokenizer.token(input, token, stack);\n        if (token.value > -1) {\n            var parser = stack.cx.parser;\n            var specIndex = findOffset(parser.data, parser.specializeTable, token.value);\n            if (specIndex >= 0) {\n                var found = parser.specializations[specIndex][input.read(token.start, token.end)];\n                if (found != null) {\n                    if ((found & 1) == 0 /* Specialize */)\n                        token.value = found >> 1;\n                    else\n                        token.extended = found >> 1;\n                }\n            }\n        }\n        else {\n            token.asError(stack.pos, input.length);\n        }\n    };\n    TokenCache.prototype.putAction = function (action, token, end, index) {\n        // Don't add duplicate actions\n        for (var i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    };\n    TokenCache.prototype.addActions = function (stack, token, end, index) {\n        var state = stack.state, parser = stack.cx.parser, data = parser.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == token || (next == 1 /* Err */ && index == 0))\n                    index = this.putAction(data[i + 1] | (data[i + 2] << 16), token, end, index);\n            }\n        }\n        return index;\n    };\n    return TokenCache;\n}());\nvar StackContext = /** @class */ (function () {\n    function StackContext(parser, maxBufferLength, input, parent) {\n        if (parent === void 0) { parent = null; }\n        this.parser = parser;\n        this.maxBufferLength = maxBufferLength;\n        this.input = input;\n        this.parent = parent;\n        this.reused = [];\n        this.tokens = new TokenCache;\n    }\n    return StackContext;\n}());\nexport { StackContext };\n/// A parse context can be used for step-by-step parsing. After\n/// creating it, you repeatedly call `.advance()` until it returns a\n/// tree to indicate it has reached the end of the parse.\nvar ParseContext = /** @class */ (function () {\n    /// @internal\n    function ParseContext(parser, input, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? undefined : _c, _d = _b.strict, strict = _d === void 0 ? false : _d, _e = _b.bufferLength, bufferLength = _e === void 0 ? DefaultBufferLength : _e;\n        this.stacks = [Stack.start(new StackContext(parser, bufferLength, input))];\n        this.strict = strict;\n        this.cache = cache ? new CacheCursor(cache) : null;\n    }\n    ParseContext.prototype.takeStack = function () {\n        // Binary heap pop\n        var stacks = this.stacks, elt = stacks[0], replacement = stacks.pop();\n        if (stacks.length == 0)\n            return elt;\n        stacks[0] = replacement;\n        for (var index = 0;;) {\n            var childIndex = (index << 1) + 1;\n            if (childIndex >= stacks.length)\n                break;\n            var child = stacks[childIndex];\n            if (childIndex + 1 < stacks.length && child.compare(stacks[childIndex + 1]) >= 0) {\n                child = stacks[childIndex + 1];\n                childIndex++;\n            }\n            if (replacement.compare(child) < 0)\n                break;\n            stacks[childIndex] = replacement;\n            stacks[index] = child;\n            index = childIndex;\n        }\n        return elt;\n    };\n    ParseContext.prototype.putStack = function (stack, strict) {\n        if (strict === void 0) { strict = stack.badness < 50 /* Stabilizing */ || stack.badness > 150 /* Wild */; }\n        var stacks = this.stacks;\n        for (var i = 0; i < stacks.length; i++) {\n            var other = stacks[i];\n            if ((strict || other.state == stack.state) && other.pos == stack.pos) {\n                var diff = stack.badness - other.badness || (stack.badness < 50 /* Stabilizing */ ? 0 : stack.stack.length - other.stack.length);\n                if (diff < 0) {\n                    stacks[i] = stack;\n                    return true;\n                }\n                else if (diff > 0)\n                    return false;\n            }\n        }\n        // Binary heap add\n        var index = stacks.push(stack) - 1;\n        while (index > 0) {\n            var parentIndex = index >> 1, parent = stacks[parentIndex];\n            if (stack.compare(parent) >= 0)\n                break;\n            stacks[index] = parent;\n            stacks[parentIndex] = stack;\n            index = parentIndex;\n        }\n        return true;\n    };\n    /// Execute one parse step. This picks the parse stack that's\n    /// currently the least far along, and does the next thing that can\n    /// be done with it. This may be:\n    ///\n    /// - Add a cached node, if a matching one is found.\n    /// - Enter a nested grammar.\n    /// - Perform all shift or reduce actions that match the current\n    ///   token (if there are more than one, this will split the stack)\n    /// - Finish the parse\n    ///\n    /// When the parse is finished, this will return a syntax tree. When\n    /// not, it returns `null`.\n    ParseContext.prototype.advance = function () {\n        var stack = this.takeStack(), start = stack.pos, _a = stack.cx, input = _a.input, parser = _a.parser;\n        if (this.cache) {\n            for (var cached = this.cache.nodeAt(start); cached;) {\n                if (!cached.isPartOf(parser.tags))\n                    continue;\n                var match = parser.getGoto(stack.state, cached.type);\n                if (match > -1 && !isFragile(cached)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(stack + (\" (via reuse of \" + parser.getName(cached.type) + \")\"));\n                    this.putStack(stack);\n                    return null;\n                }\n                if (cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                var inner = cached.children[0];\n                if (inner instanceof Tree)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        var nest = parser.startNested(stack.state);\n        maybeNest: if (nest > -1) {\n            var _b = parser.nested[nest], grammar = _b.grammar, endToken = _b.end, type = _b.type, placeholder = _b.placeholder;\n            var filterEnd = undefined, parseNode = null, nested = void 0;\n            if (typeof grammar == \"function\") {\n                var query = grammar(input, stack);\n                if (query.stay)\n                    break maybeNest;\n                (parseNode = query.parseNode, nested = query.parser, filterEnd = query.filterEnd);\n            }\n            else {\n                nested = grammar;\n            }\n            var end_1 = this.scanForNestEnd(stack, endToken, filterEnd);\n            var clippedInput = stack.cx.input.clip(end_1);\n            if (parseNode || !nested) {\n                var node = parseNode ? parseNode(clippedInput, stack.pos) : Tree.empty;\n                var keepType = (node.type & 1 /* Tagged */) || type < 0;\n                stack.useNode(new Tree(node.children, node.positions, end_1 - stack.pos, keepType ? node.tags : parser.tags, keepType ? node.type : type), parser.getGoto(stack.state, placeholder, true));\n                this.putStack(stack);\n            }\n            else {\n                var newStack = Stack.start(new StackContext(nested, stack.cx.maxBufferLength, clippedInput, stack), stack.pos);\n                if (verbose)\n                    console.log(newStack + \" (nested)\");\n                this.putStack(newStack);\n            }\n            return null;\n        }\n        var defaultReduce = parser.stateSlot(stack.state, 5 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            this.putStack(stack);\n            if (verbose)\n                console.log(stack + (\" (via always-reduce \" + parser.getName(defaultReduce & 65535 /* ValueMask */) + \")\"));\n            return null;\n        }\n        var actions = stack.cx.tokens.getActions(stack, input);\n        for (var i = 0; i < actions.length;) {\n            var action = actions[i++], term_1 = actions[i++], end_2 = actions[i++];\n            var localStack = i == actions.length ? stack : stack.split();\n            localStack.apply(action, term_1, end_2);\n            if (verbose)\n                console.log(localStack + (\" (via \" + ((action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : \"reduce of \" + parser.getName(action & 65535 /* ValueMask */)) + \" for \" + parser.getName(term_1) + \" @ \" + start + (localStack == stack ? \"\" : \", split\") + \")\"));\n            this.putStack(localStack, (action & 65536 /* ReduceFlag */) != 0);\n        }\n        if (actions.length > 0)\n            return null;\n        // If we're here, the stack failed to advance normally\n        if (start == input.length && (parser.stateFlag(stack.state, 2 /* Accepting */) || this.stacks.length == 0)) {\n            while (!parser.stateFlag(stack.state, 2 /* Accepting */) && stack.forceReduce()) { }\n            var tree = stack.toTree(), parent_1 = stack.cx.parent;\n            if (parent_1) {\n                // This is a nested parse—add its result to the parent stack and\n                // continue with that one.\n                var parentParser = parent_1.cx.parser, info = parentParser.nested[parentParser.startNested(parent_1.state)];\n                var keepType = info.type < 0;\n                var node = new Tree(tree.children, tree.positions.map(function (p) { return p - parent_1.pos; }), stack.pos - parent_1.pos, keepType ? tree.tags : parentParser.tags, keepType ? tree.type : info.type);\n                parent_1.useNode(node, parentParser.getGoto(parent_1.state, info.placeholder, true));\n                if (verbose)\n                    console.log(parent_1 + (\" (via unnest \" + parentParser.getName(info.type) + \")\"));\n                this.putStack(parent_1);\n                return null;\n            }\n            else {\n                // Actual end of parse\n                return stack.toTree();\n            }\n        }\n        var _c = stack.cx.tokens.mainToken, end = _c.end, term = _c.value;\n        if (!this.strict &&\n            !(stack.badness > 150 /* Wild */ && this.stacks.some(function (s) { return s.pos >= stack.pos && s.badness <= stack.badness; }))) {\n            var inserted = stack.recoverByInsert(term);\n            if (inserted) {\n                if (verbose)\n                    console.log(inserted + \" (via recover-insert)\");\n                this.putStack(inserted);\n            }\n            if (end == start) {\n                if (start == input.length)\n                    return null;\n                end++;\n                term = 1 /* Err */;\n            }\n            stack.recoverByDelete(term, end);\n            if (verbose)\n                console.log(stack + (\" (via recover-delete \" + parser.getName(term) + \")\"));\n            this.putStack(stack);\n        }\n        else if (!this.stacks.length) {\n            // Only happens in strict mode\n            throw new SyntaxError(\"No parse at \" + start + \" with \" + parser.getName(term) + \" (stack is \" + stack + \")\");\n        }\n        return null;\n    };\n    Object.defineProperty(ParseContext.prototype, \"pos\", {\n        /// The position to which the parse has advanced.\n        get: function () { return this.stacks[0].pos; },\n        enumerable: true,\n        configurable: true\n    });\n    /// Force the parse to finish, generating a tree containing the nodes\n    /// parsed so far.\n    ParseContext.prototype.forceFinish = function () {\n        var stack = this.stacks[0].split();\n        while (!stack.cx.parser.stateFlag(stack.state, 2 /* Accepting */) && stack.forceReduce()) { }\n        return stack.toTree();\n    };\n    ParseContext.prototype.scanForNestEnd = function (stack, endToken, filter) {\n        var input = stack.cx.input;\n        for (var pos = stack.pos; pos < input.length; pos++) {\n            dummyToken.start = pos;\n            dummyToken.value = -1;\n            endToken.token(input, dummyToken, stack);\n            if (dummyToken.value > -1 && (!filter || filter(input.read(pos, dummyToken.end))))\n                return pos;\n        }\n        return input.length;\n    };\n    return ParseContext;\n}());\nexport { ParseContext };\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nvar Parser = /** @class */ (function () {\n    /// @internal\n    function Parser(\n    /// The parse states for this grammar @internal\n    states, \n    /// A blob of data that the parse states, as well as some\n    /// of `Parser`'s fields, point into @internal\n    data, \n    /// The goto table. See `computeGotoTable` in\n    /// lezer-generator for details on the format @internal\n    goto, \n    /// A `TagMap` mapping the node types in this grammar to their tag\n    /// names.\n    tags, \n    /// The tokenizer objects used by the grammar @internal\n    tokenizers, \n    /// Metadata about nested grammars used in this grammar @internal\n    nested, \n    /// Points into this.data at an array of token types that\n    /// are specialized @internal\n    specializeTable, \n    /// For each specialized token type, this holds an object mapping\n    /// names to numbers, with the first bit indicating whether the\n    /// specialization extends or replaces the original token, and the\n    /// rest of the bits holding the specialized token type. @internal\n    specializations, \n    /// Points into this.data at an array that holds the\n    /// precedence order (higher precedence first) for ambiguous\n    /// tokens @internal\n    tokenPrecTable, \n    /// Points at an array of node types that are part of\n    /// skip rules @internal\n    skippedNodes, \n    /// An optional object mapping term ids to name strings @internal\n    termNames) {\n        if (termNames === void 0) { termNames = null; }\n        this.states = states;\n        this.data = data;\n        this.goto = goto;\n        this.tags = tags;\n        this.tokenizers = tokenizers;\n        this.nested = nested;\n        this.specializeTable = specializeTable;\n        this.specializations = specializations;\n        this.tokenPrecTable = tokenPrecTable;\n        this.skippedNodes = skippedNodes;\n        this.termNames = termNames;\n    }\n    /// Parse a given string or stream.\n    Parser.prototype.parse = function (input, options) {\n        if (typeof input == \"string\")\n            input = new StringStream(input);\n        var cx = new ParseContext(this, input, options);\n        for (;;) {\n            var done = cx.advance();\n            if (done)\n                return done;\n        }\n    };\n    /// Create a `ParseContext`.\n    Parser.prototype.startParse = function (input, options) {\n        return new ParseContext(this, input, options);\n    };\n    /// Get a goto table entry @internal\n    Parser.prototype.getGoto = function (state, term, loose) {\n        if (loose === void 0) { loose = false; }\n        var table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (var pos = table[term + 1];;) {\n            var groupTag = table[pos++], last = groupTag & 1;\n            var target = table[pos++];\n            if (last && loose)\n                return target;\n            for (var end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    };\n    /// Check if this state has an action for a given terminal @internal\n    Parser.prototype.hasAction = function (state, terminal) {\n        var data = this.data;\n        for (var set = 0; set < 2; set++) {\n            for (var i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next = void 0; (next = data[i]) != 65535 /* End */; i += 3) {\n                if (next == terminal || next == 1 /* Err */)\n                    return data[i + 1] | (data[i + 2] << 16);\n            }\n        }\n        return 0;\n    };\n    // Get a recovery action for a given state and terminal, or 0 when\n    // none\n    ///@internal\n    Parser.prototype.getRecover = function (state, terminal) {\n        for (var i = this.stateSlot(state, 3 /* Recover */), next = void 0; (next = this.data[i]) != 65535 /* End */; i += 2)\n            if (next == terminal)\n                return this.data[i + 1];\n        return 0;\n    };\n    /// @internal\n    Parser.prototype.stateSlot = function (state, slot) {\n        return this.states[(state << 3 /* Shift */) + slot];\n    };\n    /// @internal\n    Parser.prototype.stateFlag = function (state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    };\n    /// @internal\n    Parser.prototype.startNested = function (state) {\n        var flags = this.stateSlot(state, 0 /* Flags */);\n        return flags & 4 /* StartNest */ ? flags >> 10 /* NestShift */ : -1;\n    };\n    /// @internal\n    Parser.prototype.anyReduce = function (state) {\n        var defaultReduce = this.stateSlot(state, 5 /* DefaultReduce */);\n        if (defaultReduce > 0)\n            return defaultReduce;\n        for (var i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */)\n                return 0;\n            var isReduce = this.data[i + 2];\n            if (isReduce)\n                return this.data[i + 1] | (isReduce << 16);\n        }\n    };\n    /// Tells you whether a given term is part of the skip rules for the\n    /// grammar.\n    Parser.prototype.isSkipped = function (term) {\n        for (var i = this.skippedNodes, cur = void 0; (cur = this.data[i]) != 65535 /* End */; i++)\n            if (cur == term)\n                return true;\n        return false;\n    };\n    /// @internal\n    Parser.prototype.overrides = function (token, prev) {\n        var iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    };\n    /// Create a new `Parser` instance with different values for (some\n    /// of) the nested grammars. This can be used to, for example, swap\n    /// in a different language for a nested grammar or fill in a nested\n    /// grammar that was left blank by the original grammar.\n    Parser.prototype.withNested = function (spec) {\n        return new Parser(this.states, this.data, this.goto, this.tags, this.tokenizers, this.nested.map(function (obj) {\n            if (!Object.prototype.hasOwnProperty.call(spec, obj.name))\n                return obj;\n            return { name: obj.name, grammar: spec[obj.name], end: obj.end, type: obj.type, placeholder: obj.placeholder };\n        }), this.specializeTable, this.specializations, this.tokenPrecTable, this.skippedNodes, this.termNames);\n    };\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    Parser.prototype.getName = function (term) {\n        return this.termNames ? this.termNames[term] : (term & 1 /* Tagged */) && this.tags[term >> 1].tag || String(term);\n    };\n    /// (Used by the output of the parser generator) @internal\n    Parser.deserialize = function (states, stateData, goto, tags, globalTag, tokenData, tokenizers, nested, specializeTable, specializations, tokenPrec, skippedNodes, termNames) {\n        var tokenArray = decodeArray(tokenData);\n        return new Parser(decodeArray(states, Uint32Array), decodeArray(stateData), decodeArray(goto), tags.map(function (tag) { return new Tag(tag + (globalTag ? \".\" + globalTag : \"\")); }), tokenizers.map(function (value) { return typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value; }), nested.map(function (_a) {\n            var name = _a[0], grammar = _a[1], endToken = _a[2], type = _a[3], placeholder = _a[4];\n            return ({ name: name, grammar: grammar, end: new TokenGroup(decodeArray(endToken), 0), type: type, placeholder: placeholder });\n        }), specializeTable, specializations.map(withoutPrototype), tokenPrec, skippedNodes, termNames);\n    };\n    return Parser;\n}());\nexport { Parser };\nfunction findOffset(data, start, term) {\n    for (var i = start, next = void 0; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\n// Strip the prototypes from objects, so that they can safely be\n// accessed as maps.\nfunction withoutPrototype(obj) {\n    if (!(obj instanceof Object))\n        return obj;\n    var result = Object.create(null);\n    for (var prop in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, prop))\n            result[prop] = obj[prop];\n    return result;\n}\n// Checks whether a node starts or ends with an error node, in which\n// case we shouldn't reuse it.\nfunction isFragile(node) {\n    var doneStart = false, doneEnd = false, fragile = node.type == 1 /* Err */;\n    if (!fragile)\n        node.iterate(0, node.length, function (tag) {\n            return doneStart || (tag.tag == \"⚠\" ? fragile = doneStart = true : undefined);\n        }, function (type) {\n            doneStart = true;\n        });\n    if (!fragile)\n        node.iterate(node.length, 0, function (tag) {\n            return doneEnd || (tag.tag == \"⚠\" ? fragile = doneEnd = true : undefined);\n        }, function (type) {\n            doneEnd = true;\n        });\n    return fragile;\n}\n//# sourceMappingURL=parse.js.map","map":"{\"version\":3,\"file\":\"parse.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/parse.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/parse.d.ts","writeByteOrderMark":false,"text":"import { Stack } from \"./stack\";\nimport { InputStream, Token, Tokenizer, TokenGroup } from \"./token\";\nimport { Tree, Tag } from \"lezer-tree\";\nexport declare type NestedGrammar = null | Parser | ((input: InputStream, stack: Stack) => NestedGrammarSpec);\nexport interface NestedGrammarSpec {\n    parser?: Parser;\n    stay?: boolean;\n    parseNode?: (input: InputStream, start: number) => Tree;\n    filterEnd?: (endToken: string) => boolean;\n}\ndeclare class CacheCursor {\n    trees: Tree[];\n    start: number[];\n    index: number[];\n    nextStart: number;\n    constructor(tree: Tree);\n    nodeAt(pos: number): Tree | null;\n}\ndeclare class CachedToken extends Token {\n    readonly tokenizer: Tokenizer;\n    extended: number;\n    constructor(tokenizer: Tokenizer);\n    clear(start: number): void;\n}\ndeclare class TokenCache {\n    tokens: CachedToken[];\n    mainToken: Token;\n    actions: number[];\n    getActions(stack: Stack, input: InputStream): number[];\n    updateCachedToken(token: CachedToken, stack: Stack, input: InputStream): void;\n    putAction(action: number, token: number, end: number, index: number): number;\n    addActions(stack: Stack, token: number, end: number, index: number): number;\n}\nexport interface ParseOptions {\n    cache?: Tree;\n    strict?: boolean;\n    bufferLength?: number;\n}\nexport declare class StackContext {\n    readonly parser: Parser;\n    readonly maxBufferLength: number;\n    readonly input: InputStream;\n    readonly parent: Stack | null;\n    reused: Tree[];\n    tokens: TokenCache;\n    constructor(parser: Parser, maxBufferLength: number, input: InputStream, parent?: Stack | null);\n}\nexport declare class ParseContext {\n    stacks: Stack[];\n    cache: CacheCursor | null;\n    strict: boolean;\n    constructor(parser: Parser, input: InputStream, { cache, strict, bufferLength }?: ParseOptions);\n    private takeStack;\n    private putStack;\n    advance(): Tree;\n    readonly pos: number;\n    forceFinish(): Tree;\n    private scanForNestEnd;\n}\nexport declare class Parser {\n    readonly states: Readonly<Uint32Array>;\n    readonly data: Readonly<Uint16Array>;\n    readonly goto: Readonly<Uint16Array>;\n    readonly tags: readonly Tag[];\n    readonly tokenizers: readonly Tokenizer[];\n    readonly nested: readonly {\n        name: string;\n        grammar: NestedGrammar;\n        end: TokenGroup;\n        type: number;\n        placeholder: number;\n    }[];\n    readonly specializeTable: number;\n    readonly specializations: readonly {\n        [value: string]: number;\n    }[];\n    readonly tokenPrecTable: number;\n    readonly skippedNodes: number;\n    readonly termNames: null | {\n        [id: number]: string;\n    };\n    constructor(states: Readonly<Uint32Array>, data: Readonly<Uint16Array>, goto: Readonly<Uint16Array>, tags: readonly Tag[], tokenizers: readonly Tokenizer[], nested: readonly {\n        name: string;\n        grammar: NestedGrammar;\n        end: TokenGroup;\n        type: number;\n        placeholder: number;\n    }[], specializeTable: number, specializations: readonly {\n        [value: string]: number;\n    }[], tokenPrecTable: number, skippedNodes: number, termNames?: null | {\n        [id: number]: string;\n    });\n    parse(input: InputStream | string, options?: ParseOptions): Tree;\n    startParse(input: InputStream, options?: ParseOptions): ParseContext;\n    getGoto(state: number, term: number, loose?: boolean): number;\n    hasAction(state: number, terminal: number): number;\n    getRecover(state: number, terminal: number): number;\n    stateSlot(state: number, slot: number): number;\n    stateFlag(state: number, flag: number): boolean;\n    startNested(state: number): number;\n    anyReduce(state: number): number;\n    isSkipped(term: number): boolean;\n    overrides(token: number, prev: number): boolean;\n    withNested(spec: {\n        [name: string]: NestedGrammar | null;\n    }): Parser;\n    getName(term: number): string;\n    static deserialize(states: string, stateData: string, goto: string, tags: readonly string[], globalTag: string | null, tokenData: string, tokenizers: (Tokenizer | number)[], nested: [string, null | NestedGrammar, string, number, number][], specializeTable: number, specializations: readonly {\n        [term: string]: number;\n    }[], tokenPrec: number, skippedNodes: number, termNames?: {\n        [id: number]: string;\n    }): Parser;\n}\nexport {};\n"}}

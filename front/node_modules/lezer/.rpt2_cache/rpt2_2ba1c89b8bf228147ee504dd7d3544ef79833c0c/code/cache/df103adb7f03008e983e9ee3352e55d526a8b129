{"code":"import { Stack, BADNESS_WILD, DEFAULT_BUFFER_LENGTH, setBufferLength } from \"./stack\";\nimport { TERM_EOF, TERM_ERR, TERM_TAGGED } from \"./term\";\nimport { Node, Tree, TreeBuffer } from \"./tree\";\nvar verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nexport var SPECIALIZE = 0, REPLACE = 1, EXTEND = 2;\nvar CacheCursor = /** @class */ (function () {\n    function CacheCursor(tree) {\n        this.start = [0];\n        this.index = [0];\n        this.nextStart = 0;\n        this.trees = tree instanceof Tree ? [tree] : [];\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    CacheCursor.prototype.nodeAt = function (pos) {\n        if (pos < this.nextStart)\n            return null;\n        for (;;) {\n            var last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextStart = 1e9;\n                return null;\n            }\n            var top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            var next = top.children[index];\n            var start = this.start[last] + top.positions[index];\n            if (next instanceof TreeBuffer) {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n            else if (start >= pos) {\n                return start == pos ? next : null;\n            }\n            else {\n                this.index[last]++;\n                if (start + next.length >= pos) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n        }\n    };\n    return CacheCursor;\n}());\nvar TokenCache = /** @class */ (function () {\n    function TokenCache(parser, input) {\n        this.parser = parser;\n        this.input = input;\n        this.cachedFor = null;\n        this.pos = 0;\n        this.start = 0;\n        this.end = 0;\n        // Latest read base token\n        this.term = 0;\n        // Potential specialization for .term\n        this.specialized = 0;\n        // Latest token, with specialization applied, used for recovery\n        this.token = 0;\n        this.skipContent = [];\n        this.actions = [];\n    }\n    TokenCache.prototype.updateToken = function (stack) {\n        var tokenizers = stack.state.tokenizers, pos = stack.pos;\n        if (this.pos == pos && this.cachedFor == tokenizers)\n            return;\n        this.pos = pos;\n        this.cachedFor = tokenizers;\n        this.specialized = -1;\n        if (this.skipContent.length)\n            this.skipContent.length = 0;\n        var input = this.input;\n        for (;;) {\n            if (pos == input.length) { // FIXME do call external tokenizers\n                this.term = this.token = TERM_EOF;\n                this.start = this.end = pos;\n            }\n            else {\n                // Try the external tokenizers for this group + the main tokenizer, in order\n                for (var _i = 0, tokenizers_1 = tokenizers; _i < tokenizers_1.length; _i++) {\n                    var group = tokenizers_1[_i];\n                    group.token(input.goto(pos), stack);\n                    if (input.token >= 0)\n                        break;\n                }\n                if (input.token < 0) {\n                    this.term = this.token = TERM_ERR;\n                    this.start = pos;\n                    this.end = pos + 1;\n                }\n                else if (this.parser.skip.includes(input.token)) {\n                    if (input.token & TERM_TAGGED)\n                        this.skipContent.push(pos, input.tokenEnd, input.token);\n                    pos = input.tokenEnd;\n                    continue;\n                }\n                else {\n                    this.term = this.token = input.token;\n                    this.start = pos;\n                    this.end = input.tokenEnd;\n                    var specIndex = this.parser.specialized.indexOf(this.term);\n                    if (specIndex >= 0) {\n                        // FIXME use .term differently or define a new prop so that recovery uses the specialized token?\n                        var found = this.parser.specializations[specIndex][input.read(pos, this.end)];\n                        if (found != null)\n                            this.specialized = found;\n                    }\n                }\n            }\n            break;\n        }\n    };\n    TokenCache.prototype.actionsFor = function (stack) {\n        var actionIndex = 0, state = stack.state;\n        maybeSpec: {\n            if (this.specialized > -1) {\n                var initialIndex = actionIndex;\n                actionIndex = this.addActions(state, this.specialized >> 2, this.end, actionIndex);\n                var type = this.specialized & 3;\n                if (type == REPLACE || (type == SPECIALIZE && actionIndex > initialIndex)) {\n                    this.token = this.specialized >> 2;\n                    break maybeSpec;\n                }\n            }\n            if (this.term != TERM_ERR)\n                actionIndex = this.addActions(state, this.term, this.end, actionIndex);\n        }\n        if (this.actions.length > actionIndex)\n            this.actions.length = actionIndex;\n        return this.actions;\n    };\n    TokenCache.prototype.addActions = function (state, token, end, index) {\n        for (var i = 0; i < state.actions.length; i += 2)\n            if (state.actions[i] == token) {\n                this.actions[index++] = state.actions[i + 1];\n                this.actions[index++] = token;\n                this.actions[index++] = end; // FIXME always the same as this.end?\n            }\n        return index;\n    };\n    return TokenCache;\n}());\nexport function parse(input, parser, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.cache, cache = _c === void 0 ? null : _c, _d = _b.strict, strict = _d === void 0 ? false : _d, _e = _b.bufferLength, bufferLength = _e === void 0 ? DEFAULT_BUFFER_LENGTH : _e;\n    setBufferLength(bufferLength);\n    var parses = [Stack.start(parser)];\n    var cacheCursor = cache && new CacheCursor(cache);\n    var tokens = new TokenCache(parser, input);\n    var _loop_1 = function () {\n        var stack = Stack.take(parses);\n        tokens.updateToken(stack);\n        var start = tokens.start;\n        if (cacheCursor) { //  && !stack.state.ambiguous) { // FIXME implement fragility check\n            for (var cached = cacheCursor.nodeAt(start); cached;) {\n                var match = parser.getGoto(stack.state.id, cached.tag);\n                if (match) {\n                    stack.useCached(cached, start, parser.states[match]);\n                    if (verbose)\n                        console.log(stack + (\" (via reuse of \" + parser.getName(cached.tag) + \")\"));\n                    stack.put(parses);\n                    return \"continue-parse\";\n                }\n                if (cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                var inner = cached.children[0];\n                if (inner instanceof Node)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        if (stack.state.defaultReduce > 0) {\n            stack.reduce(stack.state.defaultReduce);\n            stack.put(parses);\n            if (verbose)\n                console.log(stack + \" (via always-reduce)\");\n            return \"continue\";\n        }\n        var actions = tokens.actionsFor(stack);\n        for (var i = 0; i < actions.length;) {\n            var action = actions[i++], term = actions[i++], end = actions[i++];\n            var localStack = i == actions.length ? stack : stack.split();\n            localStack.apply(action, term, start, end, tokens.skipContent);\n            if (verbose)\n                console.log(localStack + (\" (via \" + (action < 0 ? \"shift\" : \"reduce\") + \" for \" + parser.getName(term) + \" @ \" + start + (localStack == stack ? \"\" : \", split\") + \")\"));\n            localStack.put(parses, action >= 0);\n            if (action < 0)\n                tokens.pos = -1;\n        }\n        if (actions.length > 0)\n            return \"continue\";\n        // If we're here, the stack failed to advance normally\n        // FIXME proper end condition check\n        if (start == input.length && (stack.stack.length == 3 || parses.length == 0)) {\n            stack.shiftSkipped(tokens.skipContent);\n            return { value: stack.toTree() };\n        }\n        if (!strict &&\n            !(stack.badness > BADNESS_WILD && parses.some(function (s) { return s.pos >= stack.pos && s.badness <= stack.badness; }))) {\n            var inserted = stack.recoverByInsert(tokens.token, start, tokens.end);\n            if (inserted) {\n                if (verbose)\n                    console.log(inserted + \" (via recover-insert)\");\n                inserted.put(parses);\n            }\n            stack.recoverByDelete(tokens.token, start, tokens.end, tokens.skipContent);\n            if (verbose)\n                console.log(stack + \" (via recover-delete)\");\n            stack.put(parses);\n        }\n        else if (!parses.length) {\n            // Only happens in strict mode\n            throw new SyntaxError(\"No parse at \" + start + \" with \" + parser.getName(tokens.token) + \" (stack is \" + stack + \")\");\n        }\n    };\n    parse: for (;;) {\n        var state_1 = _loop_1();\n        if (typeof state_1 === \"object\")\n            return state_1.value;\n        switch (state_1) {\n            case \"continue-parse\": continue parse;\n        }\n    }\n}\nvar Parser = /** @class */ (function () {\n    function Parser(states, tags, repeats, taggedGoto, untaggedGoto, specialized, specializations, tokenPrec, skip, termNames) {\n        if (termNames === void 0) { termNames = null; }\n        this.states = states;\n        this.tags = tags;\n        this.repeats = repeats;\n        this.taggedGoto = taggedGoto;\n        this.untaggedGoto = untaggedGoto;\n        this.specialized = specialized;\n        this.tokenPrec = tokenPrec;\n        this.skip = skip;\n        this.termNames = termNames;\n        this.specializations = specializations.map(withoutPrototype);\n    }\n    Parser.prototype.getTag = function (term) {\n        return (term & TERM_TAGGED) ? this.tags[term >> 1] : null;\n    };\n    Parser.prototype.getName = function (term) {\n        return this.termNames ? this.termNames[term] : this.getTag(term) || String(term);\n    };\n    // Term should be a repeat term\n    Parser.prototype.getRepeat = function (term) {\n        return this.repeats[term >> 1];\n    };\n    Parser.prototype.parse = function (input, options) {\n        return parse(input, this, options);\n    };\n    Parser.prototype.getGoto = function (state, term) {\n        var table = (term & TERM_TAGGED ? this.taggedGoto : this.untaggedGoto)[term >> 1];\n        for (var i = 0; i < table.length; i += 2) {\n            if (table[i] < 0 || table[i] == state)\n                return table[i + 1];\n        }\n        throw new Error(\"Missing goto table entry for \" + this.getName(term) + \" and state \" + state);\n    };\n    return Parser;\n}());\nexport { Parser };\nfunction withoutPrototype(obj) {\n    if (!(obj instanceof Object))\n        return obj;\n    var result = Object.create(null);\n    for (var prop in obj)\n        if (Object.prototype.hasOwnProperty.call(obj, prop))\n            result[prop] = obj[prop];\n    return result;\n}\n//# sourceMappingURL=parse.js.map","map":"{\"version\":3,\"file\":\"parse.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/parse.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/parse.d.ts","writeByteOrderMark":false,"text":"import { ParseState } from \"./state\";\nimport { InputStream } from \"./token\";\nimport { SyntaxTree } from \"./tree\";\nexport declare const SPECIALIZE = 0, REPLACE = 1, EXTEND = 2;\nexport declare type ParseOptions = {\n    cache?: SyntaxTree | null;\n    strict?: boolean;\n    bufferLength?: number;\n};\nexport declare function parse(input: InputStream, parser: Parser, { cache, strict, bufferLength }?: ParseOptions): SyntaxTree;\nexport declare class Parser {\n    readonly states: readonly ParseState[];\n    readonly tags: readonly string[];\n    readonly repeats: readonly number[];\n    readonly taggedGoto: readonly (readonly number[])[];\n    readonly untaggedGoto: readonly (readonly number[])[];\n    readonly specialized: readonly number[];\n    readonly tokenPrec: number[];\n    readonly skip: readonly number[];\n    readonly termNames: null | {\n        [id: number]: string;\n    };\n    readonly specializations: readonly {\n        [value: string]: number;\n    }[];\n    constructor(states: readonly ParseState[], tags: readonly string[], repeats: readonly number[], taggedGoto: readonly (readonly number[])[], untaggedGoto: readonly (readonly number[])[], specialized: readonly number[], specializations: readonly {\n        [value: string]: number;\n    }[], tokenPrec: number[], skip: readonly number[], termNames?: null | {\n        [id: number]: string;\n    });\n    getTag(term: number): string | null;\n    getName(term: number): string;\n    getRepeat(term: number): number;\n    parse(input: InputStream, options?: ParseOptions): SyntaxTree;\n    getGoto(state: number, term: number): number;\n}\n"}}

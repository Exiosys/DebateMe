{"code":"import { REDUCE_DEPTH_MASK, REDUCE_DEPTH_SIZE } from \"./state\";\nimport { TERM_TAGGED, TERM_ERR } from \"./term\";\nimport { Node, Tree, TreeBuffer } from \"./tree\";\nvar BADNESS_DELETE = 100, BADNESS_RECOVER = 100;\nexport var BADNESS_STABILIZING = 50, BADNESS_WILD = 150; // Limits in between which stacks are less agressively pruned\nvar REUSED_VALUE = -1;\nexport var DEFAULT_BUFFER_LENGTH = 2048;\nexport var MAX_BUFFER_LENGTH = DEFAULT_BUFFER_LENGTH;\nexport function setBufferLength(len) { MAX_BUFFER_LENGTH = len; }\n// (FIXME: this will go out of date before I know it, revisit at some\n// point)\n//\n// Badness is a measure of how off-the-rails a given parse is. It is\n// bumped when a recovery strategy is applied, and then reduced (by\n// multiplication with a constant < 1) for every successful (real)\n// token shifted.\n//\n// Stacks with a low badness are relatively credible parses that have\n// shift matching the input in their recent history. Stacks with a\n// high badness are deeply in the weeds and likely wrong. For each of\n// these, we prune agressively by dropping stacks when another stack\n// at the same position is looking better.\n//\n// For those in the BADNESS_STABILIZING - BADNESS_WILD range, we\n// assume that they are in the process of trying to recover and allow\n// a bunch of them to continue alongside each other to see which one\n// works out better.\n//\n// Stacks with the same low badness score are likely to be valid GLR\n// parsing branches, so in that case it's often a good idea to let\n// both continue.\n//\n// When a stack fails to find an advancing action, recovery is only\n// applied when its badness is < BADNESS_WILD, or no better parse\n// exists at that point.\nvar Stack = /** @class */ (function () {\n    function Stack(parser, // FIXME put these top two in dynamic variables?\n    reused, \n    // Holds state, pos, value stack pos (15 bits array index, 15 bits buffer index) triplets for all but the top state\n    stack, state, pos, badness, \n    // Holds tag,start,end,nodeCount quads\n    buffer, bufferBase, parent) {\n        this.parser = parser;\n        this.reused = reused;\n        this.stack = stack;\n        this.state = state;\n        this.pos = pos;\n        this.badness = badness;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    Stack.prototype.toString = function () {\n        return \"[\" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state.id).join(\",\") + \"]\";\n    };\n    Stack.start = function (parser) {\n        return new Stack(parser, [], [], parser.states[0], 0, 0, [], 0, null);\n    };\n    Stack.prototype.pushState = function (state, start) {\n        this.stack.push(this.state.id, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    };\n    Stack.prototype.reduce = function (action) {\n        var depth = (action & REDUCE_DEPTH_MASK) - 1, tag = action >> REDUCE_DEPTH_SIZE;\n        if (depth == 0) {\n            this.pushState(this.parser.states[this.parser.getGoto(this.state.id, tag)], this.pos);\n            return;\n        }\n        var base = this.stack.length - ((depth - 1) * 3);\n        var start = this.stack[base - 2];\n        var count = this.bufferBase + this.buffer.length - this.stack[base - 1];\n        if ((tag & TERM_TAGGED) > 0 ||\n            ((tag >> 1) < this.parser.repeats.length && this.pos - start > MAX_BUFFER_LENGTH && count > 0))\n            this.buffer.push(tag, start, this.pos, count + 4);\n        var baseStateID = this.stack[base - 3];\n        this.state = this.parser.states[this.parser.getGoto(baseStateID, tag)];\n        if (depth > 1)\n            this.stack.length = base;\n    };\n    Stack.prototype.shiftValue = function (term, start, end, childCount) {\n        if (childCount === void 0) { childCount = 4; }\n        if (term == TERM_ERR) { // Try to omit superfluous error nodes\n            var cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == TERM_ERR &&\n                (start == end || cur.buffer[top - 2] >= start))\n                return;\n        }\n        this.buffer.push(term, start, end, childCount);\n    };\n    Stack.prototype.apply = function (action, next, nextStart, nextEnd, skipped) {\n        if (action >= 0) {\n            this.reduce(action);\n        }\n        else { // Shift\n            this.shiftSkipped(skipped);\n            this.pushState(this.parser.states[-action], nextStart);\n            this.pos = nextEnd;\n            if (next & TERM_TAGGED)\n                this.shiftValue(next, nextStart, nextEnd);\n            this.badness = (this.badness >> 1) + (this.badness >> 2); // (* 0.75)\n        }\n    };\n    Stack.prototype.useCached = function (value, start, next) {\n        var index = this.reused.length - 1;\n        if (index < 0 || this.reused[index] != value) {\n            this.reused.push(value);\n            index++;\n        }\n        this.pos = start + value.length;\n        this.pushState(next, start);\n        this.badness >> 1; // FIXME\n        this.buffer.push(index, start, this.pos, REUSED_VALUE);\n    };\n    Stack.prototype.split = function () {\n        var parent = this;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && parent.buffer.length == 0)\n            parent = parent.parent;\n        return new Stack(this.parser, this.reused, this.stack.slice(), this.state, this.pos, this.badness, [], parent ? parent.bufferBase + parent.buffer.length : 0, parent);\n    };\n    Stack.prototype.shiftSkipped = function (skipped) {\n        for (var i = 0; i < skipped.length; i += 3)\n            this.buffer.push(skipped[i + 2], skipped[i], skipped[i + 1], 4);\n    };\n    Stack.prototype.recoverByDelete = function (next, nextStart, nextEnd, skipped) {\n        this.shiftSkipped(skipped);\n        if (next & TERM_TAGGED)\n            this.shiftValue(next, nextStart, nextEnd);\n        this.shiftValue(TERM_ERR, nextStart, nextEnd, (next & TERM_TAGGED) ? 8 : 4);\n        this.pos = nextEnd;\n        this.badness += BADNESS_DELETE;\n    };\n    Stack.prototype.canShift = function (term) {\n        for (var sim = new SimulatedStack(this);;) {\n            var action = sim.top.defaultReduce;\n            for (var i = 0; action == 0 && i < sim.top.actions.length; i += 2) {\n                if (sim.top.actions[i] == term) {\n                    action = sim.top.actions[i + 1];\n                    break;\n                }\n            }\n            if (action < 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    };\n    Stack.prototype.canRecover = function (next) {\n        // Scan for a state that has either a direct action or a recovery\n        // action for next, without actually building up a new stack\n        var visited = null;\n        for (var sim = new SimulatedStack(this), i = 0;; i++) {\n            if (sim.top.hasAction(next) || sim.top.getRecover(next) != 0)\n                return true;\n            // Find a way to reduce from here\n            var reduce = sim.top.anyReduce();\n            if (reduce == 0 && (reduce = sim.top.forcedReduce) < 0)\n                return false;\n            sim.reduce(reduce);\n            if (i > 10) {\n                // Guard against getting stuck in a cycle\n                if (!visited)\n                    visited = [];\n                else if (i == 100 || visited.includes(sim.top.id))\n                    return false;\n                visited.push(sim.top.id);\n            }\n        }\n    };\n    Stack.prototype.recoverByInsert = function (next, nextStart, nextEnd) {\n        if (!this.canRecover(next))\n            return null;\n        // Now that we know there's a recovery to be found, run the\n        // reduces again, the expensive way, updating the stack\n        var result = this.split();\n        result.badness += BADNESS_RECOVER;\n        for (;;) {\n            for (;;) {\n                if (result.state.hasAction(next))\n                    return result;\n                var recover = result.state.getRecover(next);\n                if (!recover)\n                    break;\n                var pos = result.pos;\n                result.pushState(this.parser.states[recover], pos);\n                result.shiftValue(TERM_ERR, pos, pos);\n            }\n            var reduce = result.state.anyReduce();\n            if (reduce == 0) {\n                // Force a reduce using this state's default reduce\n                result.shiftValue(TERM_ERR, result.pos, result.pos);\n                reduce = result.state.forcedReduce;\n            }\n            result.reduce(reduce);\n        }\n    };\n    Stack.prototype.compare = function (other) {\n        return this.pos - other.pos || this.badness - other.badness;\n    };\n    Stack.prototype.put = function (parses, strict) {\n        if (strict === void 0) { strict = this.badness < BADNESS_STABILIZING || this.badness > BADNESS_WILD; }\n        for (var i = 0; i < parses.length; i++) {\n            var other = parses[i];\n            if ((strict || other.state == this.state) && other.pos == this.pos) {\n                var diff = this.badness - other.badness || (this.badness < BADNESS_STABILIZING ? 0 : this.stack.length - other.stack.length);\n                if (diff < 0) {\n                    parses[i] = this;\n                    return true;\n                }\n                else if (diff > 0)\n                    return false;\n            }\n        }\n        // Binary heap add\n        var index = parses.push(this) - 1;\n        while (index > 0) {\n            var parentIndex = index >> 1, parent = parses[parentIndex];\n            if (this.compare(parent) >= 0)\n                break;\n            parses[index] = parent;\n            parses[parentIndex] = this;\n            index = parentIndex;\n        }\n        return true;\n    };\n    Stack.take = function (parses) {\n        // Binary heap pop\n        var elt = parses[0], replacement = parses.pop();\n        if (parses.length == 0)\n            return elt;\n        parses[0] = replacement;\n        for (var index = 0;;) {\n            var childIndex = (index << 1) + 1;\n            if (childIndex >= parses.length)\n                break;\n            var child = parses[childIndex];\n            if (childIndex + 1 < parses.length && child.compare(parses[childIndex + 1]) >= 0) {\n                child = parses[childIndex + 1];\n                childIndex++;\n            }\n            if (replacement.compare(child) < 0)\n                break;\n            parses[childIndex] = replacement;\n            parses[index] = child;\n            index = childIndex;\n        }\n        return elt;\n    };\n    Stack.prototype.toTree = function () {\n        var children = [], positions = [];\n        var cursor = new BufferCursor(this);\n        while (!cursor.done)\n            cursor.takeNode(0, children, positions);\n        return new Tree(children.reverse(), positions.reverse());\n    };\n    return Stack;\n}());\nexport { Stack };\nvar SimulatedStack = /** @class */ (function () {\n    function SimulatedStack(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    SimulatedStack.prototype.reduce = function (action) {\n        var term = action >> REDUCE_DEPTH_SIZE, depth = (action & REDUCE_DEPTH_MASK) - 1;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top.id, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        var goto = this.stack.parser.getGoto(this.rest[this.offset - 3], term);\n        this.top = this.stack.parser.states[goto];\n    };\n    return SimulatedStack;\n}());\nvar BALANCE_BRANCH_FACTOR = 5;\nvar BufferCursor = /** @class */ (function () {\n    function BufferCursor(stack) {\n        this.stack = stack;\n        this.taken = 0;\n        this.buffer = stack.buffer;\n        this.index = this.buffer.length;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    BufferCursor.prototype.maybeNext = function () {\n        var next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    };\n    Object.defineProperty(BufferCursor.prototype, \"tag\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(BufferCursor.prototype, \"done\", {\n        get: function () { return this.index == 0; },\n        enumerable: true,\n        configurable: true\n    });\n    BufferCursor.prototype.forward = function () {\n        this.index -= 4;\n        this.taken += 4;\n        if (this.index == 0)\n            this.maybeNext();\n    };\n    BufferCursor.prototype.takeNode = function (parentStart, children, positions) {\n        var _a = this, tag = _a.tag, start = _a.start, end = _a.end, size = _a.size;\n        if (size == REUSED_VALUE) {\n            this.forward();\n            children.push(this.stack.reused[tag]);\n            positions.push(start - parentStart);\n        }\n        else if (end - start > MAX_BUFFER_LENGTH) { // Too big for a buffer, make it a node\n            var endCount = this.taken + size;\n            this.forward();\n            var localChildren = [], localPositions = [];\n            while (this.taken < endCount)\n                this.takeNode(start, localChildren, localPositions);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (tag & TERM_TAGGED)\n                children.push(new Node(tag, end - start, localChildren, localPositions));\n            else\n                children.push(this.balanceRange(this.stack.parser.getRepeat(tag), localChildren, localPositions, 0, localChildren.length));\n            positions.push(start - parentStart);\n        }\n        else {\n            var _b = this.findBufferStart(size, start, end), bufferSize = _b.bufferSize, bufferStart = _b.bufferStart;\n            var buffer = new Uint16Array(bufferSize);\n            var endCount = this.taken + bufferSize, index = bufferSize;\n            while (this.taken < endCount)\n                index = this.copyToBuffer(bufferStart, buffer, index);\n            children.push(new TreeBuffer(buffer));\n            positions.push(bufferStart - parentStart);\n        }\n    };\n    BufferCursor.prototype.balanceRange = function (tag, children, positions, from, to) {\n        var start = positions[from], length = (positions[to - 1] + children[to - 1].length) - start;\n        if (from == to - 1 && start == 0) {\n            var first = children[from];\n            if (first instanceof Node)\n                return first;\n        }\n        var localChildren = [], localPositions = [];\n        if (length <= MAX_BUFFER_LENGTH) {\n            for (var i = from; i < to; i++) {\n                var child = children[i];\n                if (child instanceof Node && child.tag == tag) {\n                    // Unwrap child with same tag\n                    for (var j = 0; j < child.children.length; j++) {\n                        localChildren.push(child.children[j]);\n                        localPositions.push(positions[i] + child.positions[j] - start);\n                    }\n                }\n                else {\n                    localChildren.push(child);\n                    localPositions.push(positions[i] - start);\n                }\n            }\n        }\n        else {\n            var maxChild = Math.max(MAX_BUFFER_LENGTH, Math.ceil(length / BALANCE_BRANCH_FACTOR));\n            for (var i = from; i < to;) {\n                var groupFrom = i, groupStart = positions[i];\n                i++;\n                for (; i < to; i++) {\n                    var nextEnd = positions[i] + children[i].length;\n                    if (nextEnd - groupStart > maxChild)\n                        break;\n                }\n                if (i == groupFrom + 1) {\n                    var only = children[groupFrom];\n                    if (only instanceof Node && only.tag == tag) {\n                        // Already tagged\n                        if (only.length > maxChild << 1) { // Too big, collapse\n                            for (var j = 0; j < only.children.length; j++) {\n                                localChildren.push(only.children[j]);\n                                localPositions.push(only.positions[j] + groupStart - start);\n                            }\n                            continue;\n                        }\n                    }\n                    else {\n                        // Wrap with our tag to make reuse possible\n                        only = new Node(tag, only.length, [only], [0]);\n                    }\n                    localChildren.push(only);\n                }\n                else {\n                    localChildren.push(this.balanceRange(tag, children, positions, groupFrom, i));\n                }\n                localPositions.push(groupStart - start);\n            }\n        }\n        return new Node(tag, length, localChildren, localPositions);\n    };\n    BufferCursor.prototype.findBufferStart = function (size, start, end) {\n        var stack = this.stack, index = this.index, skip = size;\n        outer: for (;;) {\n            for (;;) { // Forward stack/index to provide access to next node\n                if (index > skip) {\n                    index -= skip;\n                    break;\n                }\n                if (!stack.parent)\n                    break outer;\n                skip -= index;\n                index = stack.bufferBase - stack.parent.bufferBase;\n                stack = stack.parent;\n            }\n            var nextSize = stack.buffer[index - 1];\n            var nextStart = stack.buffer[index - 3];\n            if (nextSize == REUSED_VALUE || end - nextStart > MAX_BUFFER_LENGTH)\n                break outer;\n            start = nextStart;\n            size += nextSize;\n            skip = nextSize;\n        }\n        return { bufferSize: size, bufferStart: start };\n    };\n    BufferCursor.prototype.copyToBuffer = function (bufferStart, buffer, index) {\n        var _a = this, tag = _a.tag, start = _a.start, end = _a.end, size = _a.size;\n        this.forward();\n        if (size > 4) {\n            var firstChildIndex = index - (size - 4);\n            while (index > firstChildIndex)\n                index = this.copyToBuffer(bufferStart, buffer, index);\n        }\n        buffer[--index] = (size >> 2) - 1;\n        buffer[--index] = end - bufferStart;\n        buffer[--index] = start - bufferStart;\n        buffer[--index] = tag;\n        return index;\n    };\n    return BufferCursor;\n}());\n//# sourceMappingURL=stack.js.map","map":"{\"version\":3,\"file\":\"stack.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/stack.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAa,iBAAiB,EAAE,iBAAiB,EAAC,MAAM,SAAS,CAAA;AACxE,OAAO,EAAC,WAAW,EAAE,QAAQ,EAAC,MAAM,QAAQ,CAAA;AAE5C,OAAO,EAAC,IAAI,EAAE,IAAI,EAAE,UAAU,EAAa,MAAM,QAAQ,CAAA;AAEzD,IAAM,cAAc,GAAG,GAAG,EAAE,eAAe,GAAG,GAAG,CAAA;AACjD,MAAM,CAAC,IAAM,mBAAmB,GAAG,EAAE,EAAE,YAAY,GAAG,GAAG,CAAA,CAAC,6DAA6D;AAEvH,IAAM,YAAY,GAAG,CAAC,CAAC,CAAA;AAEvB,MAAM,CAAC,IAAM,qBAAqB,GAAG,IAAI,CAAA;AACzC,MAAM,CAAC,IAAI,iBAAiB,GAAG,qBAAqB,CAAA;AAEpD,MAAM,UAAU,eAAe,CAAC,GAAW,IAAI,iBAAiB,GAAG,GAAG,CAAA,CAAC,CAAC;AAExE,qEAAqE;AACrE,SAAS;AACT,EAAE;AACF,oEAAoE;AACpE,mEAAmE;AACnE,kEAAkE;AAClE,iBAAiB;AACjB,EAAE;AACF,qEAAqE;AACrE,kEAAkE;AAClE,qEAAqE;AACrE,oEAAoE;AACpE,0CAA0C;AAC1C,EAAE;AACF,gEAAgE;AAChE,qEAAqE;AACrE,oEAAoE;AACpE,oBAAoB;AACpB,EAAE;AACF,oEAAoE;AACpE,kEAAkE;AAClE,iBAAiB;AACjB,EAAE;AACF,mEAAmE;AACnE,iEAAiE;AACjE,wBAAwB;AAExB;IACE,eAAqB,MAAc,EAAE,gDAAgD;IAChE,MAAc;IACvB,mHAAmH;IAC1G,KAAe,EACjB,KAAiB,EACjB,GAAW,EACX,OAAe;IACtB,sCAAsC;IAC7B,MAAgB,EAChB,UAAkB,EAClB,MAAoB;QAVpB,WAAM,GAAN,MAAM,CAAQ;QACd,WAAM,GAAN,MAAM,CAAQ;QAEd,UAAK,GAAL,KAAK,CAAU;QACjB,UAAK,GAAL,KAAK,CAAY;QACjB,QAAG,GAAH,GAAG,CAAQ;QACX,YAAO,GAAP,OAAO,CAAQ;QAEb,WAAM,GAAN,MAAM,CAAU;QAChB,eAAU,GAAV,UAAU,CAAQ;QAClB,WAAM,GAAN,MAAM,CAAc;IAAG,CAAC;IAE7C,wBAAQ,GAAR;QACE,OAAO,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,UAAC,CAAC,EAAE,CAAC,IAAK,OAAA,CAAC,GAAG,CAAC,IAAI,CAAC,EAAV,CAAU,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAA;IAC5F,CAAC;IAEM,WAAK,GAAZ,UAAa,MAAc;QACzB,OAAO,IAAI,KAAK,CAAC,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAA;IACvE,CAAC;IAED,yBAAS,GAAT,UAAU,KAAiB,EAAE,KAAa;QACxC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;QAC3E,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;IACpB,CAAC;IAED,sBAAM,GAAN,UAAO,MAAc;QACnB,IAAI,KAAK,GAAG,CAAC,MAAM,GAAG,iBAAiB,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,IAAI,iBAAiB,CAAA;QAC/E,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,CAAA;YACrF,OAAM;SACP;QAED,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;QAChD,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;QAChC,IAAI,KAAK,GAAG,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;QACvE,IAAI,CAAC,GAAG,GAAG,WAAW,CAAC,GAAG,CAAC;YACvB,CAAC,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,GAAG,GAAG,KAAK,GAAG,iBAAiB,IAAI,KAAK,GAAG,CAAC,CAAC;YAChG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,CAAC,CAAC,CAAA;QACnD,IAAI,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;QACtC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,CAAA;QACtE,IAAI,KAAK,GAAG,CAAC;YAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAA;IACzC,CAAC;IAED,0BAAU,GAAV,UAAW,IAAY,EAAE,KAAa,EAAE,GAAW,EAAE,UAAc;QAAd,2BAAA,EAAA,cAAc;QACjE,IAAI,IAAI,IAAI,QAAQ,EAAE,EAAE,sCAAsC;YAC5D,IAAI,GAAG,GAAiB,IAAI,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;YACtD,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,MAAM,EAAE;gBAC1B,GAAG,GAAG,GAAG,CAAC,UAAU,GAAG,GAAG,CAAC,MAAM,CAAC,UAAU,CAAA;gBAC5C,GAAG,GAAG,GAAG,CAAC,MAAM,CAAA;aACjB;YACD,IAAI,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,QAAQ;gBAC1C,CAAC,KAAK,IAAI,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,KAAK,CAAC;gBAAE,OAAM;SAC3D;QACD,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,UAAU,CAAC,CAAA;IAChD,CAAC;IAED,qBAAK,GAAL,UAAM,MAAc,EAAE,IAAY,EAAE,SAAiB,EAAE,OAAe,EAAE,OAAiB;QACvF,IAAI,MAAM,IAAI,CAAC,EAAE;YACf,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;SACpB;aAAM,EAAE,QAAQ;YACf,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA;YAC1B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,EAAE,SAAS,CAAC,CAAA;YACtD,IAAI,CAAC,GAAG,GAAG,OAAO,CAAA;YAClB,IAAI,IAAI,GAAG,WAAW;gBAAE,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,CAAA;YACjE,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,CAAC,CAAC,CAAA,CAAC,WAAW;SACrE;IACH,CAAC;IAED,yBAAS,GAAT,UAAU,KAAW,EAAE,KAAa,EAAE,IAAgB;QACpD,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAA;QAClC,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,KAAK,EAAE;YAC5C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YACvB,KAAK,EAAE,CAAA;SACR;QACD,IAAI,CAAC,GAAG,GAAG,KAAK,GAAG,KAAK,CAAC,MAAM,CAAA;QAC/B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAA;QAC3B,IAAI,CAAC,OAAO,IAAI,CAAC,CAAA,CAAC,QAAQ;QAC1B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,EAAE,YAAY,CAAC,CAAA;IACxD,CAAC;IAED,qBAAK,GAAL;QACE,IAAI,MAAM,GAAiB,IAAI,CAAA;QAC/B,uFAAuF;QACvF,OAAO,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC;YAAE,MAAM,GAAG,MAAM,CAAC,MAAM,CAAA;QAClE,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,GAAG,EAClE,IAAI,CAAC,OAAO,EAAE,EAAE,EAAE,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAA;IACnG,CAAC;IAED,4BAAY,GAAZ,UAAa,OAAiB;QAC5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC;YACxC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAA;IACnE,CAAC;IAED,+BAAe,GAAf,UAAgB,IAAY,EAAE,SAAiB,EAAE,OAAe,EAAE,OAAiB;QACjF,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA;QAC1B,IAAI,IAAI,GAAG,WAAW;YAAE,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,CAAA;QACjE,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,IAAI,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;QAC3E,IAAI,CAAC,GAAG,GAAG,OAAO,CAAA;QAClB,IAAI,CAAC,OAAO,IAAI,cAAc,CAAA;IAChC,CAAC;IAED,wBAAQ,GAAR,UAAS,IAAY;QACnB,KAAK,IAAI,GAAG,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,IAAI;YACzC,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,aAAa,CAAA;YAClC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;gBACjE,IAAI,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE;oBAC9B,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAA;oBAC/B,MAAK;iBACN;aACF;YACD,IAAI,MAAM,GAAG,CAAC;gBAAE,OAAO,IAAI,CAAA;YAC3B,IAAI,MAAM,IAAI,CAAC;gBAAE,OAAO,KAAK,CAAA;YAC7B,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;SACnB;IACH,CAAC;IAED,0BAAU,GAAV,UAAW,IAAY;QACrB,iEAAiE;QACjE,4DAA4D;QAC5D,IAAI,OAAO,GAAoB,IAAI,CAAA;QACnC,KAAK,IAAI,GAAG,GAAG,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,EAAE;YACpD,IAAI,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;gBAAE,OAAO,IAAI,CAAA;YACzE,iCAAiC;YACjC,IAAI,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,SAAS,EAAE,CAAA;YAChC,IAAI,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC;gBAAE,OAAO,KAAK,CAAA;YACpE,GAAG,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;YAClB,IAAI,CAAC,GAAG,EAAE,EAAE;gBACV,yCAAyC;gBACzC,IAAI,CAAC,OAAO;oBAAE,OAAO,GAAG,EAAE,CAAA;qBACrB,IAAI,CAAC,IAAI,GAAG,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC;oBAAE,OAAO,KAAK,CAAA;gBAC/D,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;aACzB;SACF;IACH,CAAC;IAED,+BAAe,GAAf,UAAgB,IAAY,EAAE,SAAiB,EAAE,OAAe;QAC9D,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAA;QAEvC,2DAA2D;QAC3D,uDAAuD;QACvD,IAAI,MAAM,GAAG,IAAI,CAAC,KAAK,EAAE,CAAA;QACzB,MAAM,CAAC,OAAO,IAAI,eAAe,CAAA;QACjC,SAAS;YACP,SAAS;gBACP,IAAI,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC;oBAAE,OAAO,MAAM,CAAA;gBAC/C,IAAI,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;gBAC3C,IAAI,CAAC,OAAO;oBAAE,MAAK;gBACnB,IAAI,GAAG,GAAG,MAAM,CAAC,GAAG,CAAA;gBACpB,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,GAAG,CAAC,CAAA;gBAClD,MAAM,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,EAAE,GAAG,CAAC,CAAA;aACtC;YAED,IAAI,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,EAAE,CAAA;YACrC,IAAI,MAAM,IAAI,CAAC,EAAE;gBACf,mDAAmD;gBACnD,MAAM,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAA;gBACnD,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,YAAY,CAAA;aACnC;YACD,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;SACtB;IACH,CAAC;IAED,uBAAO,GAAP,UAAQ,KAAY;QAClB,OAAO,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,CAAA;IAC7D,CAAC;IAED,mBAAG,GAAH,UAAI,MAAe,EAAE,MAA0E;QAA1E,uBAAA,EAAA,SAAS,IAAI,CAAC,OAAO,GAAG,mBAAmB,IAAI,IAAI,CAAC,OAAO,GAAG,YAAY;QAC7F,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACtC,IAAI,KAAK,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;YACrB,IAAI,CAAC,MAAM,IAAI,KAAK,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE;gBAClE,IAAI,IAAI,GAAG,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA;gBAC5H,IAAI,IAAI,GAAG,CAAC,EAAE;oBAAE,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;oBAAC,OAAO,IAAI,CAAA;iBAAE;qBAC1C,IAAI,IAAI,GAAG,CAAC;oBAAE,OAAO,KAAK,CAAA;aAChC;SACF;QAED,kBAAkB;QAClB,IAAI,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QACjC,OAAO,KAAK,GAAG,CAAC,EAAE;YAChB,IAAI,WAAW,GAAG,KAAK,IAAI,CAAC,EAAE,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC,CAAA;YAC1D,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC;gBAAE,MAAK;YACpC,MAAM,CAAC,KAAK,CAAC,GAAG,MAAM,CAAA;YACtB,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAA;YAC1B,KAAK,GAAG,WAAW,CAAA;SACpB;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IAEM,UAAI,GAAX,UAAY,MAAe;QACzB,kBAAkB;QAClB,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,EAAE,WAAW,GAAG,MAAM,CAAC,GAAG,EAAG,CAAA;QAChD,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC;YAAE,OAAO,GAAG,CAAA;QAClC,MAAM,CAAC,CAAC,CAAC,GAAG,WAAW,CAAA;QACvB,KAAK,IAAI,KAAK,GAAG,CAAC,IAAI;YACpB,IAAI,UAAU,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAA;YACjC,IAAI,UAAU,IAAI,MAAM,CAAC,MAAM;gBAAE,MAAK;YACtC,IAAI,KAAK,GAAG,MAAM,CAAC,UAAU,CAAC,CAAA;YAC9B,IAAI,UAAU,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;gBAChF,KAAK,GAAG,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAA;gBAC9B,UAAU,EAAE,CAAA;aACb;YACD,IAAI,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC;gBAAE,MAAK;YACzC,MAAM,CAAC,UAAU,CAAC,GAAG,WAAW,CAAA;YAChC,MAAM,CAAC,KAAK,CAAC,GAAG,KAAK,CAAA;YACrB,KAAK,GAAG,UAAU,CAAA;SACnB;QACD,OAAO,GAAG,CAAA;IACZ,CAAC;IAED,sBAAM,GAAN;QACE,IAAI,QAAQ,GAA0B,EAAE,EAAE,SAAS,GAAa,EAAE,CAAA;QAClE,IAAI,MAAM,GAAG,IAAI,YAAY,CAAC,IAAI,CAAC,CAAA;QACnC,OAAO,CAAC,MAAM,CAAC,IAAI;YAAE,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAA;QAC5D,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,EAAE,SAAS,CAAC,OAAO,EAAE,CAAC,CAAA;IAC1D,CAAC;IACH,YAAC;AAAD,CAAC,AAxND,IAwNC;;AAED;IAIE,wBAAqB,KAAY;QAAZ,UAAK,GAAL,KAAK,CAAO;QAC/B,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC,KAAK,CAAA;QACtB,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,KAAK,CAAA;QACvB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAA;IAChC,CAAC;IAED,+BAAM,GAAN,UAAO,MAAc;QACnB,IAAI,IAAI,GAAG,MAAM,IAAI,iBAAiB,EAAE,KAAK,GAAG,CAAC,MAAM,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAA;QAChF,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK;gBAAE,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAA;YAChE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAA;YACjC,IAAI,CAAC,MAAM,IAAI,CAAC,CAAA;SACjB;aAAM;YACL,IAAI,CAAC,MAAM,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAA;SAC/B;QACD,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA;QACtE,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;IAC3C,CAAC;IACH,qBAAC;AAAD,CAAC,AAtBD,IAsBC;AAED,IAAM,qBAAqB,GAAG,CAAC,CAAA;AAE/B;IAKE,sBAAmB,KAAY;QAAZ,UAAK,GAAL,KAAK,CAAO;QAF/B,UAAK,GAAG,CAAC,CAAA;QAGP,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,CAAA;QAC1B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAA;QAC/B,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC;YAAE,IAAI,CAAC,SAAS,EAAE,CAAA;IACvC,CAAC;IAED,gCAAS,GAAT;QACE,IAAI,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAA;QAC5B,IAAI,IAAI,IAAI,IAAI,EAAE;YAChB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAA;YACpD,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;YACjB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAA;SAC1B;IACH,CAAC;IAED,sBAAI,6BAAG;aAAP,cAAY,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAChD,sBAAI,+BAAK;aAAT,cAAc,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAClD,sBAAI,6BAAG;aAAP,cAAY,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAChD,sBAAI,8BAAI;aAAR,cAAa,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAEjD,sBAAI,8BAAI;aAAR,cAAa,OAAO,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA,CAAC,CAAC;;;OAAA;IAErC,8BAAO,GAAP;QACE,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA;QACf,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA;QACf,IAAI,IAAI,CAAC,KAAK,IAAI,CAAC;YAAE,IAAI,CAAC,SAAS,EAAE,CAAA;IACvC,CAAC;IAED,+BAAQ,GAAR,UAAS,WAAmB,EAAE,QAA+B,EAAE,SAAmB;QAC5E,IAAA,SAA8B,EAA7B,YAAG,EAAE,gBAAK,EAAE,YAAG,EAAE,cAAY,CAAA;QAClC,IAAI,IAAI,IAAI,YAAY,EAAE;YACxB,IAAI,CAAC,OAAO,EAAE,CAAA;YACd,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAA;YACrC,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,CAAA;SACpC;aAAM,IAAI,GAAG,GAAG,KAAK,GAAG,iBAAiB,EAAE,EAAE,uCAAuC;YACnF,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAA;YAChC,IAAI,CAAC,OAAO,EAAE,CAAA;YACd,IAAI,aAAa,GAA0B,EAAE,EAAE,cAAc,GAAa,EAAE,CAAA;YAC5E,OAAO,IAAI,CAAC,KAAK,GAAG,QAAQ;gBAAE,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,aAAa,EAAE,cAAc,CAAC,CAAA;YACjF,aAAa,CAAC,OAAO,EAAE,CAAC;YAAC,cAAc,CAAC,OAAO,EAAE,CAAA;YACjD,IAAI,GAAG,GAAG,WAAW;gBACnB,QAAQ,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,GAAG,KAAK,EAAE,aAAa,EAAE,cAAc,CAAC,CAAC,CAAA;;gBAExE,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,aAAa,EAAE,cAAc,EAAE,CAAC,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC,CAAA;YAC5H,SAAS,CAAC,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,CAAA;SACpC;aAAM;YACD,IAAA,2CAAkE,EAAjE,0BAAU,EAAE,4BAAqD,CAAA;YACtE,IAAI,MAAM,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,CAAA;YACxC,IAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,GAAG,UAAU,EAAE,KAAK,GAAG,UAAU,CAAA;YAC1D,OAAO,IAAI,CAAC,KAAK,GAAG,QAAQ;gBAC1B,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;YACvD,QAAQ,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC,CAAA;YACrC,SAAS,CAAC,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC,CAAA;SAC1C;IACH,CAAC;IAED,mCAAY,GAAZ,UAAa,GAAW,EACX,QAAwC,EAAE,SAA4B,EACtE,IAAY,EAAE,EAAU;QACnC,IAAI,KAAK,GAAG,SAAS,CAAC,IAAI,CAAC,EAAE,MAAM,GAAG,CAAC,SAAS,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,QAAQ,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,KAAK,CAAA;QAC3F,IAAI,IAAI,IAAI,EAAE,GAAG,CAAC,IAAI,KAAK,IAAI,CAAC,EAAE;YAChC,IAAI,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAA;YAC1B,IAAI,KAAK,YAAY,IAAI;gBAAE,OAAO,KAAK,CAAA;SACxC;QACD,IAAI,aAAa,GAAG,EAAE,EAAE,cAAc,GAAG,EAAE,CAAA;QAC3C,IAAI,MAAM,IAAI,iBAAiB,EAAE;YAC/B,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;gBAC9B,IAAI,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAA;gBACvB,IAAI,KAAK,YAAY,IAAI,IAAI,KAAK,CAAC,GAAG,IAAI,GAAG,EAAE;oBAC7C,6BAA6B;oBAC7B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;wBAC9C,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;wBACrC,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAA;qBAC/D;iBACF;qBAAM;oBACL,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;oBACzB,cAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAA;iBAC1C;aACF;SACF;aAAM;YACL,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,iBAAiB,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,qBAAqB,CAAC,CAAC,CAAA;YACrF,KAAK,IAAI,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,EAAE,GAAG;gBAC1B,IAAI,SAAS,GAAG,CAAC,EAAE,UAAU,GAAG,SAAS,CAAC,CAAC,CAAC,CAAA;gBAC5C,CAAC,EAAE,CAAA;gBACH,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;oBAClB,IAAI,OAAO,GAAG,SAAS,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAA;oBAC/C,IAAI,OAAO,GAAG,UAAU,GAAG,QAAQ;wBAAE,MAAK;iBAC3C;gBACD,IAAI,CAAC,IAAI,SAAS,GAAG,CAAC,EAAE;oBACtB,IAAI,IAAI,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAA;oBAC9B,IAAI,IAAI,YAAY,IAAI,IAAI,IAAI,CAAC,GAAG,IAAI,GAAG,EAAE;wBAC3C,iBAAiB;wBACjB,IAAI,IAAI,CAAC,MAAM,GAAG,QAAQ,IAAI,CAAC,EAAE,EAAE,oBAAoB;4BACrD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gCAC7C,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;gCACpC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,KAAK,CAAC,CAAA;6BAC5D;4BACD,SAAQ;yBACT;qBACF;yBAAM;wBACL,2CAA2C;wBAC3C,IAAI,GAAG,IAAI,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAA;qBAC/C;oBACD,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;iBACzB;qBAAM;oBACL,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC,CAAA;iBAC9E;gBACD,cAAc,CAAC,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC,CAAA;aACxC;SACF;QACD,OAAO,IAAI,IAAI,CAAC,GAAG,EAAE,MAAM,EAAE,aAAa,EAAE,cAAc,CAAC,CAAA;IAC7D,CAAC;IAED,sCAAe,GAAf,UAAgB,IAAY,EAAE,KAAa,EAAE,GAAW;QACtD,IAAI,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,IAAI,GAAG,IAAI,CAAA;QACvD,KAAK,EAAE,SAAS;YACd,SAAS,EAAE,qDAAqD;gBAC9D,IAAI,KAAK,GAAG,IAAI,EAAE;oBAAE,KAAK,IAAI,IAAI,CAAC;oBAAC,MAAK;iBAAE;gBAC1C,IAAI,CAAC,KAAK,CAAC,MAAM;oBAAE,MAAM,KAAK,CAAA;gBAC9B,IAAI,IAAI,KAAK,CAAA;gBACb,KAAK,GAAG,KAAK,CAAC,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,UAAU,CAAA;gBAClD,KAAK,GAAG,KAAK,CAAC,MAAM,CAAA;aACrB;YACD,IAAI,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;YACtC,IAAI,SAAS,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,GAAG,CAAC,CAAC,CAAA;YACvC,IAAI,QAAQ,IAAI,YAAY,IAAI,GAAG,GAAG,SAAS,GAAG,iBAAiB;gBAAE,MAAM,KAAK,CAAA;YAChF,KAAK,GAAG,SAAS,CAAA;YACjB,IAAI,IAAI,QAAQ,CAAA;YAChB,IAAI,GAAG,QAAQ,CAAA;SAChB;QACD,OAAO,EAAC,UAAU,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAC,CAAA;IAC/C,CAAC;IAED,mCAAY,GAAZ,UAAa,WAAmB,EAAE,MAAmB,EAAE,KAAa;QAC9D,IAAA,SAA8B,EAA7B,YAAG,EAAE,gBAAK,EAAE,YAAG,EAAE,cAAY,CAAA;QAClC,IAAI,CAAC,OAAO,EAAE,CAAA;QACd,IAAI,IAAI,GAAG,CAAC,EAAE;YACZ,IAAI,eAAe,GAAG,KAAK,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAA;YACxC,OAAO,KAAK,GAAG,eAAe;gBAC5B,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,WAAW,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;SACxD;QACD,MAAM,CAAC,EAAE,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAA;QACjC,MAAM,CAAC,EAAE,KAAK,CAAC,GAAG,GAAG,GAAG,WAAW,CAAA;QACnC,MAAM,CAAC,EAAE,KAAK,CAAC,GAAG,KAAK,GAAG,WAAW,CAAA;QACrC,MAAM,CAAC,EAAE,KAAK,CAAC,GAAG,GAAG,CAAA;QACrB,OAAO,KAAK,CAAA;IACd,CAAC;IACH,mBAAC;AAAD,CAAC,AAxJD,IAwJC\"}","dts":{"name":"/home/marijn/src/lezer/lezer/stack.d.ts","writeByteOrderMark":false,"text":"import { ParseState } from \"./state\";\nimport { Parser } from \"./parse\";\nimport { Node, SyntaxTree } from \"./tree\";\nexport declare const BADNESS_STABILIZING = 50, BADNESS_WILD = 150;\nexport declare const DEFAULT_BUFFER_LENGTH = 2048;\nexport declare let MAX_BUFFER_LENGTH: number;\nexport declare function setBufferLength(len: number): void;\nexport declare class Stack {\n    readonly parser: Parser;\n    readonly reused: Node[];\n    readonly stack: number[];\n    state: ParseState;\n    pos: number;\n    badness: number;\n    readonly buffer: number[];\n    readonly bufferBase: number;\n    readonly parent: Stack | null;\n    constructor(parser: Parser, // FIXME put these top two in dynamic variables?\n    reused: Node[], stack: number[], state: ParseState, pos: number, badness: number, buffer: number[], bufferBase: number, parent: Stack | null);\n    toString(): string;\n    static start(parser: Parser): Stack;\n    pushState(state: ParseState, start: number): void;\n    reduce(action: number): void;\n    shiftValue(term: number, start: number, end: number, childCount?: number): void;\n    apply(action: number, next: number, nextStart: number, nextEnd: number, skipped: number[]): void;\n    useCached(value: Node, start: number, next: ParseState): void;\n    split(): Stack;\n    shiftSkipped(skipped: number[]): void;\n    recoverByDelete(next: number, nextStart: number, nextEnd: number, skipped: number[]): void;\n    canShift(term: number): boolean;\n    canRecover(next: number): boolean;\n    recoverByInsert(next: number, nextStart: number, nextEnd: number): Stack | null;\n    compare(other: Stack): number;\n    put(parses: Stack[], strict?: boolean): boolean;\n    static take(parses: Stack[]): Stack;\n    toTree(): SyntaxTree;\n}\n"}}

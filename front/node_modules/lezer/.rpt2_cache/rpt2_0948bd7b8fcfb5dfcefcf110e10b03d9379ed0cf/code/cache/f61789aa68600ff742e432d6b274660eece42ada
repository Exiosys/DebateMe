{"code":"import { Tree, NodeProp } from \"lezer-tree\";\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nvar Stack = /** @class */ (function () {\n    /// @internal\n    function Stack(\n    // A group of values that the stack will share with all\n    // split instances\n    ///@internal\n    cx, \n    // Holds state, pos, value stack pos (15 bits array index, 15 bits\n    // buffer index) triplets for all but the top state\n    /// @internal\n    stack, \n    // The current parse state\n    /// @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    // The input position up to which this stack has parsed.\n    pos, \n    // The amount of error-recovery that happened on this stack\n    /// @internal\n    recovered, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.cx = cx;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.recovered = recovered;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.parent = parent;\n    }\n    /// @internal\n    Stack.prototype.toString = function () {\n        return \"[\" + this.stack.filter(function (_, i) { return i % 3 == 0; }).concat(this.state) + \"]@\" + this.pos + (this.recovered ? \"!\" + this.recovered : \"\");\n    };\n    // Start an empty stack\n    /// @internal\n    Stack.start = function (cx, pos) {\n        if (pos === void 0) { pos = 0; }\n        return new Stack(cx, [], cx.parser.states[0], pos, pos, 0, [], 0, null);\n    };\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    Stack.prototype.pushState = function (state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    };\n    // Apply a reduce action\n    /// @internal\n    Stack.prototype.reduce = function (action) {\n        var depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        var parser = this.cx.parser;\n        if (depth == 0) {\n            // Zero-depth reductions are a special caseâ€”they add stuff to\n            // the stack without popping anything off.\n            if (type <= parser.maxNode)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        var base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        var start = this.stack[base - 2];\n        var bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        if (type <= parser.maxNode && ((action & 131072 /* RepeatFlag */) || !parser.group.types[type].prop(NodeProp.repeated))) {\n            var pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            var baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n    };\n    // Shift a value into the buffer\n    /// @internal\n    Stack.prototype.storeNode = function (term, start, end, size, isReduce) {\n        if (size === void 0) { size = 4; }\n        if (isReduce === void 0) { isReduce = false; }\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            var cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            var index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    };\n    // Apply a shift action\n    /// @internal\n    Stack.prototype.shift = function (action, next, nextEnd) {\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            var start = this.pos, nextState = action, parser = this.cx.parser;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            if (next <= this.cx.parser.maxNode)\n                this.buffer.push(next, this.pos, nextEnd, 4);\n            this.pos = nextEnd;\n        }\n    };\n    // Apply an action\n    /// @internal\n    Stack.prototype.apply = function (action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    };\n    // Add a prebuilt node into the buffer. This may be a reused node or\n    // the result of running a nested parser.\n    /// @internal\n    Stack.prototype.useNode = function (value, next) {\n        var index = this.cx.reused.length - 1;\n        if (index < 0 || this.cx.reused[index] != value) {\n            this.cx.reused.push(value);\n            index++;\n        }\n        var start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size < 0 means this is a reused value */);\n    };\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    Stack.prototype.split = function () {\n        var parent = this;\n        var off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        var buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.cx, this.stack.slice(), this.state, this.reducePos, this.pos, this.recovered, buffer, base, parent);\n    };\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    Stack.prototype.recoverByDelete = function (next, nextEnd) {\n        var isNode = next <= this.cx.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.recovered++;\n    };\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    Stack.prototype.canShift = function (term) {\n        for (var sim = new SimulatedStack(this);;) {\n            var action = this.cx.parser.stateSlot(sim.top, 4 /* DefaultReduce */) || this.cx.parser.hasAction(sim.top, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    };\n    Object.defineProperty(Stack.prototype, \"ruleStart\", {\n        /// Find the start position of the rule that is currently being parsed.\n        get: function () {\n            var force = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n            if (!(force & 65536 /* ReduceFlag */))\n                return 0;\n            var base = this.stack.length - (3 * (force >> 19 /* ReduceDepthShift */));\n            return this.stack[base + 1];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /// Find the start position of the innermost instance of any of the\n    /// given term types, or return `-1` when none of them are found.\n    ///\n    /// **Note:** this is only reliable when there is at least some\n    /// state that unambiguously matches the given rule on the stack.\n    /// I.e. if you have a grammar like this, where the difference\n    /// between `a` and `b` is only apparent at the third token:\n    ///\n    ///     a { b | c }\n    ///     b { \"x\" \"y\" \"x\" }\n    ///     c { \"x\" \"y\" \"z\" }\n    ///\n    /// Then a parse state after `\"x\"` will not reliably tell you that\n    /// `b` is on the stack. You _can_ pass `[b, c]` to reliably check\n    /// for either of those two rules (assuming that `a` isn't part of\n    /// some rule that includes other things starting with `\"x\"`).\n    Stack.prototype.startOf = function (types) {\n        for (var frame = this.stack.length; frame >= 0; frame -= 3) {\n            var state = frame == this.stack.length ? this.state : this.stack[frame];\n            var force = this.cx.parser.stateSlot(state, 5 /* ForcedReduce */);\n            if (types.includes(force & 65535 /* ValueMask */)) {\n                var base = frame - (3 * (force >> 19 /* ReduceDepthShift */));\n                return this.stack[base + 1];\n            }\n        }\n        return -1;\n    };\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    Stack.prototype.recoverByInsert = function (next) {\n        var _this = this;\n        var nextStates = this.cx.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */) {\n            var best = nextStates.filter(function (s) { return s != _this.state && _this.cx.parser.hasAction(s, next); });\n            for (var i = 0; best.length < 4 /* MaxNext */ && i < nextStates.length; i++)\n                if (!best.includes(nextStates[i]))\n                    best.push(nextStates[i]);\n            nextStates = best;\n        }\n        var result = [];\n        for (var i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i++) {\n            if (nextStates[i] == this.state)\n                continue;\n            var stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(nextStates[i], this.pos);\n            stack.recovered++;\n            result.push(stack);\n        }\n        return result;\n    };\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    Stack.prototype.forceReduce = function () {\n        var reduce = this.cx.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        if (!this.cx.parser.validAction(this.state, reduce)) {\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.recovered++;\n        }\n        this.reduce(reduce);\n        return true;\n    };\n    /// @internal\n    Stack.prototype.forceAll = function () {\n        while (!this.cx.parser.stateFlag(this.state, 2 /* Accepting */) && this.forceReduce()) { }\n        return this;\n    };\n    // Convert the stack's buffer to a syntax tree.\n    /// @internal\n    Stack.prototype.toTree = function () {\n        return Tree.build(StackBufferCursor.create(this), this.cx.parser.group, 1 /* Top */, this.cx.maxBufferLength, this.cx.reused);\n    };\n    return Stack;\n}());\nexport { Stack };\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nvar SimulatedStack = /** @class */ (function () {\n    function SimulatedStack(stack) {\n        this.stack = stack;\n        this.top = stack.state;\n        this.rest = stack.stack;\n        this.offset = this.rest.length;\n    }\n    SimulatedStack.prototype.reduce = function (action) {\n        var term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.rest == this.stack.stack)\n                this.rest = this.rest.slice();\n            this.rest.push(this.top, 0, 0);\n            this.offset += 3;\n        }\n        else {\n            this.offset -= (depth - 1) * 3;\n        }\n        var goto = this.stack.cx.parser.getGoto(this.rest[this.offset - 3], term, true);\n        this.top = goto;\n    };\n    return SimulatedStack;\n}());\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nvar StackBufferCursor = /** @class */ (function () {\n    function StackBufferCursor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    StackBufferCursor.create = function (stack) {\n        return new StackBufferCursor(stack, stack.bufferBase + stack.buffer.length, stack.buffer.length);\n    };\n    StackBufferCursor.prototype.maybeNext = function () {\n        var next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    };\n    Object.defineProperty(StackBufferCursor.prototype, \"id\", {\n        get: function () { return this.buffer[this.index - 4]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"start\", {\n        get: function () { return this.buffer[this.index - 3]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"end\", {\n        get: function () { return this.buffer[this.index - 2]; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StackBufferCursor.prototype, \"size\", {\n        get: function () { return this.buffer[this.index - 1]; },\n        enumerable: true,\n        configurable: true\n    });\n    StackBufferCursor.prototype.next = function () {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    };\n    StackBufferCursor.prototype.fork = function () {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    };\n    return StackBufferCursor;\n}());\n//# sourceMappingURL=stack.js.map","map":"{\"version\":3,\"file\":\"stack.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/stack.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/marijn/src/lezer/lezer/stack.d.ts","writeByteOrderMark":false,"text":"import { StackContext } from \"./parse\";\nimport { Tree } from \"lezer-tree\";\nexport declare class Stack {\n    readonly cx: StackContext;\n    readonly stack: number[];\n    state: number;\n    reducePos: number;\n    pos: number;\n    recovered: number;\n    readonly buffer: number[];\n    readonly bufferBase: number;\n    readonly parent: Stack | null;\n    constructor(cx: StackContext, stack: number[], state: number, reducePos: number, pos: number, recovered: number, buffer: number[], bufferBase: number, parent: Stack | null);\n    toString(): string;\n    static start(cx: StackContext, pos?: number): Stack;\n    pushState(state: number, start: number): void;\n    reduce(action: number): void;\n    storeNode(term: number, start: number, end: number, size?: number, isReduce?: boolean): void;\n    shift(action: number, next: number, nextEnd: number): void;\n    apply(action: number, next: number, nextEnd: number): void;\n    useNode(value: Tree, next: number): void;\n    split(): Stack;\n    recoverByDelete(next: number, nextEnd: number): void;\n    canShift(term: number): boolean;\n    get ruleStart(): number;\n    startOf(types: readonly number[]): number;\n    recoverByInsert(next: number): Stack[];\n    forceReduce(): boolean;\n    forceAll(): this;\n    toTree(): Tree;\n}\n"}}
